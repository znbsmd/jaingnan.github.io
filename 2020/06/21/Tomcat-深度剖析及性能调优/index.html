

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;dark&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="来啦，老弟，这里是 AKA 190">
  <meta name="author" content="190coder">
  <meta name="keywords" content="Java Php hexo Thinking in Java">
  <title>Tomcat 深度剖析及性能调优 - 190呐</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>190coder</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-06-21 21:30" pubdate>
      2020年6月21日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      7.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      90
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Tomcat 深度剖析及性能调优</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="一、Tomcat-系统架构与原理剖析"><a href="#一、Tomcat-系统架构与原理剖析" class="headerlink" title="一、Tomcat 系统架构与原理剖析"></a>一、Tomcat 系统架构与原理剖析</h1><p>b/s（浏览器/服务器模式） 浏览器是客户端（发送http请求） ———&gt; 服务器端</p>
<h2 id="1-浏览器访问服务器的流程"><a href="#1-浏览器访问服务器的流程" class="headerlink" title="1. 浏览器访问服务器的流程"></a>1. 浏览器访问服务器的流程</h2><p>http请求的处理过程：<br><img src="https://img-blog.csdnimg.cn/20200620122417265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="http请求处理流程"></p>
<h2 id="2-Tomcat-系统总体架构"><a href="#2-Tomcat-系统总体架构" class="headerlink" title="2. Tomcat 系统总体架构"></a>2. Tomcat 系统总体架构</h2><h4 id="2-1-Tomcat-请求处理⼤致过程"><a href="#2-1-Tomcat-请求处理⼤致过程" class="headerlink" title="2.1 Tomcat 请求处理⼤致过程"></a>2.1 Tomcat 请求处理⼤致过程</h4><p>Tomcat是⼀个Http服务器（能够接收并且处理http请求，所以tomcat是⼀个http服务器）<br><img src="https://img-blog.csdnimg.cn/20200620122828349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Tomcat请求流程"><br>Servlet接⼝和Servlet容器这⼀整套内容叫作Servlet规范。<br>Tomcat 两个重要的身份 1. http服务器 2. Servlet 容器</p>
<h4 id="2-2-Tomcat-Servlet容器处理流程"><a href="#2-2-Tomcat-Servlet容器处理流程" class="headerlink" title="2.2 Tomcat Servlet容器处理流程"></a>2.2 Tomcat Servlet容器处理流程</h4><p>当⽤户请求某个URL资源时<br>1）HTTP服务器会把请求信息使⽤ServletRequest对象封装起来<br>2）进⼀步去调⽤Servlet容器中某个具体的Servlet<br>3）在 2）中，<strong>Servlet容器拿到请求后，根据URL和Servlet的映射关系，找到相应的Servlet</strong><br>4）如果Servlet还没有被加载，就⽤<strong>反射机制创建这个Servlet，并调⽤Servlet的init⽅法来完成初始化</strong><br>5）接着调⽤这个具体Servlet的service⽅法来处理请求，请求处理结果使⽤ServletResponse对象封装<br>6）把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端<br><img src="https://img-blog.csdnimg.cn/20200620124116245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="servlet处理流程"></p>
<h4 id="2-3-Tomcat-系统总体架构"><a href="#2-3-Tomcat-系统总体架构" class="headerlink" title="2.3 Tomcat 系统总体架构"></a>2.3 Tomcat 系统总体架构</h4><p><img src="https://img-blog.csdnimg.cn/20200620124724476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="总体架构图"><br><strong>连接器，负责对外交流</strong>： 处理Socket连接，负责⽹络字节流与Request和Response对象的转化；<br><strong>容器，负责内部处理</strong>：加载和管理Servlet，以及具体处理Request请求；</p>
<h2 id="3-Tomcat-连接器组件-Coyote"><a href="#3-Tomcat-连接器组件-Coyote" class="headerlink" title="3. Tomcat 连接器组件 Coyote"></a>3. Tomcat 连接器组件 Coyote</h2><h4 id="3-1-Coyote-简介"><a href="#3-1-Coyote-简介" class="headerlink" title="3.1 Coyote 简介"></a>3.1 Coyote 简介</h4><p>Coyote 是Tomcat 中连接器的组件名称 , 是对外的接⼝。客户端通过Coyote与服务器建⽴连接、发送请<br>求并接受响应 。<br>（1）Coyote 封装了底层的⽹络通信（Socket 请求及响应处理）<br>（2）Coyote 使Catalina 容器（容器组件）与具体的请求协议及IO操作⽅式完全解耦<br>（3）Coyote 将Socket 输⼊转换封装为 Request 对象，进⼀步封装后交由Catalina 容器进⾏处理，处<br>理请求完成后, Catalina 通过Coyote 提供的Response 对象将结果写⼊输出流<br>（4）<strong>Coyote 负责的是具体协议（应⽤层）和IO（传输层）相关内容</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200620125035665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Coyote"><br>Tomcat⽀持多种应⽤层协议和I/O模型，如下：<br><img src="https://img-blog.csdnimg.cn/20200620125154474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Tomcat支持应用协议"><br>在 8.0 之前 ，Tomcat 默认采⽤的I/O⽅式为 BIO。</p>
<h4 id="3-2-Coyote-的内部组件及流程"><a href="#3-2-Coyote-的内部组件及流程" class="headerlink" title="3.2 Coyote 的内部组件及流程"></a>3.2 Coyote 的内部组件及流程</h4><p><img src="https://img-blog.csdnimg.cn/20200620125637616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Coyote内部处理组件流程"></p>
<p>Coyote 组件以及作用 ：</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">EndPoint</td>
<td align="left">EndPoint 是监听的接⼝，是Socket接收和发送处理器，是对传输层的抽象，因此EndPoint⽤来实现TCP/IP协议的</td>
</tr>
<tr>
<td align="left">Processor</td>
<td align="left">Processor 是Coyote 协议处理接⼝，Processor⽤来实现HTTP协议，Processor接收来⾃EndPoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应⽤层协议的抽象</td>
</tr>
<tr>
<td align="left">ProtocolHandler</td>
<td align="left">Coyote 协议接⼝， 通过Endpoint 和 Processor ， 实现针对具体协议的处理能⼒。Tomcat 按照协议和I/O 提供了6个实现类 ： AjpNioProtocol ，AjpAprProtocol，AjpNio2Protocol ，Http11NioProtocol Http11Nio2Protocol ，Http11AprProtocol</td>
</tr>
<tr>
<td align="left">Adapter</td>
<td align="left">协议不同，请求信息也不同，Tomcat定义了Request封装信息。将ProtocolHandler 处理成 ServletRequest，这是经典的适配器模式，连接器调用CoyoteAdapter的Sevice⽅法，将Tomcat Request -&gt; ServletRequest</td>
</tr>
</tbody></table>
<h2 id="4-Tomcat-Servlet-容器-Catalina"><a href="#4-Tomcat-Servlet-容器-Catalina" class="headerlink" title="4. Tomcat Servlet 容器 Catalina"></a>4. Tomcat Servlet 容器 Catalina</h2><h4 id="4-1-Tomcat-模块分层结构图及Catalina位置"><a href="#4-1-Tomcat-模块分层结构图及Catalina位置" class="headerlink" title="4.1 Tomcat 模块分层结构图及Catalina位置"></a>4.1 Tomcat 模块分层结构图及Catalina位置</h4><p>Tomcat 可以通过 （conf/server.xml）的组件构成的Web容器，⽽Catalina是Tomcat的<br>servlet容器。<strong>Catalina 才是 Tomcat 的核⼼。</strong> 其他模块都是为Catalina 提供⽀撑的。 ⽐如 ： 通过 Coyote 模块提供链接通信，Jasper 模块提供 JSP 引擎，Naming 提供JNDI 服务，Juli 提供⽇志服务。</p>
<p><img src="https://img-blog.csdnimg.cn/20200620131348121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Catalina分层结构图"></p>
<h4 id="4-2-Servlet-容器-Catalina-的结构"><a href="#4-2-Servlet-容器-Catalina-的结构" class="headerlink" title="4.2 Servlet 容器 Catalina 的结构"></a>4.2 Servlet 容器 Catalina 的结构</h4><p>Catalina实例<img src="https://img-blog.csdnimg.cn/20200620131908197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="catalina实例图"><br>可认知为整个Tomcat就是一个Catalina实例，Tomcat启动会初始化这个实例，<strong>Catalina 实例通过加载server.xml 完成其他实例创建，创建管理一个Server，Server创建多个Serivce，每个Service有多个Connector 和一个Container。</strong></p>
<p><strong>⚠️：多个Connector 对应 一个 Container/Engine</strong></p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">作用描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Catalina</td>
<td align="left">解析conf/server.xml，以此创建Server并管理。</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">表示整个Catalina Servlet容器以及其他组件，负责启动Servlet引擎，Tomcat连接器Connector</td>
</tr>
<tr>
<td align="left">Service</td>
<td align="left">Server内部组件，⼀个Server包含多个Service。它将若⼲个Connector组件绑定到⼀个Container</td>
</tr>
<tr>
<td align="left">Container</td>
<td align="left">容器，负责处理⽤户的servlet请求，并返回对象给web⽤户的模块</td>
</tr>
</tbody></table>
<h4 id="4-3-Container-组件的具体结构"><a href="#4-3-Container-组件的具体结构" class="headerlink" title="4.3 Container 组件的具体结构"></a>4.3 Container 组件的具体结构</h4><p>Container组件下有⼏种具体的组件，分别是Engine、Host、Context和Wrapper。这4种组件（容器）<br>是⽗⼦关系。（<strong>都是一对多</strong>）Tomcat通过⼀种分层的架构，使得Servlet容器具有很好的灵活性。包含如下组件：</p>
<ul>
<li>Engine ：表示整个Catalina的Servlet引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine，但是可以包含多个Host。</li>
<li>Host ：代表一个虚拟主机，（例如一个<a href="http://www.abc.com域名就是一个虚拟主机），而一个虚拟主机可以包含多个Context。" target="_blank" rel="noopener">www.abc.com域名就是一个虚拟主机），而一个虚拟主机可以包含多个Context。</a></li>
<li>Context ：代表一个Web应用，⼀个Web应⽤可包含多个Wrapper。</li>
<li>Wrapper ：表示⼀个Servlet，Wrapper 作为容器中的最底层，不能包含⼦容器</li>
</ul>
<p><strong>上述组件的配置其实就体现在conf/server.xml中。</strong></p>
<h1 id="二、Tomcat-服务器核⼼配置详解"><a href="#二、Tomcat-服务器核⼼配置详解" class="headerlink" title="二、Tomcat 服务器核⼼配置详解"></a>二、Tomcat 服务器核⼼配置详解</h1><h2 id="1-配置路径-amp-如何配置"><a href="#1-配置路径-amp-如何配置" class="headerlink" title="1. 配置路径 &amp; 如何配置"></a>1. 配置路径 &amp; 如何配置</h2><p>根目录 -&gt; conf/server.xml，server.xml中包含了 Servlet容器的相关配置，即 Catalina 的配置。主要是标签的使用。</p>
<h4 id="主要标签结构如下："><a href="#主要标签结构如下：" class="headerlink" title="主要标签结构如下："></a>主要标签结构如下：</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">&lt;!--Server 根元素，创建⼀个Server实例，⼦标签有 Listener、GlobalNamingResources、Service--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Server</span>&gt;</span>
<span class="hljs-comment">&lt;!--定义监听器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Listener</span>/&gt;</span>
<span class="hljs-comment">&lt;!--定义服务器的全局JNDI资源 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>/&gt;</span>
<span class="hljs-comment">&lt;!--定义⼀个Service服务，⼀个Server标签可以有多个Service服务实例--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Service</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre></div>

<h6 id="Server-标签"><a href="#Server-标签" class="headerlink" title="Server 标签"></a>Server 标签</h6><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--port：关闭服务器的监听端⼝ shutdown：关闭服务器的指令字符串--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8005"</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">"SHUTDOWN"</span>&gt;</span>
	<span class="hljs-comment">&lt;!-- 以⽇志形式输出服务器 、操作系统、JVM的版本信息 --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span>
	<span class="hljs-comment">&lt;!-- Security listener. Documentation at /docs/config/listeners.html
	&lt;Listener className="org.apache.catalina.security.SecurityListener" /&gt;
	--&gt;</span>
	<span class="hljs-comment">&lt;!--APR library loader. Documentation at /docs/apr.html --&gt;</span>
	<span class="hljs-comment">&lt;!-- 加载（服务器启动） 和 销毁 （服务器停⽌） APR。 如果找不到APR库， 则会输出⽇志， 并
	不影响 Tomcat启动 --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.AprLifecycleListener"</span>
	<span class="hljs-attr">SSLEngine</span>=<span class="hljs-string">"on"</span> /&gt;</span>
	<span class="hljs-comment">&lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;</span>
	<span class="hljs-comment">&lt;!-- 避免JRE内存泄漏问题 --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span>
	<span class="hljs-comment">&lt;!-- 加载（服务器启动） 和 销毁（服务器停⽌） 全局命名服务 --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span>
	<span class="hljs-comment">&lt;!-- 在Context停⽌时重建 Executor 池中的线程， 以避免ThreadLocal 相关的内存泄漏 --&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span>
	
	<span class="hljs-comment">&lt;!-- Global JNDI resources
	Documentation at /docs/jndi-resources-howto.html
	GlobalNamingResources 中定义了全局命名服务
	--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>&gt;</span>
	<span class="hljs-comment">&lt;!-- Editable user database that can also be used by
	UserDatabaseRealm to authenticate users
	--&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"UserDatabase"</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.apache.catalina.UserDatabase"</span>
		<span class="hljs-attr">description</span>=<span class="hljs-string">"User database that can be updated and saved"</span>
		<span class="hljs-attr">factory</span>=<span class="hljs-string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span>
		<span class="hljs-attr">pathname</span>=<span class="hljs-string">"conf/tomcat-users.xml"</span> /&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">GlobalNamingResources</span>&gt;</span>
<span class="hljs-comment">&lt;!-- A "Service" is a collection of one or more "Connectors" that share
a single "Container" <span class="hljs-doctag">Note:</span> A "Service" is not itself a "Container",
so you may not define subcomponents such as "Valves" at this level.
Documentation at /docs/config/service.html
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span></code></pre></div>

<h6 id="Service-标签"><a href="#Service-标签" class="headerlink" title="Service 标签"></a>Service 标签</h6><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--
该标签⽤于创建 Service 实例，默认使⽤ org.apache.catalina.core.StandardService。
默认情况下，Tomcat 仅指定了Service 的名称， 值为 "Catalina"。
Service ⼦标签为 ： Listener、Executor、Connector、Engine，
其中：
Listener ⽤于为Service添加⽣命周期监听器，
Executor ⽤于配置Service 共享线程池，
Connector ⽤于配置Service 包含的链接器，
Engine ⽤于配置Service中链接器对应的Servlet 容器引擎
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span></code></pre></div>

<h6 id="Executor-标签"><a href="#Executor-标签" class="headerlink" title="Executor 标签"></a>Executor 标签</h6><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 默认情况下，Service 并未添加共享线程池配置。 如果我们想添加⼀个线程池， 可以在
&lt;Service&gt; 下添加如下配置：
name：线程池名称，⽤于 Connector中指定
namePrefix：所创建的每个线程的名称前缀，⼀个单独的线程名称为
namePrefix+threadNumber
maxThreads：池中最⼤线程数
minSpareThreads：活跃线程数，也就是核⼼池线程数，这些线程不会被销毁，会⼀直存在
maxIdleTime：线程空闲时间，超过该时间后，空闲线程会被销毁，默认值为6000（1分钟），单位
毫秒
maxQueueSize：在被执⾏前最⼤线程排队数⽬，默认为Int的最⼤值，也就是⼴义的⽆限。除⾮特
殊情况，这个值 不需要更改，否则会有请求不会被处理的情况发⽣
prestartminSpareThreads：启动线程池时是否启动 minSpareThreads部分线程。默认值为
false，即不启动
threadPriority：线程池中线程优先级，默认值为5，值从1到10
className：线程池实现类，未指定情况下，默认实现类为
org.apache.catalina.core.StandardThreadExecutor。如果想使⽤⾃定义线程池⾸先需要实现
org.apache.catalina.Executor接⼝
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Executor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"commonThreadPool"</span>
<span class="hljs-attr">namePrefix</span>=<span class="hljs-string">"thread-exec-"</span>
<span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"200"</span>
<span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"100"</span>
<span class="hljs-attr">maxIdleTime</span>=<span class="hljs-string">"60000"</span>
<span class="hljs-attr">maxQueueSize</span>=<span class="hljs-string">"Integer.MAX_VALUE"</span>
<span class="hljs-attr">prestartminSpareThreads</span>=<span class="hljs-string">"false"</span>
<span class="hljs-attr">threadPriority</span>=<span class="hljs-string">"5"</span>
<span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.StandardThreadExecutor"</span>/&gt;</span></code></pre></div>

<h6 id="Connector-标签"><a href="#Connector-标签" class="headerlink" title="Connector 标签"></a>Connector 标签</h6><p>Connector 标签⽤于创建链接器实例<br>默认情况下，server.xml 配置了两个链接器，⼀个⽀持HTTP协议，⼀个⽀持AJP协议<br>⼤多数情况下，我们并不需要新增链接器配置，只是根据需要对已有链接器进⾏优化</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--
port：
端⼝号，Connector ⽤于创建服务端Socket 并进⾏监听， 以等待客户端请求链接。如果该属性设置
为0， Tomcat将会随机选择⼀个可⽤的端⼝号给当前Connector 使⽤
protocol：
当前Connector ⽀持的访问协议。 默认为 HTTP/1.1 ， 并采⽤⾃动切换机制选择⼀个基于 JAVA
NIO 的链接器或者基于本地APR的链接器（根据本地是否含有Tomcat的本地库判定）
connectionTimeOut:
Connector 接收链接后的等待超时时间， 单位为 毫秒。 -1 表示不超时。
redirectPort：
当前Connector 不⽀持SSL请求， 接收到了⼀个请求， 并且也符合security-constraint 约束，
需要SSL传输，Catalina⾃动将请求重定向到指定的端⼝。
executor：
指定共享线程池的名称， 也可以通过maxThreads、minSpareThreads 等属性配置内部线程池。
URIEncoding:
⽤于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 , Tomcat7.x版本默认为ISO-
8859-1
--&gt;</span>
<span class="hljs-comment">&lt;!--org.apache.coyote.http11.Http11NioProtocol ， ⾮阻塞式 Java NIO 链接器--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
<span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8009"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"AJP/1.3"</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span></code></pre></div>

<p>可以使⽤共享线程池</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span>
		<span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span>
		<span class="hljs-attr">executor</span>=<span class="hljs-string">"commonThreadPool"</span>
		<span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"1000"</span>
		<span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"100"</span>
		<span class="hljs-attr">acceptCount</span>=<span class="hljs-string">"1000"</span>
		<span class="hljs-attr">maxConnections</span>=<span class="hljs-string">"1000"</span>
		<span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
		<span class="hljs-attr">compression</span>=<span class="hljs-string">"on"</span>
		<span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">"2048"</span>
		<span class="hljs-attr">disableUploadTimeout</span>=<span class="hljs-string">"true"</span>
		<span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span>
		<span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></code></pre></div>

<h6 id="Engine-标签"><a href="#Engine-标签" class="headerlink" title="Engine 标签"></a>Engine 标签</h6><p>Engine 表示 Servlet 引擎</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--
name： ⽤于指定Engine 的名称， 默认为Catalina
defaultHost：默认使⽤的虚拟主机名称， 当客户端请求指向的主机⽆效时， 将交由默认的虚拟主机处
理， 默认为localhost
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">Engine</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span> <span class="hljs-attr">defaultHost</span>=<span class="hljs-string">"localhost"</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span></code></pre></div>

<h6 id="Host-标签"><a href="#Host-标签" class="headerlink" title="Host 标签"></a>Host 标签</h6><p>Host 标签⽤于配置⼀个虚拟主机</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"localhost"</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span> <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span>
...
<span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span></code></pre></div>

<h6 id="Context-标签"><a href="#Context-标签" class="headerlink" title="Context 标签"></a>Context 标签</h6><p>Context 标签⽤于配置⼀个Web应⽤，如下：</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"www.abc.com"</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span> <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span>
<span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span>
<span class="hljs-comment">&lt;!--
docBase：Web应⽤⽬录或者War包的部署路径。可以是绝对路径，也可以是相对于 Host appBase的
相对路径。
path：Web应⽤的Context 路径。如果我们Host名为localhost， 则该web应⽤访问的根路径为：
http://localhost:8080/web_demo。
--&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"/Users/yingdian/web_demo"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/web3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span>
		<span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span>
		<span class="hljs-attr">prefix</span>=<span class="hljs-string">"localhost_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span>
		<span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span></code></pre></div>

<p><strong>注：Context 不配置 path 默认 还是走Host</strong></p>
<h1 id="三、⼿写实现迷你版-Tomcat"><a href="#三、⼿写实现迷你版-Tomcat" class="headerlink" title="三、⼿写实现迷你版 Tomcat"></a>三、⼿写实现迷你版 Tomcat</h1><p>实现简单功能 ：<br>1）提供服务，接收请求（Socket通信）<br>2）请求信息封装成Request对象（Response对象）<br>3）客户端请求资源，资源分为静态资源（html）和动态资源（Servlet）<br>4）资源返回给客户端浏览器</p>
<p>源码地址 -&gt; xxxxx</p>
<h1 id="四、Tomcat-源码构建及核⼼流程源码剖析"><a href="#四、Tomcat-源码构建及核⼼流程源码剖析" class="headerlink" title="四、Tomcat 源码构建及核⼼流程源码剖析"></a>四、Tomcat 源码构建及核⼼流程源码剖析</h1><h2 id="1-源码构建"><a href="#1-源码构建" class="headerlink" title="1. 源码构建"></a>1. 源码构建</h2><h4 id="1-1-下载源码"><a href="#1-1-下载源码" class="headerlink" title="1.1 下载源码"></a>1.1 下载源码</h4><p>地址为 ：<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a> -&gt; Source Code Distributions -&gt; tar.gz</p>
<h4 id="1-2-源码导⼊IDE之前准备⼯作"><a href="#1-2-源码导⼊IDE之前准备⼯作" class="headerlink" title="1.2 源码导⼊IDE之前准备⼯作"></a>1.2 源码导⼊IDE之前准备⼯作</h4><ul>
<li>解压 tar.gz 压缩包，得到⽬录 apache-tomcat-8.5.50-src</li>
<li>进⼊ apache-tomcat-8.5.50-src ⽬录，创建⼀个pom.xml⽂件，⽂件内容如下<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>
         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>
         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0
http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apache-tomcat-8.5.50-src<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.5<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>
        <span class="hljs-comment">&lt;!--指定源⽬录--&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.5<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>
            <span class="hljs-comment">&lt;!--引⼊编译插件--&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>
    <span class="hljs-comment">&lt;!--tomcat 依赖的基础包--&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.easymock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easymock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxrpc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.soap<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.xml.soap-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div>

</li>
</ul>
<ul>
<li><p>在 apache-tomcat-8.5.50-src ⽬录中创建 source ⽂件夹</p>
</li>
<li><p>将 conf、webapps ⽬录移动到刚刚创建的 source ⽂件夹中 (为了方便调试管理)</p>
</li>
</ul>
<h4 id="1-3-导⼊源码⼯程到IDE并进⾏配置"><a href="#1-3-导⼊源码⼯程到IDE并进⾏配置" class="headerlink" title="1.3 导⼊源码⼯程到IDE并进⾏配置"></a>1.3 导⼊源码⼯程到IDE并进⾏配置</h4><ul>
<li><p>将源码⼯程导⼊到 IDEA 中</p>
</li>
<li><p>给 tomcat 的源码程序启动类 Bootstrap 配置 VM 参数，因为 tomcat 源码运⾏也需要加载配置⽂件等。</p>
<div class="hljs"><pre><code class="hljs undefined"> -Dcatalina.home=/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-<span class="hljs-number">8.5</span>.<span class="hljs-number">50</span>-src/source
-Dcatalina.base=/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-<span class="hljs-number">8.5</span>.<span class="hljs-number">50</span>-src/source
-Djava<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.manager</span>=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.juli</span><span class="hljs-selector-class">.ClassLoaderLogManager</span>
-Djava<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.file</span>=/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-<span class="hljs-number">8.5</span>.<span class="hljs-number">50</span>-src/source/conf/logging.properties</code></pre></div>
</li>
<li><p>执行BootStrap main 启动 tomcat，访问会遇到Jsp引擎Jasper没有被初始化，在 org.apache.catalina.startup.ContextConfig -&gt;configureStart 加入 context.addServletContainerInitializer(new JasperInitializer(),null);<br><img src="https://img-blog.csdnimg.cn/20200621153744777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="描述代码"></p>
</li>
<li><p>重启Tomcat，至此源码调试环境搭建完成。</p>
</li>
</ul>
<h2 id="2-核⼼流程源码剖析"><a href="#2-核⼼流程源码剖析" class="headerlink" title="2. 核⼼流程源码剖析"></a>2. 核⼼流程源码剖析</h2><h4 id="2-1-生命周期接口Lifecycle"><a href="#2-1-生命周期接口Lifecycle" class="headerlink" title="2.1 生命周期接口Lifecycle"></a>2.1 生命周期接口Lifecycle</h4><ul>
<li>Lifecycle⽣命周期接⼝主要⽅法示意<br><img src="https://img-blog.csdnimg.cn/20200621155048250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Lifecycle方法"></li>
<li>Tomcat中的各容器组件都会涉及创建、销毁等，因此<strong>设计了⽣命周期接⼝Lifecycle进⾏统⼀规范，各容器组件实现Lifecycle接⼝</strong>。<br>继承Lifecycle 的类如下：<br><img src="https://img-blog.csdnimg.cn/20200621154817665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="继承Lifecycle的类"></li>
</ul>
<h4 id="2-2-核⼼流程源码剖析"><a href="#2-2-核⼼流程源码剖析" class="headerlink" title="2.2 核⼼流程源码剖析"></a>2.2 核⼼流程源码剖析</h4><p>源码追踪部分我们关注两个流程：<strong>Tomcat启动流程和Tomcat请求处理流程</strong></p>
<p>Tomcat启动流程 ：<br><img src="https://img-blog.csdnimg.cn/20200621155305466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="启动时序图"><br>Tomcat请求处理流程 ：</p>
<ul>
<li>请求处理流程分析</li>
<li><img src="https://img-blog.csdnimg.cn/20200621155711301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="请求处理流程"></li>
<li>请求处理流程示意图<br><img src="https://img-blog.csdnimg.cn/20200621155848332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="请求流程示意图"></li>
<li>Mapper组件体系结构<br><img src="https://img-blog.csdnimg.cn/20200621160024122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Mapper组件体系结构"></li>
</ul>
<h1 id="五、Tomcat-类加载机制剖析"><a href="#五、Tomcat-类加载机制剖析" class="headerlink" title="五、Tomcat 类加载机制剖析"></a>五、Tomcat 类加载机制剖析</h1><p>Java类（.java）—&gt; 字节码⽂件(.class) —&gt; 字节码⽂件需要被加载到jvm内存当中（这个过程就是⼀个类加载的过程）<br>类加载器（ClassLoader，说⽩了也是⼀个类，jvm启动的时候先把类加载器读取到内存当中去，其他的类（⽐如各种jar中的字节码⽂件，⾃⼰开发的代码编译之后的.class⽂件等等））要说 Tomcat 的类加载机制，⾸先需要来看看 Jvm 的类加载机制，因为 <strong>Tomcat 类加载机制是在 Jvm 类加载机制基础之上进⾏了⼀些变动。</strong></p>
<h2 id="1-JVM-的类加载机制"><a href="#1-JVM-的类加载机制" class="headerlink" title="1. JVM 的类加载机制"></a>1. JVM 的类加载机制</h2><p>JVM 的类加载机制中有⼀个⾮常重要的⻆⾊叫做类加载器（ClassLoader），类加载器有⾃⼰的体系，Jvm内置了⼏种类加载器，包括：引导类加载器、扩展类加载器、系统类加载器，他们之间形成⽗⼦关系，通过 Parent 属性来定义这种关系，最终可以形成树形结构。</p>
<p><img src="https://img-blog.csdnimg.cn/20200621161139924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="类加载结构图"><br><strong>⚠️rt.jar 里为java核⼼库 java.*</strong></p>
<p>另外：⽤户可以⾃定义类加载器（Java编写，⽤户⾃定义的类加载器，可加载指定路径的 class ⽂件）<br>　　当 JVM 运⾏过程中，⽤户⾃定义了类加载器去加载某些类时，会按照下⾯的步骤（⽗类委托机制）<br>　　1） ⽤户⾃⼰的类加载器，把加载请求传给⽗加载器，⽗加载器再传给其⽗加载器，⼀直到加载器树的顶层<br>　　2 ）最顶层的类加载器⾸先针对其特定的位置加载，如果加载不到就转交给⼦类<br>　　3 ）如果⼀直到底层的类加载都没有加载到，那么就会抛出异常 ClassNotFoundException<br>　 因此，按照这个过程可以想到，如果同样在 classpath 指定的⽬录中和⾃⼰⼯作⽬录中存放相同的class，会优先加载 classpath ⽬录中的⽂件。</p>
<h2 id="2-双亲委派机制"><a href="#2-双亲委派机制" class="headerlink" title="2. 双亲委派机制"></a>2. 双亲委派机制</h2><h4 id="2-1-什么是双亲委派机制"><a href="#2-1-什么是双亲委派机制" class="headerlink" title="2.1 什么是双亲委派机制"></a>2.1 什么是双亲委派机制</h4><p>当某个类加载器需要加载某个.class⽂件时，它⾸先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，⾃⼰才会去加载这个类。</p>
<h4 id="2-2-双亲委派机制的作⽤"><a href="#2-2-双亲委派机制的作⽤" class="headerlink" title="2.2 双亲委派机制的作⽤"></a>2.2 双亲委派机制的作⽤</h4><ul>
<li><strong>防⽌重复加载同⼀个.class</strong>。通过委托去向上⾯问⼀问，加载过了，就不⽤再加载⼀遍。保证数据安全。</li>
<li><strong>保证核⼼.class不能被篡改</strong>。通过委托⽅式，不会去篡改核⼼.class，即使篡改也不会去加载，即使加载也不会是同⼀个.class对象了。不同的加载器加载同⼀个.class也不是同⼀个.class对象。这样保证了class执⾏安全（如果⼦类加载器先加载，那么我们可以写⼀些与java.lang包中基础类同名的类， 然后再定义⼀个⼦类加载器，这样整个应⽤使⽤的基础类就都变成我们⾃⼰定义的类了。）<br><strong>⚠️ Object类 —–&gt; ⾃定义类加载器（会出现问题的，那么真正的Object类就可能被篡改了）</strong></li>
</ul>
<h2 id="3-Tomcat-的类加载机制"><a href="#3-Tomcat-的类加载机制" class="headerlink" title="3. Tomcat 的类加载机制"></a>3. Tomcat 的类加载机制</h2><p>Tomcat 的类加载机制相对于 Jvm 的类加载机制做了⼀些改变。<br>没有严格的遵从双亲委派机制，也可以说打破了双亲委派机制<br>⽐如：有⼀个tomcat，webapps下部署了两个应⽤<br>app1/lib/a-1.0.jar com.lagou.edu.Abc<br>app2/lib/a-2.0.jar com.lagou.edu.Abc<br>不同版本中Abc类的内容是不同的，代码是不⼀样的。<br><img src="https://img-blog.csdnimg.cn/20200621162549763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Tomcat类加载机制"></p>
<ul>
<li><p>引导类加载器 和 扩展类加载器 的作⽤不变</p>
</li>
<li><p>系统类加载器正常情况下加载的是 CLASSPATH 下的类，但是 Tomcat 的启动脚本并未使⽤该变量，⽽是加载tomcat启动的类，⽐如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下。也就是说<strong>先不会加载系统类加载器</strong>。</p>
</li>
<li><p>Common 通⽤类加载器加载Tomcat使⽤以及应⽤通⽤的⼀些类，位于CATALINA_HOME/lib下，⽐如servlet-api.jar。</p>
</li>
<li><p>Catalina ClassLoader ⽤于加载服务器内部可⻅类，这些类应⽤程序不能访问。</p>
</li>
<li><p>Shared ClassLoader ⽤于加载应⽤程序共享类，这些类服务器不会依赖。</p>
</li>
<li><p>Webapp ClassLoader，每个应⽤程序都会有⼀个独⼀⽆⼆的Webapp ClassLoader，他⽤来加载本应⽤程序 /WEB-INF/classes 和 /WEB-INF/lib 下的类。</p>
<p>所以tomcat 8.5 默认改变了严格的双亲委派机制，把WebappClassLoader提到前面了。整体加载流程如下：</p>
</li>
<li><p>⾸先从 Bootstrap Classloader加载指定的类</p>
</li>
<li><p>如果未加载到，则从 /WEB-INF/classes加载</p>
</li>
<li><p>如果未加载到，则从 /WEB-INF/lib/*.jar 加载</p>
</li>
<li><p>如果未加载到，则依次从 System、Common、Shared 加载（在这最后⼀步，遵从双亲委派机制</p>
</li>
</ul>
<h1 id="六、Tomcat-对-Https-的⽀持及-Tomcat-性能优化策略"><a href="#六、Tomcat-对-Https-的⽀持及-Tomcat-性能优化策略" class="headerlink" title="六、Tomcat 对 Https 的⽀持及 Tomcat 性能优化策略"></a>六、Tomcat 对 Https 的⽀持及 Tomcat 性能优化策略</h1><h2 id="1-Tomcat-对-HTTPS-的⽀持"><a href="#1-Tomcat-对-HTTPS-的⽀持" class="headerlink" title="1. Tomcat 对 HTTPS 的⽀持"></a>1. Tomcat 对 HTTPS 的⽀持</h2><h4 id="1-1-Https-介绍"><a href="#1-1-Https-介绍" class="headerlink" title="1.1 Https 介绍"></a>1.1 Https 介绍</h4><p>Https是⽤来加强数据传输安全的</p>
<p>HTTPS和HTTP的主要区别 ：</p>
<ol>
<li>HTTPS协议使⽤时需要到电⼦商务认证授权机构（CA）申请SSL证书</li>
<li>HTTP默认使⽤8080端⼝，HTTPS默认使⽤8443端⼝</li>
<li>HTTPS则是具有SSL加密的安全性传输协议，对数据的传输进⾏加密，效果上相当于HTTP的升级<br>版</li>
<li>HTTP的连接是⽆状态的，不安全的；HTTPS协议是由SSL+HTTP协议构建的可进⾏加密传输、身<br>份认证的⽹络协议，⽐HTTP协议安全</li>
</ol>
<h4 id="1-2-HTTPS⼯作原理"><a href="#1-2-HTTPS⼯作原理" class="headerlink" title="1.2 HTTPS⼯作原理"></a>1.2 HTTPS⼯作原理</h4><p><img src="https://img-blog.csdnimg.cn/2020062117000843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Https工作原理"><br>总共是4次建立握手链接。</p>
<ol>
<li>浏览器将自己支持的加密规则发送网站</li>
<li>网站选出加密算法，将身份、证书发回浏览器（证书包括地址、加密公钥、证书颁发机构）</li>
<li>使用公钥加密生成随机密码➕ 握手信息发给网站</li>
<li>网站收到请求使用私钥解出密码，使用密码解密握手信息，使用密码再加密一段握手信息，发送浏览器</li>
<li>浏览器解密并计算握手信息的Hash，如果一致，握手结束</li>
<li>之后的所有通信由之前浏览器生成的随机密码并利用对称加密算法进行加密</li>
</ol>
<h4 id="1-3-Tomcat-对-HTTPS-的⽀持"><a href="#1-3-Tomcat-对-HTTPS-的⽀持" class="headerlink" title="1.3 Tomcat 对 HTTPS 的⽀持"></a>1.3 Tomcat 对 HTTPS 的⽀持</h4><ol>
<li><p>使⽤ JDK 中的 keytool ⼯具⽣成免费的秘钥库⽂件(证书)。</p>
<div class="hljs"><pre><code class="hljs powershell">keytool -genkey -alias zjn -keyalg RSA -keystore zjn.keystore</code></pre></div>
</li>
<li><p>配置conf/server.xml</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8443"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>
<span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">schema</span>=<span class="hljs-string">"https"</span> <span class="hljs-attr">secure</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">SSLEnabled</span>=<span class="hljs-string">"true"</span>&gt;</span>
	<span class="hljs-tag">&lt;<span class="hljs-name">SSLHostConfig</span>&gt;</span>
		<span class="hljs-tag">&lt;<span class="hljs-name">Certificate</span>
			<span class="hljs-attr">certificateKeystoreFile</span>=<span class="hljs-string">"/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-8.5.50-src/source/conf/zjn.keystore"</span> <span class="hljs-attr">certificateKeystorePassword</span>=<span class="hljs-string">"123321"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"RSA"</span>
			/&gt;</span>
	<span class="hljs-tag">&lt;/<span class="hljs-name">SSLHostConfig</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span></code></pre></div>
</li>
<li><p>使⽤https协议访问8443端⼝（<a href="https://localhost:8443）" target="_blank" rel="noopener">https://localhost:8443）</a></p>
</li>
</ol>
<h2 id="2-Tomcat-性能优化策略"><a href="#2-Tomcat-性能优化策略" class="headerlink" title="2. Tomcat 性能优化策略"></a>2. Tomcat 性能优化策略</h2><p>系统性能的衡量指标，主要是响应时间和吞吐量 :</p>
<p>1）响应时间：执⾏某个操作的耗时。<br>2)  吞吐量：系统在给定时间内能够⽀持的事务数量，单位为TPS（Transactions PerSecond的缩写，也<br>就是事务数/秒，⼀个事务是指⼀个客户机向服务器发送请求然后服务器做出反应的过程。</p>
<p>Tomcat优化从两个⽅⾯进⾏ :</p>
<p>1）JVM虚拟机优化（优化内存模型）<br>2）Tomcat⾃身配置的优化（⽐如是否使⽤了共享线程池？IO模型？）</p>
<p>学习优化的原则<br>提供给⼤家优化思路，没有说有明确的参数值⼤家直接去使⽤，必须根据⾃⼰的真实⽣产环境来进⾏调<br>整，调优是⼀个过程</p>
<h4 id="2-1-虚拟机运⾏优化（参数调整）"><a href="#2-1-虚拟机运⾏优化（参数调整）" class="headerlink" title="2.1 虚拟机运⾏优化（参数调整）"></a>2.1 虚拟机运⾏优化（参数调整）</h4><p>Java 虚拟机的运⾏优化主要是内存分配和垃圾回收策略的优化：</p>
<ul>
<li>内存直接影响服务的运⾏效率和吞吐量</li>
<li>垃圾回收机制会不同程度地导致程序运⾏中断（垃圾回收策略不同，垃圾回收次数和回收效率都是<br>不同的）Stop The World～</li>
</ul>
<h6 id="2-1-1-Java-虚拟机内存相关参数"><a href="#2-1-1-Java-虚拟机内存相关参数" class="headerlink" title="2.1.1 Java 虚拟机内存相关参数"></a>2.1.1 Java 虚拟机内存相关参数</h6><table>
<thead>
<tr>
<th align="center">参数</th>
<th align="center">参数作用</th>
<th align="center">优化建议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-server</td>
<td align="center">启动Server，以服务端模式运⾏服</td>
<td align="center">服务端模式建议开启</td>
</tr>
<tr>
<td align="center">-Xms</td>
<td align="center">最小堆内存</td>
<td align="center">建议与-Xmx设置相同</td>
</tr>
<tr>
<td align="center">-Xmx</td>
<td align="center">最⼤堆内存</td>
<td align="center">建议设置为可⽤内存的80%</td>
</tr>
<tr>
<td align="center">-XX:MetaspaceSize</td>
<td align="center">元空间初始值</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-XX:MaxMetaspaceSize</td>
<td align="center">元空间最⼤内存</td>
<td align="center">默认无限</td>
</tr>
<tr>
<td align="center">-XX:NewRatio</td>
<td align="center">年轻代和⽼年代⼤⼩⽐值，取值为整数，默认为2</td>
<td align="center">不需要修改</td>
</tr>
<tr>
<td align="center">-XX:SurvivorRatio</td>
<td align="center">Eden区与Survivor区⼤⼩的⽐值，取值为整数，默认为8</td>
<td align="center">不需要修改</td>
</tr>
</tbody></table>
<p> <strong>JVM内存模型</strong><br><img src="https://img-blog.csdnimg.cn/20200621174250128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="JVM内存模型"></p>
<p>参数调整示例<br>    <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">"-server -Xms2048m -Xmx2048m -XX:MetaspaceSize=256m 
-XX:MaxMetaspaceSize=512m"</span></code></pre></div></p>
<p>将上述参数 放入 /bin/catalina.sh 大长篇注释下方就可以了。<br>调整后查看可使⽤JDK提供的内存映射⼯具</p>
<div class="hljs"><pre><code class="hljs powershell">jhsdb jmap --heap --pid <span class="hljs-number">22498</span>(进程号)</code></pre></div>

<h6 id="2-1-2-垃圾回收（GC）策略"><a href="#2-1-2-垃圾回收（GC）策略" class="headerlink" title="2.1.2 垃圾回收（GC）策略"></a>2.1.2 垃圾回收（GC）策略</h6><p>垃圾回收性能指标 :</p>
<ul>
<li>吞吐量：<strong>⼯作时间（排除GC时间）占总时间的百分⽐</strong>， ⼯作时间并不仅是程序运⾏的时间，还包<br>含内存分配时间。</li>
<li>暂停时间：由垃圾回收导致的应⽤程序停⽌响应次数/时间。</li>
</ul>
<p>垃圾收集器 :</p>
<ul>
<li>串⾏收集器（Serial Collector）<br>单线程执⾏所有的垃圾回收⼯作， 适⽤于单核CPU服务器</li>
</ul>
<p><strong>⼯作进程—–|（单线程）垃圾回收线程进⾏垃圾收集|—⼯作进程继续</strong></p>
<ul>
<li>并⾏收集器（Parallel Collector）</li>
</ul>
<p><strong>⼯作进程—–|（多线程）垃圾回收线程进⾏垃圾收集|—⼯作进程继续</strong><br>⼜称为吞吐量收集器（关注吞吐量）， 以并⾏的⽅式执⾏年轻代的垃圾回收， 该⽅式可以显著降<br>低垃圾回收的开销(指多条垃圾收集线程并⾏⼯作，但此时<strong>⽤户线程仍然处于等待状态</strong>)。适⽤于多<br>处理器或多线程硬件上运⾏的数据量较⼤的应⽤</p>
<ul>
<li>并发收集器（Concurrent Collector）<br>以并发的⽅式执⾏⼤部分垃圾回收⼯作，以缩短垃圾回收的暂停时间。适⽤于那些响应时间优先于<br>吞吐量的应⽤， 因为该收集器虽然最⼩化了暂停时间(<strong>指⽤户线程与垃圾收集线程同时执⾏,但不⼀<br>定是并⾏的，可能会交替进⾏)， 但是会降低应⽤程序的性能</strong></li>
<li>CMS收集器（Concurrent Mark Sweep Collector）</li>
</ul>
<p><strong>并发标记清除收集器</strong>， 适⽤于那些更愿意缩短垃圾回收暂停时间并且负担的起与垃圾回收共享处<br>理器资源的应⽤</p>
<ul>
<li><p>G1收集器（Garbage-First Garbage Collector）<br>适⽤于<strong>⼤容量内存的多核服务器</strong>， 可以在满⾜垃圾回收暂停时间⽬标的同时， 以最⼤可能性实现<br>⾼吞吐量(JDK1.7之后)</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:+UseSerialGC</td>
<td align="left">启⽤串⾏收集器</td>
</tr>
<tr>
<td align="left">-XX:+UseParallelGC</td>
<td align="left">启⽤并⾏垃圾收集器，配置了该选项，那么 -XX:+UseParallelOldGC默认启⽤</td>
</tr>
<tr>
<td align="left">-XX:+UseParNewGC</td>
<td align="left">年轻代采⽤并⾏收集器，如果设置了 -XX:+UseConcMarkSweepGC选项，⾃动启⽤</td>
</tr>
<tr>
<td align="left">-XX:+ParallelGCThreads</td>
<td align="left">年轻代及⽼年代垃圾回收使⽤的线程数。默认值依赖于JVM使⽤的CPU个数</td>
</tr>
<tr>
<td align="left">-XX:+UseConcMarkSweepGC（CMS）</td>
<td align="left">对于⽼年代，启⽤CMS垃圾收集器。 当并⾏收集器⽆法满⾜应⽤的延迟需求是，推荐使⽤CMS或G1收集器。启⽤该选项后， -XX:+UseParNewGC⾃动启⽤。</td>
</tr>
<tr>
<td align="left">-XX:+UseSerialGC</td>
<td align="left">启⽤G1收集器。 G1是服务器类型的收集器， ⽤于多核、⼤内存的机器。它在保持⾼吞吐量的情况下，⾼概率满⾜GC暂停时间的⽬标。</td>
</tr>
</tbody></table>
<p>  将上述参数 放入 /bin/catalina.sh 大长篇注释下方就可以了。</p>
  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">"-XX:+UseG1GC"</span></code></pre></div>

<p>  接下来使用 jdk 自带的 jconsole 监控可查看启用的垃圾回收器，如下图：<br><img src="https://img-blog.csdnimg.cn/202006212029416.png" srcset="/img/loading.gif" alt="G1"></p>
</li>
</ul>
<h4 id="2-2-Tomcat-配置调优"><a href="#2-2-Tomcat-配置调优" class="headerlink" title="2.2 Tomcat 配置调优"></a>2.2 Tomcat 配置调优</h4><p>Tomcat⾃身相关的调优</p>
<ul>
<li><p>使用并调整tomcat线程池 conf/server.xml<br><img src="https://img-blog.csdnimg.cn/20200621203144530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="server.xml配置调优"></p>
</li>
<li><p>调整tomcat的连接器，同样在 conf/server.xml </p>
<table>
<thead>
<tr>
<th align="center">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">maxConnections</td>
<td align="left"><strong>最⼤连接数</strong>，当到达该值后，服务器接收但不会处理更多的请求， 额外的请求将会阻塞直到连接数低于maxConnections 。可通过ulimit -a 查看服务器限制。对于CPU要求更⾼(计算密集型)时，建议不要配置过⼤ ; 对于CPU要求不是特别⾼时，建议配置在2000左右(受服务器性能影响)。 当然这个需要服务器硬件的⽀持</td>
</tr>
<tr>
<td align="center">maxThreads</td>
<td align="left">最⼤线程数,需要根据服务器的硬件情况，进⾏⼀个合理的设置</td>
</tr>
<tr>
<td align="center">acceptCount</td>
<td align="left">最⼤排队等待数,当服务器接收的请求数量到达maxConnections ，此时Tomcat会将后⾯的请求，存放在任务队列中进⾏排序， acceptCount指的就是任务队列中排队等待的请求数 。 <strong>⼀台Tomcat的最⼤的请求处理数量，是maxConnections+acceptCount</strong></td>
</tr>
</tbody></table>
<p><strong>⚠️ 基础小知识：Uimit -n 查看文件描述符，每个进程开启一个soeket连接，都会占用一个文件描述符。所以 可打开的最大文件数就是最大连接数。在Linux系统中一切皆可以看成是文件。因为建立链接也是要读写</strong></p>
</li>
<li><p>禁⽤ AJP 连接器</p>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; --&gt;</span></code></pre></div>

<p><strong>⚠️AJPV13协议是面向包的。WEB服务器和 servlet容器通过TCP链接来交互；为节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP链接到servlet容器，并且在多个请求和响应周期过程会重用链接，所以用不到AJP。</strong></p>
</li>
</ul>
<p>我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议</p>
<ul>
<li><p>调整 IO 模式<br>修改如下内容：</p>
  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span>
                    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
                    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span></code></pre></div>

<p>  修改protocol的值为org.apache.coyote.http11.Http11NioProtocol</p>
  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>
                    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>
                    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span></code></pre></div>

<p>  Tomcat8之前的版本默认使⽤BIO（阻塞式IO），对于每⼀个请求都要创建⼀个线程来处理，不适合⾼并发；Tomcat8以后的版本默认使⽤NIO模式（⾮阻塞式IO）<br>  当Tomcat并发性能有较⾼要求或者出现瓶颈时，我们可以尝试使⽤APR模式，APR（Apache Portable Runtime）是从操作系统级别解决异步IO问题，使⽤时需要在操作系统上安装APR和Native（因为APR原理是使⽤使⽤JNI技术调⽤操作系统底层的IO接⼝）</p>
</li>
<li><p>动静分离（前后端分离用不上）<br>可以使⽤Nginx+Tomcat相结合的部署⽅案，Nginx负责静态资源访问，Tomcat负责Jsp等动态资源访问处理（因为Tomcat不擅⻓处理静态资源）目前都是前后端分离，Nginx 一般用作反向代理，打到不同的Tomcat。</p>
</li>
</ul>
<blockquote>
<p><em>《拉勾教育》Tomcat 笔记整理</em></p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Tomcat/">Tomcat</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/06/23/Nginx-使用-剖析/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Nginx 使用& 剖析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/06/12/spring-mvc-思维导图-（知识点-手写mvc核心思想）/">
                        <span class="hidden-mobile">spring-mvc 思维导图 （知识点&手写mvc核心思想）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Tomcat 深度剖析及性能调优&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
