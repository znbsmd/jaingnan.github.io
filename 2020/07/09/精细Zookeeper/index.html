

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;light&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="来啦，老弟，这里是 AKA 190">
  <meta name="author" content="190coder">
  <meta name="keywords" content="Java Php hexo Thinking in Java">
  <title>精细Zookeeper  - 190呐</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>190coder</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-09 13:31" pubdate>
      2020年7月9日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      70
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">精细Zookeeper </h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>ZooKeeper主要的使用场景就是分布式协同服务，保证分布式信息的一致性。</p>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用可以基于它实现数据订阅/发布、负载均衡、命名服务、集群服务、分布式锁和分布式队列等功能。</p>
<ul>
<li>集群角色：在zk中，没有沿用Master/Slave(主备)概念，而是引入了Leader、Follwer、Observer三种角色。通过Leader选举来选定一台Leader机器,Leader机器为客户端提供读写服务，其他角色提供读服务，<strong>唯一区别就是Observer不参与Leader选举过程、写操作过半成功策略</strong>，因此Oberver可以在不影响写性能情况下提高集群性能。</li>
<li>会话（session）：指一个客户端连接，代表客户端和服务器一个TCP长连接。通过连接，客户端通过心跳检测与服务器保持有效的会话，还能够接受服务器Watch事件。</li>
<li>数据节点（Znode）：机器节点，每个Znode保存自己的数据内容、属性信息。</li>
<li>版本：每个ZNode 都会维护一个Stat数据结构，Stat记录三个数据版本，分别是version（当前版本）、cversion（子节点版本）、aversion（ACL版本）。</li>
<li>Watch（事件监听）：节点注册Watch，会收到服务器事件通知，是Zookeeper重要特性。</li>
<li>ACL：权限控制策略，有5种：create（创建子节点权限）、read（获取节点数据和子节点权限）、write（更新节点数据权限）、delete（删除子节点权限）、admin（设置ACL权限），<strong>⚠️create、delete 都是针对子节点</strong></li>
</ul>
<h2 id="二、-环境搭建"><a href="#二、-环境搭建" class="headerlink" title="二、 环境搭建"></a>二、 环境搭建</h2><p>三种搭建方式：</p>
<ul>
<li>单机：适合测试</li>
<li>集群：适合生产</li>
<li>伪集群：一台服务器运行多个zk，适合生产前测试</li>
</ul>
<h3 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1. 单机部署"></a>1. 单机部署</h3><ol>
<li><p>下载地址：<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></p>
</li>
<li><p>解压</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zxvf</span> <span class="hljs-selector-tag">zookeeper-3</span><span class="hljs-selector-class">.4</span><span class="hljs-selector-class">.14</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span></code></pre></div>
</li>
<li><p>创建data文件夹</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">cd</span> <span class="hljs-selector-tag">zookeeper-3</span><span class="hljs-selector-class">.4</span><span class="hljs-selector-class">.14</span>
<span class="hljs-selector-tag">mkdir</span> <span class="hljs-selector-tag">data</span></code></pre></div>
</li>
<li><p>修改配置</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">cd</span> <span class="hljs-selector-tag">conf</span>
<span class="hljs-selector-tag">mv</span> <span class="hljs-selector-tag">zoo_sample</span><span class="hljs-selector-class">.cfg</span> <span class="hljs-selector-tag">zoo</span><span class="hljs-selector-class">.cfg</span></code></pre></div>
</li>
<li><p>修改zoo.cfg 中data属性</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-title">dataDir</span>=/root/zookeeper<span class="hljs-number">-3.4</span><span class="hljs-number">.14</span>/<span class="hljs-class"><span class="hljs-keyword">data</span></span></code></pre></div>
</li>
<li><p>服务启动、看状态、停止</p>
<div class="hljs"><pre><code class="hljs undefined">./zkServer<span class="hljs-selector-class">.sh</span> start
./zkServer<span class="hljs-selector-class">.sh</span> status
./zkServer<span class="hljs-selector-class">.sh</span> stop</code></pre></div>

</li>
</ol>
<h3 id="2-伪集群部署"><a href="#2-伪集群部署" class="headerlink" title="2. 伪集群部署"></a>2. 伪集群部署</h3><p>保证端口号不冲突、dataDir也不同、在dataDir所在目录创建myid文件指定对应ZK实例</p>
<ul>
<li>clientPort：不同实例配置不同端口</li>
<li>dataDir、dataLogDir：将数据文件和日志文凯存放</li>
<li>server.X、myid 两个相互对应 1，2，3</li>
</ul>
<p>前几步与单机一样，主要是复制多个zk和配置变动：</p>
<ul>
<li><p>server 1:</p>
  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span> 
<span class="hljs-attr">dataDir</span>=/zkcluster/zookeeper01/data 
<span class="hljs-attr">dataLogDir</span>=/zkcluster/zookeeper01/data/logs</code></pre></div>
</li>
<li><p>server 2:</p>
  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">clientPort</span>=<span class="hljs-number">21812</span>
<span class="hljs-attr">dataDir</span>=/zkcluster/zookeeper02/data 
<span class="hljs-attr">dataLogDir</span>=/zkcluster/zookeeper02/data/logs</code></pre></div>
</li>
<li><p>更多服务配置…</p>
</li>
<li><p>配置集群：在每个zk的data下创建myid，分别是1，2，3，记录服务ID</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">touch myid</span></code></pre></div>

<ul>
<li>在每个zk的zoo.cfg 配置端口访问和集群服务IP列表</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined">server<span class="hljs-meta">.1</span>=<span class="hljs-number">10.211</span><span class="hljs-meta">.55</span><span class="hljs-meta">.4</span>:<span class="hljs-number">2881</span>:<span class="hljs-number">3881</span>
server<span class="hljs-meta">.2</span>=<span class="hljs-number">10.211</span><span class="hljs-meta">.55</span><span class="hljs-meta">.4</span>:<span class="hljs-number">2882</span>:<span class="hljs-number">3882</span>
server<span class="hljs-meta">.3</span>=<span class="hljs-number">10.211</span><span class="hljs-meta">.55</span><span class="hljs-meta">.4</span>:<span class="hljs-number">2883</span>:<span class="hljs-number">3883</span>
#server.服务器ID=服务器<span class="hljs-built_in">IP</span>地址:服务器之间通信端口:服务器之间投票选举端口</code></pre></div>

<ul>
<li>启动实例，完成集群</li>
</ul>
<h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h2><h3 id="1-系统模型"><a href="#1-系统模型" class="headerlink" title="1. 系统模型"></a>1. 系统模型</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a27cd31b8034?w=1124&h=656&f=png&s=188105" srcset="/img/loading.gif" alt><br>根据斜杠分割表示路径。</p>
<h4 id="1-1-ZNode节点可分为三大类："><a href="#1-1-ZNode节点可分为三大类：" class="headerlink" title="1.1 ZNode节点可分为三大类："></a>1.1 ZNode节点可分为三大类：</h4><ul>
<li>持久性节点：一直存在，直到删除主动清除</li>
<li>持久顺序性节点：+ 顺序</li>
<li>临时性节点：生命周期和客户端会话绑定一起，会话结束便删除</li>
<li>顺序性节点：+ 顺序</li>
</ul>
<p>不同类型有不同类型的生命周期</p>
<h4 id="1-2-事务ID"><a href="#1-2-事务ID" class="headerlink" title="1.2 事务ID"></a>1.2 事务ID</h4><p>用ZXID表示，通常是一个64位数字，每一次ZXID对应一次新操作，间接直到zk处理更新操作的全局顺序</p>
<h4 id="1-3-ZNode-状态信息"><a href="#1-3-ZNode-状态信息" class="headerlink" title="1.3 ZNode 状态信息"></a>1.3 ZNode 状态信息</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a36e04586466?w=1326&h=676&f=png&s=482701" srcset="/img/loading.gif" alt></p>
<div class="hljs"><pre><code class="hljs undefined"> 
cZxid 就是 <span class="hljs-keyword">Create</span> ZXID，表示节点被创建时的事务<span class="hljs-keyword">ID</span>。
ctime 就是 <span class="hljs-keyword">Create</span> <span class="hljs-built_in">Time</span>，表示节点创建时间。
mZxid 就是 Modified ZXID，表示节点最后一次被修改时的事务<span class="hljs-keyword">ID</span>。
mtime 就是 Modified <span class="hljs-built_in">Time</span>，表示节点最后一次被修改的时间。
pZxid 表示该节点的子节点列表最后一次被修改时的事务 <span class="hljs-keyword">ID</span>。只有子节点列表变更才会更新 pZxid，
子节点内容变更不会更新。
cversion 表示子节点的版本号。
dataVersion 表示内容版本号。
aclVersion 标识acl版本
ephemeralOwner 表示创建该临时节点时的会话 sessionID，如果是持久性节点那么值为 <span class="hljs-number">0</span> <span class="hljs-keyword">dataLength</span> 表示数据⻓度。
numChildren 表示直系子节点数。</code></pre></div>

<h4 id="1-4-Watcher-gt-数据变更通知"><a href="#1-4-Watcher-gt-数据变更通知" class="headerlink" title="1.4 Watcher-&gt; 数据变更通知"></a>1.4 Watcher-&gt; 数据变更通知</h4><p>zk使用Watcher实现发布/订阅，流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a38b6156c9ee?w=866&h=492&f=png&s=100924" srcset="/img/loading.gif" alt></p>
<h4 id="1-5-ACL-gt-保证数据安全"><a href="#1-5-ACL-gt-保证数据安全" class="headerlink" title="1.5 ACL -&gt;保证数据安全"></a>1.5 ACL -&gt;保证数据安全</h4><p>从三方面理解ACL机制，权限模式 Scheme 、授权对象ID、权限Permission,通常使用<strong>scheme: id : permission 标识有效的ACL信息</strong> :</p>
<ul>
<li><p>权限模式 Scheme </p>
<ul>
<li>IP:通过IP地址粒度进行权限控制</li>
<li>Digest：最常用的，username:password 进行控制</li>
<li>World：对所有用户开放，world: anyone</li>
<li>Super：特殊的Digest，对任何节点操作</li>
</ul>
</li>
<li><p>授权对象：ID …</p>
</li>
</ul>
<h3 id="2-命令行操作"><a href="#2-命令行操作" class="headerlink" title="2. 命令行操作"></a>2. 命令行操作</h3><ul>
<li>进入客户端：<div class="hljs"><pre><code class="hljs undefined">./zkCli<span class="hljs-selector-class">.sh</span> 连接本地的zookeeper服务器
./zkCli<span class="hljs-selector-class">.sh</span> -server ip:port 连接指定的服务器</code></pre></div>

</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a4bcf9da16e3?w=1218&h=1142&f=png&s=714898" srcset="/img/loading.gif" alt></p>
<ul>
<li>创建节点：</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined">create [<span class="hljs-string">-s</span>][<span class="hljs-symbol">-e</span>] path data acl
//其中，-s或-e分别指定节点特性，顺序或临时节点，若不指定，则创建持久节点;acl用来进行权限控制。</code></pre></div>

<ul>
<li><p>创建永久节点</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">create</span> /zk-<span class="hljs-literal">permanent</span> <span class="hljs-number">123</span></code></pre></div>
</li>
<li><p>读取节点</p>
</li>
</ul>
<p>path表示的是指定数据节点的节点路径，例：get /zk-permanent</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">ls</span> path <span class="hljs-string">//</span> <span class="hljs-keyword">ls</span> 列出所有子节点、只能查看下一级子节点
get path <span class="hljs-string">//</span> 可获取指定节点数据内容和属性信息
<span class="hljs-keyword">ls</span>/  <span class="hljs-string">//</span> 获取根节点所有子节点</code></pre></div>

<ul>
<li>更新节点/删除节点 例：set /zk-test0000000000 4567 ，返回更新后信息，其中dataVersion 自增</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">set</span> <span class="hljs-keyword">path</span> <span class="hljs-keyword">data</span> [<span class="hljs-keyword">version</span>]
<span class="hljs-keyword">delete</span> <span class="hljs-keyword">path</span> [<span class="hljs-keyword">version</span>]</code></pre></div>

<h3 id="3-api-使用"><a href="#3-api-使用" class="headerlink" title="3. api 使用"></a>3. api 使用</h3><p>引入</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>剩下的crud，直接交给搜索引擎…</p>
<h3 id="4-zk-开源客户端"><a href="#4-zk-开源客户端" class="headerlink" title="4. zk 开源客户端"></a>4. zk 开源客户端</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.101tec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>api使用更加方便简洁，剩下的，直接交给搜索引擎…</p>
<h3 id="5-Curator-客户端"><a href="#5-Curator-客户端" class="headerlink" title="5. Curator 客户端"></a>5. Curator 客户端</h3><p>提供了Fluent 编程风格支持，封装zk底层的细节开发工作，包括重连、反复注册Watcher。</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> 
    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div>

<p>剩下的，直接交给搜索引擎…</p>
<h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><h3 id="1-数据发布-订阅"><a href="#1-数据发布-订阅" class="headerlink" title="1. 数据发布/订阅"></a>1. 数据发布/订阅</h3><p>发布/订阅有2种设计模式，推Push &amp; 拉Pull。在推模中，服务端将所有数据更新发给订阅的客户端，而拉是由客户端主动发起请求获取最新数据。通常采用轮寻。</p>
<p>zk采用推拉结合，客户端向服务端注册自己需要关注的节点，一旦该节点数据发生变更，服务器像客户端发送Watcher事件通知，收到消息主动向服务端获取最新数据。<strong>这种模式主要用于配置信息获取同步。</strong></p>
<h3 id="2-命名服务"><a href="#2-命名服务" class="headerlink" title="2. 命名服务"></a>2. 命名服务</h3><p>通常客户端能够根据指定名字获取资源实体、服务地址和提供者信息。来实现提供全局唯一ID的分配机制。其中比较常见的RPC就是使用这种机制。</p>
<p><strong>由于zk可以创建顺序节点，保证了同一节点下子节点是唯一的</strong>，所以直接按照存放文件的方法，设置节点，比如一个路径下不可能存在两个相同的文件名，这种定义创建节点，就是全局唯一ID，如下</p>
<div class="hljs"><pre><code class="hljs java">ZkClient zkClient = <span class="hljs-keyword">new</span> ZkClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>);
zkClient.createPersistentSequential(<span class="hljs-string">"/home/zjn/wyid"</span>,<span class="hljs-keyword">null</span>);</code></pre></div>

<p>获取节点直接拼接所定义的路径，方可得到全局唯一ID</p>
<h3 id="3-集群管理"><a href="#3-集群管理" class="headerlink" title="3. 集群管理"></a>3. 集群管理</h3><p>根据zk的<strong>watcher机制和会话结束临时节点自动删除</strong>两大特性可实现实时监控机器活动，实现集群管理。</p>
<h3 id="4-Master-选举"><a href="#4-Master-选举" class="headerlink" title="4. Master 选举"></a>4. Master 选举</h3><p>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能。</p>
<p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。（其实只要实现数据唯一性就可以做到选举，关系型数据库也可以，但是性能不好，设计也复杂）</p>
<h3 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5. 分布式锁"></a>5. 分布式锁</h3><h4 id="5-1-实现排他锁"><a href="#5-1-实现排他锁" class="headerlink" title="5.1 实现排他锁"></a>5.1 实现排他锁</h4><p>在java中，可以利用zk提供的api实现分布式锁，具体流程为：</p>
<ul>
<li>定义锁：在zk中，通过数据节点表示一个锁，例如 “/exclusive_lock/lock” 可以被定义成一个锁，在使用中可定义个临时节点。</li>
<li>获取锁：创建节点成功就是抢锁成功，同时所有没获取到锁的客户需要到”/exclusive_lock” 注册一个子节点变更的Watcher监听，以便实时监听lock节点变更。</li>
<li>释放锁：由于定义临时节点，那在以下两种情况有可能释放锁： <ol>
<li>客户端宕机 </li>
<li>执行完业务逻辑后，主动删除</li>
</ol>
</li>
</ul>
<p>释放后，重新获取锁，整个流程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731ceccd77199ad?w=666&h=654&f=png&s=136671" srcset="/img/loading.gif" alt></p>
<h4 id="5-2-实现共享锁（读锁）"><a href="#5-2-实现共享锁（读锁）" class="headerlink" title="5.2 实现共享锁（读锁）"></a>5.2 实现共享锁（读锁）</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731cfe54d39a3f1?w=686&h=460&f=png&s=53614" srcset="/img/loading.gif" alt><br>其实就是与写锁区分开，单独创建一个读的节点 例如 ：”/shared_lock/host1-R-0000000001”。</p>
<p><strong>这里说明下，在同一节点下创建任何带顺序子节点，都会使序号递增。</strong></p>
<p>下面摘抄下网络上的共享锁demo，方便配合解释理解：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.bigdata.zklock;

<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.List;
<span class="hljs-keyword">import</span> java.util.Random;

<span class="hljs-keyword">import</span> org.apache.zookeeper.CreateMode;
<span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;
<span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;
<span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher.Event.EventType;
<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;
<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperShareLock</span> </span>&#123;
    <span class="hljs-comment">// 会话超时</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SESSION_TIMEOUT = <span class="hljs-number">2000</span>;
    <span class="hljs-comment">// zookeeper集群地址</span>
    <span class="hljs-keyword">private</span> String hosts = <span class="hljs-string">"mini1:2181,mini2:2181,mini3:2181"</span>;
    <span class="hljs-keyword">private</span> String groupNode = <span class="hljs-string">"locks"</span>;
    <span class="hljs-keyword">private</span> String subNode = <span class="hljs-string">"sub"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> haveLock = <span class="hljs-keyword">false</span>;

    <span class="hljs-keyword">private</span> ZooKeeper zk;
    <span class="hljs-comment">// 记录自己创建的子节点路径</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String thisPath;

    <span class="hljs-comment">/**
     * 连接zookeeper
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectZookeeper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        zk = <span class="hljs-keyword">new</span> ZooKeeper(hosts, SESSION_TIMEOUT, <span class="hljs-keyword">new</span> Watcher() &#123;
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;
                <span class="hljs-keyword">try</span> &#123;

                    <span class="hljs-comment">// 判断事件类型，此处只处理子节点变化事件</span>
                    <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeChildrenChanged &amp;&amp; event.getPath().equals(<span class="hljs-string">"/"</span> + groupNode)) &#123;
                        <span class="hljs-comment">//获取子节点，并对父节点进行监听</span>
                        List&lt;String&gt; childrenNodes = zk.getChildren(<span class="hljs-string">"/"</span> + groupNode, <span class="hljs-keyword">true</span>);
                        String thisNode = thisPath.substring((<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span>).length());
                        <span class="hljs-comment">// 去比较是否自己是最小id</span>
                        Collections.sort(childrenNodes);
                        <span class="hljs-keyword">if</span> (childrenNodes.indexOf(thisNode) == <span class="hljs-number">0</span>) &#123;
                            <span class="hljs-comment">//访问共享资源处理业务，并且在处理完成之后删除锁</span>
                            doSomething();
                            <span class="hljs-comment">//重新注册一把新的锁</span>
                            thisPath = zk.create(<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span> + subNode, <span class="hljs-keyword">null</span>, Ids.OPEN_ACL_UNSAFE,
                                    CreateMode.EPHEMERAL_SEQUENTIAL);
                        &#125;
                    &#125;
                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;);

        <span class="hljs-comment">// 1、程序一进来就先注册一把锁到zk上</span>
        thisPath = zk.create(<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span> + subNode, <span class="hljs-keyword">null</span>, Ids.OPEN_ACL_UNSAFE,
                CreateMode.EPHEMERAL_SEQUENTIAL);

        <span class="hljs-comment">// wait一小会，便于观察</span>
        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));

        <span class="hljs-comment">// 从zk的锁父目录下，获取所有子节点，并且注册对父节点的监听</span>
        List&lt;String&gt; childrenNodes = zk.getChildren(<span class="hljs-string">"/"</span> + groupNode, <span class="hljs-keyword">true</span>);

        <span class="hljs-comment">//如果争抢资源的程序就只有自己，则可以直接去访问共享资源</span>
        <span class="hljs-keyword">if</span> (childrenNodes.size() == <span class="hljs-number">1</span>) &#123;
            doSomething();
            thisPath = zk.create(<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span> + subNode, <span class="hljs-keyword">null</span>, Ids.OPEN_ACL_UNSAFE,
                    CreateMode.EPHEMERAL_SEQUENTIAL);
        &#125;
    &#125;

    <span class="hljs-comment">/**
     * 处理业务逻辑，并且在最后释放锁
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">try</span> &#123;
            System.out.println(<span class="hljs-string">"gain lock: "</span> + thisPath);
            Thread.sleep(<span class="hljs-number">2000</span>);
            <span class="hljs-comment">// do something</span>
        &#125; <span class="hljs-keyword">finally</span> &#123;
            System.out.println(<span class="hljs-string">"finished: "</span> + thisPath);
            <span class="hljs-comment">// 将thisPath删除, 监听thisPath的client将获得通知</span>
            <span class="hljs-comment">// 相当于释放锁</span>
            zk.delete(<span class="hljs-keyword">this</span>.thisPath, -<span class="hljs-number">1</span>);
        &#125;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        ZookeeperShareLock dl = <span class="hljs-keyword">new</span> ZookeeperShareLock();
        dl.connectZookeeper();
        Thread.sleep(Long.MAX_VALUE);
    &#125;

&#125;</code></pre></div>

<p>以上就是实现最简单的共享锁的逻辑。<br>如果升级为读写锁都有，其实实现读写锁核心就是判断读写顺序就可以 ，如下：</p>
<ol>
<li>创建完节点后，获取/shared_lock节点下所有子节点，并对该节点变更注册监听。    </li>
<li>确定自己的节点序号在所有子节点中的顺序。</li>
<li>对于读请求:若没有比自己序号小的子节点或所有比自己序号小的子节点都是读请求，那么表 明自己已经成功获取到共享锁，同时开始执行读取逻辑，若有写请求，则需要等待。对于写请求:若自己不 是序号最小的子节点，那么需要等待。</li>
<li>接收到Watcher通知后，重复步骤1</li>
</ol>
<h4 id="5-3-羊群效应"><a href="#5-3-羊群效应" class="headerlink" title="5.3 羊群效应"></a>5.3 羊群效应</h4><p>以上实现可以满足一般分布式集群竞争锁的需求（一般集群为10台机器以内），并且性能都还可以。但是机器规模扩大后，会出现问题，如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d2622e1222b9?w=666&h=694&f=png&s=81526" srcset="/img/loading.gif" alt></p>
<p>以上会出现的问题，就是如果 host1完成读操作，并将节点删除，会通知所有节点，但是你如果理解上面讲的判断读写顺序，其实可以分析出，host1移除只影响host2，对其他机器并没有产生影响。<strong>如果同一时间有多个节点完成事务给大量节点进行通知，会对网络开销和性能造成巨大影响，这就是所谓的羊群效应。</strong></p>
<p>问题根源就是没有找准客户端真正关注的点，其实分布式锁的竞争核心是<strong>只需要关注比自己序号小的那个节点的变更情况</strong>就可以，不需要关注所有节点。</p>
<p>改进：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d3aa818f6c95?w=1058&h=974&f=png&s=445385" srcset="/img/loading.gif" alt></p>
<p><strong>核心：只对比自己小的节点注册Watcher机制</strong></p>
<p>至于demo就不放上来了，这么实现还是比较复杂的，合理运用搜索引擎…<br>最后建议在实际生产环境中，尽量去缩小锁的范围。能简化开发则简化。毕竟一般公司达不到大规模集群…</p>
<h3 id="6-分布式队列"><a href="#6-分布式队列" class="headerlink" title="6. 分布式队列"></a>6. 分布式队列</h3><h4 id="6-1-FIFO-先入先出"><a href="#6-1-FIFO-先入先出" class="headerlink" title="6.1 FIFO 先入先出"></a>6.1 FIFO 先入先出</h4><p>和创建共享锁差不多，判断自己序号是不是最小，是就等，不是就dosomeing…</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d46a923785e7?w=726&h=602&f=png&s=198338" srcset="/img/loading.gif" alt></p>
<h4 id="6-2-Barrier-分布式屏障"><a href="#6-2-Barrier-分布式屏障" class="headerlink" title="6.2 Barrier: 分布式屏障"></a>6.2 Barrier: 分布式屏障</h4><p><strong>可以理解成分布式闭锁</strong>，特指分布式一个协调条件，规定了一个队列元素必须聚焦后才能统一进行安排，否则一直等待。一般应用在大规模分布式计算应用场景。</p>
<p>设计思想如下：</p>
<p>设置一个/queue_barrier 节点，其数据内容赋值为一个数字n来代表Barrier 值，步骤如下：</p>
<ol>
<li><p>创建并设置值</p>
 <div class="hljs"><pre><code class="hljs undefined">create <span class="hljs-string">/queue_barrier</span> 10
get <span class="hljs-string">/queue_barrier</span> <span class="hljs-string">//</span> 得到10</code></pre></div>
</li>
<li><p>通过 getChildren 获取所有子节点，同时对注册子节点变更的Watcher监听。</p>
</li>
<li><p>统计，数不足10个，需要等待。</p>
</li>
<li><p>接受Watch通知，重复步骤2</p>
</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d4ed5678a5c9?w=880&h=690&f=png&s=188691" srcset="/img/loading.gif" alt></p>
<h2 id="五、深入进阶"><a href="#五、深入进阶" class="headerlink" title="五、深入进阶"></a>五、深入进阶</h2><h3 id="1-ZAB协议"><a href="#1-ZAB协议" class="headerlink" title="1. ZAB协议"></a>1. ZAB协议</h3><p>Zab协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。它是特别为Zookeeper设计的支持<strong>崩溃恢复的原子广播协议</strong>。</p>
<p>ZAB核心是定义对于改变zk服务数据状态的事务请求的处理方式：</p>
<p>即:所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，余下的 服务器则称为Follower服务器，Leader服务器负责将一个客户端事务请求转化成一个事务Proposal(提 议)，并将该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有 Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向 所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交，类似2pc</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d6378f954ff4?w=1224&h=494&f=png&s=83797" srcset="/img/loading.gif" alt></p>
<p><strong>协议内容</strong></p>
<p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 进入崩溃恢复模式，选举产生新的Leader。当新的Leader出来了，同时，已有过半机器完成同步之后，ZAB协议将退出恢复模式。<strong>进入消息广播模式</strong>。这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。如果集群中其他机器收到客户端事务请求后，那么会先转发Leader服务器，由Leader统一处理。</p>
<ul>
<li><p>崩溃恢复：<br>  一但出现崩溃，会导致数据不一致，ZAB的崩溃恢复开始起作用。有如下两个确保：</p>
<ol>
<li><p>ZAB协议需要确保已经在Leader提交的事务最终被所有服务器提交。</p>
</li>
<li><p>ZAB协议需要确保丢弃只在Leader服务器上被提出的事务。</p>
<p>最终决定了Leader选举算法：针对上两个要求，如果Leader选举算法<strong>保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID最大）的事务Proposal，那么就能保证新的Leader 一定具有已提交的所有提案</strong>，更重要是，如果这么做，可以省去Leader服务器检查Proposal的提交和丢弃工作的这一步。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>消息广播模式 ：</p>
<ol>
<li><p>在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。zookeeper中农数据副本的同步方式与二段提交相似，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。</p>
</li>
<li><p>Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈”</p>
</li>
<li><p>整个过程中，Leader为每个事务请求生产对应的Proposal，在广播前，为这个事务分配一个全局唯一ID，为ZXID（事务ID），必须按照递增的事务顺序进行处理。</p>
</li>
<li><p>具体流程如上图。</p>
</li>
</ol>
</li>
</ul>
<p><strong>运行时状态分析</strong></p>
<ul>
<li>LOOKING：Leader选举阶段</li>
<li>FOLLOWING：Follower 和Leader保持同步状态</li>
<li>LEADING：Leader服务器作为主进程领导状态</li>
</ul>
<p>所有进程初始状态都是LOOKING，之后选举Leader，有了Leader，会变成FOLLOWING，Leader变成 LEADING，当Leader崩溃后，所有进程变成LOOKING，重新选举。当 Leader与所有机器断开TCP连接，其他FOLLOWING会放弃这个Leader，同时转到 LOOKING，之后重新选举。</p>
<p><strong>ZAB与Paxos联系&amp;区别</strong></p>
<p>两者设计目标不一样，ZAB主要用于构建高可用分布式系统，Paxos 算法用于构建一致性状态机器。所有会有细微差别。但是ZAB就是在Paxos保证一致性基础上设计出高可用的协议。</p>
<h3 id="2-服务器角色"><a href="#2-服务器角色" class="headerlink" title="2. 服务器角色"></a>2. 服务器角色</h3><h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><p>zk的核心，主要工作如下：</p>
<div class="hljs"><pre><code>1. 事务请求的唯一调度和处理者，保证集群的顺序性。
2. 集群各服务调度者。</code></pre></div><p><strong>请求处理链：</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e548fcfee4e0?w=1446&h=292&f=png&s=110564" srcset="/img/loading.gif" alt></p>
<ul>
<li>PrepRequestProcessor：请求预处理器。如创建请求事务头、事务体、会话检查、ACL检查和版本检查</li>
<li>ProposalRequestProcessor ：事务日志记录处理器。事务处理发起者，非事务请求直接转发CommitProcessor，对于事务请求还需要创建Proposal提议，并发送给所有Follower，进行一次集群内事务投票。同时ProposalRequestProcessor还会将事务请求交给SyncRequestProcessor进行事务日志记录。</li>
<li>SyncRequestProcessor： 事务日志记录处理器，记录日志，并触发zk进行快照。</li>
<li>AckRequestProcessor：记录日志后向Proposal的投票收集器发送ACK反馈。告知当前服务器已完成日志记录。</li>
<li>CommitProcessor ： 事务提交处理器。非事务请求，直接交付下一阶段。</li>
<li>ToBeCommitProcessor ： 此处理器有toBeApplied队列，用来存储已经被CommitProcessor处理过的可被提交的Proposal，将这些完成的交给FinalRequestProcessor，处理完成后从队列移除。</li>
<li>FinalRequestProcessor ：用来进行对客户端请求的返回之前的操作，针对事务操作，直接应用到内存数据库。</li>
</ul>
<h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><p>跟随者，主要工作如下：</p>
<div class="hljs"><pre><code>1. 处理非事务请求（读请求），转发事务请求给Leader
2. 参与事务请求Proposal投票
3. 参与Leader选举</code></pre></div><p>Follower也采用了责任链模式处理客户端请求。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e62dce0de73e?w=1268&h=430&f=png&s=99390" srcset="/img/loading.gif" alt></p>
<ul>
<li>FollowerRequestProcessor ： 事务请求转发器</li>
<li>SendAckRequestProcessor ： 事务日志记录反馈，完成日志记录后，向Leader发送ACK消息表面完成工作。</li>
</ul>
<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>zk3.3开始引入的角色，观察最新状态，并变更。与Follower不同只是不参与投票、选举，只提供非事务服务。<br>处理链如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e66e90da3b4c?w=1192&h=148&f=png&s=40865" srcset="/img/loading.gif" alt></p>
<p>SyncRequestProcessor 只是在初始化 记录日志、快照。运行中Leader不会将请求投票发给Observer</p>
<h3 id="3-服务启动"><a href="#3-服务启动" class="headerlink" title="3. 服务启动"></a>3. 服务启动</h3><h4 id="五个步骤："><a href="#五个步骤：" class="headerlink" title="五个步骤："></a>五个步骤：</h4><ol>
<li>配置文件解析</li>
<li>初始化数据管理器</li>
<li>初始化网络I/O管理器</li>
<li>数据恢复</li>
<li>对外服务</li>
</ol>
<ul>
<li><strong>单机服务器启动流程</strong>：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e6ac3b89545a?w=1358&h=1000&f=png&s=253217" srcset="/img/loading.gif" alt></p>
<hr>
<ul>
<li><strong>集群服务器启动流程</strong>：</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e6c0e7bf0ba9?w=1406&h=1074&f=png&s=307315" srcset="/img/loading.gif" alt></p>
<h4 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h4><ol>
<li>初始化Leader选举。集群模式特有，Zookeeper首先会根据自身的服务器ID(SID)、最新的 ZXID(lastLoggedZxid)和当前的服务器epoch(currentEpoch)来生成一个初始化投票，在 初始化过程中，每个服务器都会给自己投票。然后，根据zoo.cfg的配置，创建相应Leader选举算法 实现，Zookeeper提供了三种默认算法(LeaderElection、AuthFastLeaderElection、 FastLeaderElection)，可通过zoo.cfg中的electionAlg属性来指定，但现只支持 FastLeaderElection选举算法。在初始化阶段，Zookeeper会创建Leader选举所需的网络I/O层 QuorumCnxManager，同时启动对Leader选举端口的监听，等待集群中其他服务器创建连接。</li>
<li>注册JMX服务。</li>
<li>检测当前服务器状态<br>运行期间，QuorumPeer会不断检测当前服务器状态。在正常情况下，Zookeeper服务器的状态 在LOOKING、LEADING、FOLLOWING/OBSERVING之间进行切换。在启动阶段，QuorumPeer的初始 状态是LOOKING，因此开始进行Leader选举。</li>
<li>Leader选举<br>ZooKeeper的Leader选举过程，简单地讲，就是一个集群中所有的机器相互之间进行一系列投 票，选举产生最合适的机器成为Leader，同时其余机器成为Follower或是Observer的集群机器⻆ 色初始化过程。关于Leader选举算法，简而言之，就是集群中哪个机器处理的数据越新(通常我们根 据每个服务器处理过的最大ZXID来比较确定其数据是否更新)，其越有可能成为Leader。当然，如 果集群中的所有机器处理的ZXID一致的话，那么SID最大的服务器成为Leader，其余机器称为 Follower和Observer</li>
</ol>
<h4 id="Leader-Follower-启动期交互过程"><a href="#Leader-Follower-启动期交互过程" class="headerlink" title="Leader Follower 启动期交互过程"></a>Leader Follower 启动期交互过程</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e747a193db8f?w=876&h=720&f=png&s=417301" srcset="/img/loading.gif" alt></p>
<h3 id="4-Leader选举"><a href="#4-Leader选举" class="headerlink" title="4. Leader选举"></a>4. Leader选举</h3><p>当zk集群一台服务器出现以下2种情况之一时候，需要进入Leader选举。</p>
<div class="hljs"><pre><code>1. 服务器初始化启动
2. 服务器运行无法和Leader保持连接。</code></pre></div><p>分析以上两种情况：</p>
<ol>
<li><p>启动时期选举：</p>
<ul>
<li>每个Server发出一个投票</li>
<li>接受来自各个服务器的投票</li>
<li>处理投票（优先检查ZXID，相同就比较myid）</li>
<li>统计投票（ 判断是否已经有过半的机器接收到相同的投票信息，所谓“过半”就是指大于集群机器数量的一半，即大于或等于 (n/2+1)。对于这里由3台机器构成的集群，大于等于2台即为达到“过半”要求。）</li>
<li>改变服务器状态：Leader-&gt;LEADING, Follower-&gt;FOLLOWING</li>
</ul>
</li>
<li><p>服务运行期间的Leader选举：</p>
<ul>
<li>变更状态：Leader挂后，剩下的Follower都变成LOOKING，进入Leader选举</li>
<li>每个Server发出投票，第一轮都投自己，然后将自己投票发给所有机器</li>
<li>接收投票，与启动选举相同</li>
<li>处理投票，与启动选举相同</li>
<li>统计投票，与启动选举相同</li>
<li>改变服务器状态，与启动选举相同</li>
</ul>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Zookeeper/">Zookeeper</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/17/Dubbo从实战-源码分析/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Dubbo从实战->源码分析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/01/分布式理论-自定义RPC/">
                        <span class="hidden-mobile">分布式理论&自定义RPC</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "精细Zookeeper &nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
