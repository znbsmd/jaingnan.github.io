

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;dark&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="来啦，老弟，这里是 AKA 190">
  <meta name="author" content="190coder">
  <meta name="keywords" content="Java Php hexo Thinking in Java">
  <title>Dubbo从实战-&gt;源码分析 - 190呐</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>190coder</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-07-17 10:44" pubdate>
      2020年7月17日 上午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      16.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      206
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Dubbo从实战-&gt;源码分析</h1>
            
            <div class="markdown-body" id="post-body">
              <h2 id="一、-项目架构演变过程"><a href="#一、-项目架构演变过程" class="headerlink" title="一、 项目架构演变过程"></a>一、 项目架构演变过程</h2><p>单体架构-&gt;垂直架构(业务拆分)-&gt;分布式架构（SOA 松耦合)-&gt;微服务架构</p>
<h2 id="二、-Dubbo架构与实战"><a href="#二、-Dubbo架构与实战" class="headerlink" title="二、 Dubbo架构与实战"></a>二、 Dubbo架构与实战</h2><h3 id="1-Dubbo-架构概述"><a href="#1-Dubbo-架构概述" class="headerlink" title="1. Dubbo 架构概述"></a>1. Dubbo 架构概述</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开<br>源Java RPC框架，可以和Spring框架无缝集成。</p>
<h4 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h4><p>面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p>
<h4 id="1-3-服务治理"><a href="#1-3-服务治理" class="headerlink" title="1.3 服务治理"></a>1.3 服务治理</h4><p>包括最佳实践、架构原则、治理规程、规律以及其他决定性的因素。服务治理指的是用来管理SOA的采用和实现的过程。</p>
<h3 id="2-处理流程"><a href="#2-处理流程" class="headerlink" title="2. 处理流程"></a>2. 处理流程</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17340a5c9f971167?w=1318&h=1180&f=png&s=476735" srcset="/img/loading.gif" alt></p>
<h3 id="3-服务注册中心Zookeeper"><a href="#3-服务注册中心Zookeeper" class="headerlink" title="3. 服务注册中心Zookeeper"></a>3. 服务注册中心Zookeeper</h3><p>Dubbo官方推荐使用Zookeeper作为服务注册中心。Zookeeper 是 Apache Hadoop 的子项目，作为 Dubbo 服<br>务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。</p>
<h3 id="4-Dubbo开发实战"><a href="#4-Dubbo开发实战" class="headerlink" title="4. Dubbo开发实战"></a>4. Dubbo开发实战</h3><p>使用方面直接官方文档吧，个人写的再好，也没有原创的好…  官方地址-&gt; <a href="http://dubbo.apache.org/zh-cn/index.html。" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/index.html。</a></p>
<p>总结下来小demo就是配置三个模块：客户端、服务端、公用api接口，剩下的配置好zk，可以完美和Spring结合，使用及其方便。</p>
<h3 id="5-Dubbo管理控制台-dubbo-admin"><a href="#5-Dubbo管理控制台-dubbo-admin" class="headerlink" title="5. Dubbo管理控制台 dubbo-admin"></a>5. Dubbo管理控制台 dubbo-admin</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>主要包含：服务管理 、 路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能，2.6以后可以是jar包可以直接通过java命令运行。不需要配置tomcat。</p>
<h4 id="2-控制台安装步骤"><a href="#2-控制台安装步骤" class="headerlink" title="2. 控制台安装步骤"></a>2. 控制台安装步骤</h4><p>官方配置走起-&gt; <a href="https://dubbo.apache.org/zh-cn/docs/admin/introduction.html" target="_blank" rel="noopener">https://dubbo.apache.org/zh-cn/docs/admin/introduction.html</a></p>
<h3 id="6-Dubbo配置项说明"><a href="#6-Dubbo配置项说明" class="headerlink" title="6. Dubbo配置项说明"></a>6. Dubbo配置项说明</h3><h4 id="6-1-dubbo-application"><a href="#6-1-dubbo-application" class="headerlink" title="6.1. dubbo:application"></a>6.1. dubbo:application</h4><p>对应 org.apache.dubbo.config.ApplicationConfig, 代表当前应用的信息</p>
<ol>
<li>name: 当前应用程序的名称，在dubbo-admin中我们也可以看到。请求时也会根据name来进行请求。</li>
<li>owner: 当前应用程序的负责人，可以通过这个负责人找到其相关的应用列表，用于快速定位到责<br>任人。</li>
<li>qosEnable : 是否启动QoS 默认true</li>
<li>qosPort : 启动QoS绑定的端口 默认22222</li>
<li>qosAcceptForeignIp: 是否允许远程访问 默认是false</li>
</ol>
<h4 id="6-2-dubbo-registry"><a href="#6-2-dubbo-registry" class="headerlink" title="6.2. dubbo:registry"></a>6.2. dubbo:registry</h4><p>org.apache.dubbo.config.RegistryConfig, 代表该模块所使用的注册中心。可注册一个也可注册多个。</p>
<ol>
<li>id : 当服务中provider或者consumer中存在多个注册中心时，则使用需要增加该配置。在一<br>些公司，<strong>会通过业务线的不同选择不同的注册中心</strong>。</li>
<li>address : 当前注册中心的访问地址。</li>
<li>protocol : 当前注册中心所使用的协议是什么。也可以直接在address 中写入，比如使用<br>zookeeper，就可以写成zookeeper://xx.xx.xx.xx:2181</li>
<li>timeout : 当与注册中心不再同一个机房时，大多会把该参数延长。</li>
</ol>
<h4 id="6-3-dubbo-protocol"><a href="#6-3-dubbo-protocol" class="headerlink" title="6.3. dubbo:protocol"></a>6.3. dubbo:protocol</h4><p>org.apache.dubbo.config.ProtocolConfig, 指定服务在进行数据传输所使用的协议。</p>
<ol>
<li>id : 在大公司，可能因为各个部门技术栈不同，所以可能会选择使用不同的协议进行交互。这里<br>在多个协议使用时，需要指定。</li>
<li>name : 指定协议名称。默认使用dubbo 。</li>
</ol>
<h4 id="6-4-dubbo-service"><a href="#6-4-dubbo-service" class="headerlink" title="6.4. dubbo:service"></a>6.4. dubbo:service</h4><p>org.apache.dubbo.config.ServiceConfig, 用于指定当前需要对外暴露的服务信息</p>
<ol>
<li>interface : 指定当前需要进行对外暴露的接口是什么。</li>
<li>ref : 具体实现对象的引用，一般我们在生产级别都是使用Spring去进行Bean托管的，所以这里面<br>一般也指的是Spring中的BeanId。</li>
<li>version : 对外暴露的版本号。不同的版本号，消费者在消费的时候只会根据固定的版本号进行消<br>费。</li>
</ol>
<h4 id="6-5-dubbo-reference"><a href="#6-5-dubbo-reference" class="headerlink" title="6.5. dubbo:reference"></a>6.5. dubbo:reference</h4><p>org.apache.dubbo.config.ReferenceConfig, 消费者的配置</p>
<ol>
<li>id : 指定该Bean在注册到Spring中的id。</li>
<li>interface: 服务接口名</li>
<li>version : 指定当前服务版本，与服务提供者的版本一致。</li>
<li>registry : 指定所具体使用的注册中心地址。这里面也就是使用上面在dubbo:registry 中所声<br>明的id。</li>
</ol>
<h4 id="6-6-dubbo-method"><a href="#6-6-dubbo-method" class="headerlink" title="6.6. dubbo:method"></a>6.6. dubbo:method</h4><p>org.apache.dubbo.config.MethodConfig, 用于在制定的dubbo:service 或者dubbo:reference 中的<br>更具体一个层级，指定具体方法级别在进行RPC操作时候的配置，可以理解为对这上面层级中的配置针<br>对于具体方法的特殊处理。</p>
<ol>
<li>name : 指定方法名称，用于对这个方法名称的RPC调用进行特殊配置。</li>
<li>async: 是否异步 默认false</li>
</ol>
<h4 id="6-7-dubbo-service和dubbo-reference详解"><a href="#6-7-dubbo-service和dubbo-reference详解" class="headerlink" title="6.7. dubbo:service和dubbo:reference详解"></a>6.7. dubbo:service和dubbo:reference详解</h4><ol>
<li>mock: 用于在方法调用出现错误时，当做服务降级来统一对外返回结果。</li>
<li>timeout: 用于指定当前方法或者接口中所有方法的超时时间。比如我们在进行第三方服务依赖时可能会对接口的时长做放宽，防止第三方服务不稳定。</li>
<li>check: 用于在启动时，检查生产者是否有该服务。我们一般都会将这个值设置为false，不让其进<br>行检查。因为如果出现模块之间循环引用的话，那么则<strong>可能会出现相互依赖</strong>，都进行check的话，那么这两个服务永远也启动不起来。</li>
<li>retries: 用于指定当前服务在执行时出现错误或者超时时的重试机制。<ol>
<li><strong>提供者必须幂等</strong>，否则可能出现数据一致性问题</li>
<li><strong>提供者是否有类似缓存机制</strong>，如出现大面积错误时，可能因为不停重试导致雪崩</li>
</ol>
</li>
<li>executes: 用于在提供者做配置，来确保最大的并行度。<ol>
<li>可能导致集群功能无法充分利用或者堵塞</li>
<li>但是也可以启动部分对应用的保护功能</li>
<li>可以不做配置，结合后面的熔断限流使用</li>
</ol>
</li>
</ol>
<p><strong>所有配置最终都将转换为 URL（protocol://username:password@host:port/path?key=value&amp;key=value）表示，并由服务提供方生成，经注册中心传递给消费方。</strong></p>
<h2 id="三、Dubbo高级实战"><a href="#三、Dubbo高级实战" class="headerlink" title="三、Dubbo高级实战"></a>三、Dubbo高级实战</h2><h3 id="1-SPI（面试常客）"><a href="#1-SPI（面试常客）" class="headerlink" title="1. SPI（面试常客）"></a>1. SPI（面试常客）</h3><h4 id="1-1-SPI简介"><a href="#1-1-SPI简介" class="headerlink" title="1.1 SPI简介"></a>1.1 SPI简介</h4><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。 目前有不少框架用它<br>来做服务的扩展发现（springboot），简单来说，它就是一种动态替换发现的机制。使用SPI机制的优势是实现解耦，<br>使得第三方服务模块的装配控制逻辑与调用者的业务代码分离。</p>
<h4 id="1-2-JDK中的SPI"><a href="#1-2-JDK中的SPI" class="headerlink" title="1.2 JDK中的SPI"></a>1.2 JDK中的SPI</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/1734313239bdd3ae?w=1210&h=450&f=png&s=160736" srcset="/img/loading.gif" alt></p>
<p>SPI遵循如下约定：</p>
<ul>
<li>当服务提供者提供了接口的一种具体实现后，在META-INF/services目录下创建一个以“接口全<br>限定名”为命名的文件，内容为实现类的全限定名；</li>
<li>接口实现类所在的jar包放在主程序的classpath中；</li>
<li>主程序通过java.util.ServiceLoader动态装载实现模块，它通过扫描META-INF/services目录下<br>的配置文件找到实现类的全限定名，把类加载到JVM；</li>
<li>SPI的实现类必须携带一个无参构造方法；</li>
</ul>
<h4 id="1-3-Dubbo中的SPI"><a href="#1-3-Dubbo中的SPI" class="headerlink" title="1.3 Dubbo中的SPI"></a>1.3 Dubbo中的SPI</h4><p>dubbo中大量的使用了SPI来作为扩展点，通过实现同一接口的前提下，可以进行定制自己的实现类。<br>比如比较常见的协议，负载均衡，都可以通过SPI的方式进行定制化，自己扩展。Dubbo中已经存在的<br>所有已经实现好的扩展点。详见dubbo-2.7.3.jar!/META-INF/dubbo/internal</p>
<h4 id="1-4-Dubbo中扩展点使用方式"><a href="#1-4-Dubbo中扩展点使用方式" class="headerlink" title="1.4 Dubbo中扩展点使用方式"></a>1.4 Dubbo中扩展点使用方式</h4><p>我们使用三个项目来演示Dubbo中扩展点的使用方式，一个主项目main，一个服务接口项目api，一个服务实现项目impl。</p>
<ul>
<li>创建接口</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span>(<span class="hljs-string">"human"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-function">String  <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;
    <span class="hljs-meta">@Adaptive</span>
    <span class="hljs-function">String  <span class="hljs-title">sayHello</span><span class="hljs-params">(URL url)</span></span>;
&#125;</code></pre></div>

<ul>
<li>创建实现类 </li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogHelloService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span></span>&#123;
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"wang wang"</span>;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(URL url)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"wang url"</span>;
    &#125;
&#125;</code></pre></div>

<ul>
<li>创建META-INF(key=value(实现类))</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined">human=com<span class="hljs-selector-class">.zjn</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.HumanHelloService</span>
dog=com<span class="hljs-selector-class">.zjn</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.DogHelloService</span></code></pre></div>

<ul>
<li>Main方法走起来</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboSpiMain</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        <span class="hljs-comment">// 获取扩展加载器</span>
        ExtensionLoader&lt;HelloService&gt;  extensionLoader  = ExtensionLoader.getExtensionLoader(HelloService.class);
        <span class="hljs-comment">// 遍历所有的支持的扩展点 META-INF.META-INF</span>
        Set&lt;String&gt; extensions = extensionLoader.getSupportedExtensions();
        <span class="hljs-keyword">for</span> (String extension : extensions)&#123;
            String result = extensionLoader.getExtension(extension).sayHello();
            System.out.println(result);
        &#125;

    &#125;
&#125;</code></pre></div>

<ul>
<li><p>dubbo自己做SPI的目的</p>
<div class="hljs"><pre><code>1. JDK 标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源
2. 如果有扩展点加载失败，则所有扩展点无法使用
3. 提供了对扩展点包装的功能(Adaptive)，并且还支持通过set的方式对其他的扩展点进行注入</code></pre></div></li>
</ul>
<h4 id="1-5-Dubbo-SPI中的Adaptive功能"><a href="#1-5-Dubbo-SPI中的Adaptive功能" class="headerlink" title="1.5 Dubbo SPI中的Adaptive功能"></a>1.5 Dubbo SPI中的Adaptive功能</h4><p>Dubbo中的Adaptive功能，主要解决的问题是如何动态的选择具体的扩展点。通过URL的方式对扩展点来进行动态选择。(dubbo中所有的注册信息都是通过URL的形式进行处理的。)</p>
<ul>
<li>接口在需要扩展的方法上加@Adaptive，案例见上面创建接口</li>
<li>创建Main方法</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboAdaptiveMain</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        URL url = URL.valueOf(<span class="hljs-string">"test://localhost/hello?hello.service=dog"</span>);
        <span class="hljs-keyword">final</span> HelloService adaptiveExtension=ExtensionLoader.getExtensionLoader(HelloService.class).getAdaptiveExtension();
        adaptiveExtension.sayHello(url);
    &#125;
&#125;</code></pre></div>

<ul>
<li>通过getAdaptiveExtension来提供一个统一的类来对所有的扩展点提供支持(底层对所有的扩展点进行封装)。</li>
<li>调用时通过参数中增加URL 对象来实现动态的扩展点使用。</li>
<li>如果URL没有提供该参数，则该方法会使用默认在SPI 注解中声明的实现。</li>
</ul>
<h4 id="1-6-Dubbo调用时拦截操作"><a href="#1-6-Dubbo调用时拦截操作" class="headerlink" title="1.6 Dubbo调用时拦截操作"></a>1.6 Dubbo调用时拦截操作</h4><p>提供了非常方便的扩展性，比如为dubbo接口实现ip白名单功能、监控功能、日志记录等。demo代码如下：</p>
<ul>
<li><p>实现org.apache.dubbo.rpc.Filter 接口</p>
</li>
<li><p>使用org.apache.dubbo.common.extension.Activate 接口进行对类进行注册 通过group 可以指定生产端 消费端</p>
<div class="hljs"><pre><code class="hljs undefined">@<span class="hljs-keyword">Activate</span>(<span class="hljs-keyword">group</span> = &#123;<span class="hljs-selector-tag">CommonConstants</span><span class="hljs-selector-class">.CONSUMER</span>)</code></pre></div>
</li>
<li><p>在META-INF.dubbo 中新建org.apache.dubbo.rpc.Filter 文件，并将当前类的全名写入</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">timerFilter</span>=包名.过滤器的名字</code></pre></div>

<h3 id="2-负载均衡策略"><a href="#2-负载均衡策略" class="headerlink" title="2 负载均衡策略"></a>2 负载均衡策略</h3><p>直接官方吧，很详细: <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p>
<h4 id="2-1-负载均衡基本配置"><a href="#2-1-负载均衡基本配置" class="headerlink" title="2.1 负载均衡基本配置"></a>2.1 负载均衡基本配置</h4><p>配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在服务消费者一方配置负载均衡策略</span>
<span class="hljs-meta">@Reference</span>(check = <span class="hljs-keyword">false</span>,loadbalance = <span class="hljs-string">"random"</span>)</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在服务提供者一方配置负载均衡</span>
<span class="hljs-meta">@Service</span>(loadbalance = <span class="hljs-string">"random"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span> + name;
    &#125;
&#125;</code></pre></div>

<h4 id="2-2-自定义负载均衡器"><a href="#2-2-自定义负载均衡器" class="headerlink" title="2.2 自定义负载均衡器"></a>2.2 自定义负载均衡器</h4><p>负载均衡器在Dubbo中的SPI接口是org.apache.dubbo.rpc.cluster.LoadBalance , 可以通过实现这个接口来实现自定义的负载均衡规则。</p>
<ul>
<li>创建负载均衡器OnlyFirstLoadbalancer</li>
<li>配置负载均衡器：在dubbo-spi-loadbalance工程的META-INF/dubbo 目录下新建<br>org.apache.dubbo.rpc.cluster.LoadBalance 文件，并将当前类的全名写入<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">onlyFirst</span>=包名.负载均衡器</code></pre></div>

</li>
</ul>
<p><strong>保证注册相同的注册中心。其他配置与过滤器配置相同</strong></p>
<h3 id="3-异步调用"><a href="#3-异步调用" class="headerlink" title="3 异步调用"></a>3 异步调用</h3><p>主要<strong>应用于提供者接口响应耗时明显</strong>，消费者端可以利用调用接口的时间去做一些其他的接口调用,利用Future模式来异步等待和获取结果即可。这种方式可以大大的提升消费者端的利用率。 目前这种方式可以通过XML的方式进行引入。</p>
<h4 id="3-1-异步调用实现"><a href="#3-1-异步调用实现" class="headerlink" title="3.1 异步调用实现"></a>3.1 异步调用实现</h4><ul>
<li>修改接口</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> timeToWait)</span></span>;</code></pre></div>

<ul>
<li>服务端接口实现sleep 为了模拟调用耗时 可以让线程等待一段时间</li>
<li>在消费者端，配置异步调用,配置如果提供端耗时大于1000毫秒超时</li>
</ul>
<div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"helloService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.zjn.service.HelloService"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sayHello"</span> <span class="hljs-attr">async</span>=<span class="hljs-string">"true"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre></div>

<ul>
<li>消费者端通过RpcContext.getContext().getFuture()来进行获取Future对象来进行后续的结果等待操作。</li>
</ul>
<h4 id="3-2-异步调用特殊说明"><a href="#3-2-异步调用特殊说明" class="headerlink" title="3.2 异步调用特殊说明"></a>3.2 异步调用特殊说明</h4><div class="hljs"><pre><code class="hljs !">注意：该方式的使用，请确保dubbo的版本在2.5.4及以后的版本使用。 原因在于在2.5.3及之前的版本使用的时候，会出现异步状态传递问题。
比如我们的服务调用关系是A-&gt;B-&gt;C,这时候如果A向B发起了异步请求，在错误的版本时，B向C发起的请求也会连带的产生异步请求。这是因为在底层实现层面，他是通过RPCContext 中的attachment实现的。在A向B发起异步请求时，会在attachment中增加一个异步标示字段来表明异步等待结果。B在接受到A中的请求时，会通过该字段来判断是否是异步处理。但是由于值传递问题，B向C发起时同样会将该值进行传递，导致C误以为需要异步结果，导致返回空。这个问题在2.5.4及以后的版本进行了修正。</code></pre></div>

<h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4 线程池"></a>4 线程池</h3><h4 id="4-1-Dubbo已有线程池"><a href="#4-1-Dubbo已有线程池" class="headerlink" title="4.1 Dubbo已有线程池"></a>4.1 Dubbo已有线程池</h4><p>dubbo在使用时，都是通过创建真实的业务线程池进行操作的。</p>
<ul>
<li>fix: 表示创建固定大小的线程池。也是Dubbo默认的使用方式，默认创建的执行线程数为200，并且是没有任何等待队列的。所以再极端的情况下可能会存在问题，比如某个操作大量执行时，可能存在堵塞的情况。</li>
<li>cache: 创建非固定大小的线程池，当线程不足时，会自动创建新的线程。但是使用这种的时候需要注意，如果突然有高TPS的请求过来，方法没有及时完成，则会造成大量的线程创建，对系统的CPU和负载都是压力，执行越多反而会拖慢整个系统。</li>
</ul>
<h4 id="4-2-自定义线程池"><a href="#4-2-自定义线程池" class="headerlink" title="4.2 自定义线程池"></a>4.2 自定义线程池</h4><p>特殊业务使用fix模式，可能会因为线程不足产生错误。这是无感知的，所以要做一个线程监控，这样就可以进行及时的扩缩容机器或者告警。如下可以自定义线程池：</p>
<ol>
<li>线程池实现, 这里主要是基于对FixedThreadPool 中的实现做扩展出线程监控的部分,注意<strong>要写构造方法</strong>,上代码</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjn.threadpool;

<span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;

<span class="hljs-keyword">import</span> org.apache.dubbo.common.threadpool.support.fixed.FixedThreadPool;
<span class="hljs-keyword">import</span> org.slf4j.Logger;
<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.concurrent.*;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span>: 190coder &lt;190coder.cn&gt;
 * <span class="hljs-doctag">@description</span>:
 * <span class="hljs-doctag">@create</span>: 2020-07-13 16:31
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WachingThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FixedThreadPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;
    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WachingThreadPool.class);
    <span class="hljs-comment">// 定义线程池使用的阀值</span>
    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  <span class="hljs-keyword">double</span>  ALARM_PERCENT = <span class="hljs-number">0.90</span>;
    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> Map&lt;URL, ThreadPoolExecutor&gt; THREAD_POOLS = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();
    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">WachingThreadPool</span><span class="hljs-params">()</span></span>&#123;
        <span class="hljs-comment">// 每隔3秒打印线程使用情况</span>
        Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(<span class="hljs-keyword">this</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>, TimeUnit.SECONDS);
    &#125;


    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getExecutor</span><span class="hljs-params">(URL url)</span> </span>&#123;
        <span class="hljs-keyword">final</span>  Executor executor = <span class="hljs-keyword">super</span>.getExecutor(url);
        <span class="hljs-keyword">if</span>(executor <span class="hljs-keyword">instanceof</span> ThreadPoolExecutor)&#123;
            THREAD_POOLS.put(url,(ThreadPoolExecutor)executor);
        &#125;
        <span class="hljs-keyword">return</span>  executor;
    &#125;

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;

        <span class="hljs-comment">// 遍历线程池</span>
        <span class="hljs-keyword">for</span> (Map.Entry&lt;URL,ThreadPoolExecutor&gt; entry: THREAD_POOLS.entrySet())&#123;
            <span class="hljs-keyword">final</span>   URL  url = entry.getKey();
            <span class="hljs-keyword">final</span>   ThreadPoolExecutor  executor = entry.getValue();
            <span class="hljs-comment">// 计算相关指标</span>
            <span class="hljs-keyword">final</span>  <span class="hljs-keyword">int</span>  activeCount  = executor.getActiveCount();
            <span class="hljs-keyword">final</span>  <span class="hljs-keyword">int</span>  poolSize = executor.getCorePoolSize();
            <span class="hljs-keyword">double</span>  usedPercent = activeCount / (poolSize*<span class="hljs-number">1.0</span>);
            LOGGER.info(<span class="hljs-string">"线程池执行状态:[&#123;&#125;/&#123;&#125;:&#123;&#125;%]"</span>,activeCount,poolSize,usedPercent*<span class="hljs-number">100</span>);
            <span class="hljs-keyword">if</span> (usedPercent &gt; ALARM_PERCENT)&#123;
                LOGGER.error(<span class="hljs-string">"超出警戒线! host:&#123;&#125; 当前使用率是:&#123;&#125;,URL:&#123;&#125;"</span>,url.getIp(),usedPercent*<span class="hljs-number">100</span>,url);
            &#125;

        &#125;

    &#125;
&#125;</code></pre></div>

<ol start="2">
<li>SPI声明，创建文件META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool</li>
</ol>
<div class="hljs"><pre><code class="hljs undefined">watching=com<span class="hljs-selector-class">.zjn</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.WachingThreadPool</span> <span class="hljs-comment">// 包名.线程池名</span></code></pre></div>

<ol start="3">
<li>服务提供方项目引入该依赖,设置使用该线程池生成器</li>
</ol>
<div class="hljs"><pre><code class="hljs undefined">dubbo<span class="hljs-selector-class">.provider</span><span class="hljs-selector-class">.threadpool</span>=watching</code></pre></div>

<h3 id="5-路由规则"><a href="#5-路由规则" class="headerlink" title="5. 路由规则"></a>5. 路由规则</h3><p>路由是决定一次请求中需要发往目标机器的重要判断，通过对其控制可以决定请求的目标机器。我们可以通过创建这样的规则来决定一个请求会交给哪些服务器去处理。</p>
<h4 id="5-1-快速入门"><a href="#5-1-快速入门" class="headerlink" title="5.1 快速入门"></a>5.1 快速入门</h4><p>（1）提供两个提供者(一台本机作为提供者，一台为其他的服务器)，每个提供者会在调用时可以返回不同的信息 以区分提供者。</p>
<p>（2）针对于消费者，我们这里通过一个死循环，每次等待用户输入，再进行调用，来模拟真实的请求情况。通过调用的返回值 确认具体的提供者。</p>
<p>（3）我们通过ipconfig来查询到我们的IP地址，并且单独启动一个客户端，来进行如下配置(这里假设我们希望隔离掉本机的请求，都发送到另外一台机器上)。</p>
<p><strong>如果无集群，可只启一个客户端和服务端作为测试，执行一次，可根据规则禁止同一zk内的服务。设置规则如下：</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;
<span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;
<span class="hljs-keyword">import</span> org.apache.dubbo.registry.Registry;
<span class="hljs-keyword">import</span> org.apache.dubbo.registry.RegistryFactory;

<span class="hljs-comment">/**
 * <span class="hljs-doctag">@author</span>: 190coder &lt;190coder.cn&gt;
 * <span class="hljs-doctag">@description</span>:
 * <span class="hljs-doctag">@create</span>: 2020-07-13 18:00
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboRouterMain</span> </span>&#123;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;
        RegistryFactory registryFactory =
                ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
                
        Registry registry =
                registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">"zookeeper://127.0.0.1:2181"</span>));
        registry.register(URL.valueOf(<span class="hljs-string">"condition://0.0.0.0/com.zjn.service.HelloService?category=routers&amp;force=true&amp;dynamic=true&amp;rule="</span> + URL.encode(<span class="hljs-string">"=&gt; host != 你的机器ip不能是127.0.0.1"</span>)));
    &#125;
&#125;</code></pre></div>

<h4 id="5-2-路由规则详解"><a href="#5-2-路由规则详解" class="headerlink" title="5.2 路由规则详解"></a>5.2 路由规则详解</h4><p>通过上面的程序，我们实际本质上就是通过在zookeeper中保存一个节点数据，来记录路由规则。消费<br>者会通过监听这个服务的路径，来感知整个服务的路由规则配置，然后进行适配。<br>参数详解官方文档走起 -&gt; <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule-deprecated.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule-deprecated.html</a></p>
<h4 id="5-3-路由与上线系统结合"><a href="#5-3-路由与上线系统结合" class="headerlink" title="5.3 路由与上线系统结合"></a>5.3 路由与上线系统结合</h4><p>实战场景：一个dubbo的提供者要准备进行上线，一般都提供多台提供者来同时在线上提供服务。这时候一个请求刚到达一个提供者，提供者却进行了关闭操作。那么此次请求就应该认定为失败了。所以基于这样的场景，我们可以通过路由的规则，把预发布(灰度)的机器进行从机器列表中移除。并且等待一定的时间，让其把现有的请求处理完成之后再进行关闭服务。同时，在启动时，同样需要等待一定的时间，以免因为尚未重启结束，就已经注册上去。等启动到达一定时间之<br>后，再进行开启流量操作。</p>
<p><strong>实现主体思路 ：</strong></p>
<div class="hljs"><pre><code>1.利用zookeeper的路径感知能力，在服务准备进行重启之前将当前机器的IP地址和应用名写入zookeeper。
2.服务消费者监听该目录，读取其中需要进行关闭的应用名和机器IP列表并且保存到内存中。
3.当前请求过来时，判断是否是请求该应用，如果是请求重启应用，则将该提供者从服务列表中移除。</code></pre></div><p>具体操作流程：</p>
<ol>
<li>引入Curator 框架，操作Zookeeper</li>
<li>编写需要进行预发布的路径管理器，用于缓存和监听所有的待灰度机器信息列表。</li>
<li>编写路由类(实现org.apache.dubbo.rpc.cluster.Router )，主要目的在于对<br> ReadyRestartInstances中的数据进行处理，并且移除路由调用列表中正在重启中的服务。</li>
<li>由于Router 机制比较特殊，所以需要利用一个专门的RouterFactory来生成，原因在于并不是所有的都需要添加路由，所以需要利用@Activate 来锁定具体哪些服务才需要生成使用。</li>
</ol>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Activate</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestartingInstanceRouterFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RouterFactory</span> </span>&#123;
    <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> Router <span class="hljs-title">getRouter</span><span class="hljs-params">(URL url)</span> </span>&#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestartingInstanceRouter(url); <span class="hljs-comment">// 自定义router实现类</span>
    &#125;
&#125;</code></pre></div>

<ol start="5">
<li>对RouterFactory 进行注册，同样放入到 META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory</li>
</ol>
<div class="hljs"><pre><code class="hljs undefined">restartInstances=com<span class="hljs-selector-class">.lagou</span><span class="hljs-selector-class">.router</span><span class="hljs-selector-class">.RestartingInstanceRouterFactory</span></code></pre></div>

<ol start="6">
<li>完成对zk节点的操作，使得节点列表变更</li>
</ol>
<h3 id="6-服务动态降级"><a href="#6-服务动态降级" class="headerlink" title="6. 服务动态降级"></a>6. 服务动态降级</h3><h4 id="6-1-什么是服务降级"><a href="#6-1-什么是服务降级" class="headerlink" title="6.1 什么是服务降级"></a>6.1 什么是服务降级</h4><p>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。</p>
<h4 id="6-2-为什么要服务降级"><a href="#6-2-为什么要服务降级" class="headerlink" title="6.2 为什么要服务降级"></a>6.2 为什么要服务降级</h4><p>防止分布式服务发生雪崩效应，什么是雪崩？就是蝴蝶效应，当一个请求发生超时，一直等待着服务响应，那么在高并发情况下，很多请求都是因为这样一直等着响应，直到<br>服务资源耗尽产生宕机，而宕机之后会导致分布式其他服务调用该宕机的服务也会出现资源耗尽宕机，这样下去将导致整个分布式服务都瘫痪，这就是雪崩。</p>
<h4 id="6-3-dubbo-服务降级实现"><a href="#6-3-dubbo-服务降级实现" class="headerlink" title="6.3 dubbo 服务降级实现"></a>6.3 dubbo 服务降级实现</h4><ul>
<li>在 dubbo 管理控制台配置服务降级<ul>
<li>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li>
<li>mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/13/1734891d35c3a919?w=1246&h=464&f=png&s=276805" srcset="/img/loading.gif" alt></p>
<ul>
<li><p>配置xml 指定返回简单值或者null</p>
  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxService"</span> <span class="hljs-attr">check</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xx.XxService"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"3000"</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">"return null"</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxService2"</span> <span class="hljs-attr">check</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xx.XxService2"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"3000"</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">"return 1234"</span> /&gt;</span></code></pre></div>
</li>
<li><p>注解 ：@Reference(mock=”return null”) @Reference(mock=”return 简单值”)<br>也支持 @Reference(mock=”force:return null”)</p>
</li>
<li><p>嵌入代码：</p>
  <div class="hljs"><pre><code class="hljs java">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();
Registry registry=registryFactory.getRegistry(URL.valueOf("zookeeper://IP:端口"));
registry.register(URL.valueOf("override://0.0.0.0/com.foo.BarService?
category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null"));</code></pre></div>


</li>
</ul>
<h2 id="四、-源码剖析"><a href="#四、-源码剖析" class="headerlink" title="四、 源码剖析"></a>四、 源码剖析</h2><h3 id="1-源码下载-amp-编译"><a href="#1-源码下载-amp-编译" class="headerlink" title="1. 源码下载&amp;编译"></a>1. 源码下载&amp;编译</h3><p>下载地址-&gt; <a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">https://github.com/apache/dubbo</a> ，防止master不问题，可以切换 分支到 release 版本，下载本地执行 mvn install -DskipTests</p>
<h3 id="2-架构整体设计"><a href="#2-架构整体设计" class="headerlink" title="2. 架构整体设计"></a>2. 架构整体设计</h3><h4 id="2-1-调用关系说明"><a href="#2-1-调用关系说明" class="headerlink" title="2.1 调用关系说明"></a>2.1 调用关系说明</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17351be6584a2799?w=1378&h=884&f=png&s=512853" srcset="/img/loading.gif" alt></p>
<ul>
<li>provider : 服务提供方<ul>
<li>Protocol ： 协议交互</li>
<li>Service ：真实的服务接口实现</li>
<li>Container ： Dubbo的运行环境</li>
</ul>
</li>
<li>Consumer: 服务消费方<ul>
<li>Protocol ： 协议交互</li>
<li>Cluster ：感知提供者端的列表信息</li>
<li>Proxy ：理解成提供者的服务调用代理类由它接管Consumer中的接口调用逻辑</li>
</ul>
</li>
<li>Registry: 注册中心，用的zk</li>
<li>Monitor: 提供者和消费者中的数据统计，比如调用频次，成功失败次数等信息。</li>
</ul>
<p><strong>启动和执行流程说明</strong> :</p>
<ul>
<li>provider启动，容器负责把Service信息加载，通过Protocol注册到 Registry</li>
<li>Consumer启动，通过监听提供者列表来感知提供者信息 并在提供者发生改变时 通过注册中心及时通知消费端</li>
<li>消费方发起 请求 通过Proxy模块</li>
<li>利用Cluster模块 来选择真实的要发送给的提供者信息</li>
<li>交由Consumer中的Protocol 把信息发送给提供者</li>
<li>提供者同样需要通过 Protocol 模块来处理消费者的信息</li>
<li>最后由真正的服务提供者 Service 来进行处理</li>
</ul>
<h4 id="2-2-整体的调用链路"><a href="#2-2-整体的调用链路" class="headerlink" title="2.2 整体的调用链路"></a>2.2 整体的调用链路</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17351d50782401e9?w=1612&h=1474&f=png&s=1613107" srcset="/img/loading.gif" alt></p>
<ul>
<li><p>淡绿色 代表了服务生产者的范围</p>
</li>
<li><p>淡蓝色 代表了服务消费者的范围 </p>
</li>
<li><p>红色箭头 代表了调用的方向</p>
</li>
</ul>
<p>总结下简单流程：</p>
<ol>
<li>Consumer通过Interface进行方法调用交给消费端Proxy，使用jdk/javassist代理技术</li>
<li>交给filter 使用SPI机制统一过滤请求</li>
<li>invoker调用，去配置中心读取信息，获取所有Invoker<ol>
<li>通过Cluster，根据选择路由规则选取Invoker列表</li>
<li>通过LoadBalance 负载均衡选择一个Invoker处理请求</li>
<li>如果出错，开始重试机制</li>
</ol>
</li>
<li>继续通过filter功能选择具体执行协议</li>
<li>客户端进行编码和序列化，发送数据</li>
<li>数据到达Service，进行反编码和反序列化接收数据</li>
<li>使用Exporter选择执行器（dubbo，rmi…）</li>
<li>交给filter 进行一个提供者过滤，到达Invoker执行器</li>
<li>通过Invoker 调用接口的具体实现 然后返回</li>
</ol>
<h4 id="2-3-源码整体设计"><a href="#2-3-源码整体设计" class="headerlink" title="2.3 源码整体设计"></a>2.3 源码整体设计</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1735295ddc568609?w=1568&h=1210&f=png&s=2750668" srcset="/img/loading.gif" alt></p>
<p>码整体设计与调用链路十分相似。只不过这里可以看到接口的一些具体实现以及左侧也有更为详细的<strong>层次划分</strong>， 如下：。</p>
<ul>
<li>service 业务层 包括我们的业务代码 比如 接口 实现类 直接面向开发者<br>RPC层 远程过程调用层</li>
<li>config 配置层 对外提供配置 以ServiceConfig ReferenceConfig 为核心 可以直接初始化配置类 也可以解析配置文件生成</li>
<li>proxy 服务代理层 无论是生产者 还是消费者 框架都会产生一个代理类 整个过程对上层透明 就是业务层对远程调用无感</li>
<li>registry 注册中心层 封装服务地址的注册与发现 以服务的URL为中心</li>
<li>cluster 路由层 (集群容错层)提供了多个提供者的路由和负载均衡并且它桥接注册中心 以Invoker为核心</li>
<li>monitor 监控层 RPC调用相关的信息 如 调用次数 成功失败的情况 调用时间等 在这一层完成</li>
<li>protocol 远程调用层 封装RPC调用 无论是服务的暴露 还是 服务的引用 都是在Protocol中作为主功能入口负责Invoker的整个生命周期Dubbo中所有的模型都向Invoker靠拢</li>
<li>Remoting层 远程数据传输层</li>
<li>exchange 信息交换层 封装请求和响应的模式 如把请求由同步 转换成异步</li>
<li>transport 网络传输层 统一网络传输的接口 比如 netty 和 mina统一为一个网络传输接口</li>
<li>serialize 数据序列化层 负责管理整个框架中的数据传输的序列化 和反序列化</li>
</ul>
<h3 id="3-服务注册与消费源码剖析"><a href="#3-服务注册与消费源码剖析" class="headerlink" title="3. 服务注册与消费源码剖析"></a>3. 服务注册与消费源码剖析</h3><h4 id="3-1-注册中心Zookeeper剖析"><a href="#3-1-注册中心Zookeeper剖析" class="headerlink" title="3.1 注册中心Zookeeper剖析"></a>3.1 注册中心Zookeeper剖析</h4><p>我们可以选择Redis、Nacos、Zookeeper作为Dubbo的注册中心，<strong>Dubbo推荐用户使用Zookeeper作为注册中心。</strong></p>
<p><strong>注册中心Zookeeper目录结构</strong></p>
<p>假设有个最基本的demo为我们提供服务</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;
    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;
&#125;</code></pre></div>

<p>则zk的目录结果如下：</p>
<div class="hljs"><pre><code class="hljs undefined">+- dubbo
| +- com.lagou.service.HelloService
| | +- consumers
| | | +- consumer:<span class="hljs-comment">//192.168.1.102/com.lagou.service.HelloService?</span>
application=dubbo-demo-annotationconsumer&amp;
category=consumers<span class="hljs-variable">&amp;check</span>=false<span class="hljs-variable">&amp;dubbo</span>=<span class="hljs-number">2.0</span><span class="hljs-number">.2</span><span class="hljs-variable">&amp;init</span>=false<span class="hljs-variable">&amp;interface</span>=com.lag
ou.service.HelloService<span class="hljs-variable">&amp;methods</span>=sayHello,sayHelloWithPrint,sayHelloWithTransmiss
ion,sayHelloWithException<span class="hljs-variable">&amp;pid</span>=<span class="hljs-number">25923</span><span class="hljs-variable">&amp;release</span>=<span class="hljs-number">2.7</span><span class="hljs-number">.5</span><span class="hljs-variable">&amp;side</span>=consumer<span class="hljs-variable">&amp;sticky</span>=false<span class="hljs-variable">&amp;tim</span>
estamp=<span class="hljs-number">1583896043650</span>
| | +- providers
| | | +- dubbo:<span class="hljs-comment">//192.168.1.102:20880/com.lagou.service.HelloService?</span>
anyhost=true<span class="hljs-variable">&amp;application</span>=dubbo-demo-annotationprovider&amp;
deprecated=false<span class="hljs-variable">&amp;dubbo</span>=<span class="hljs-number">2.0</span><span class="hljs-number">.2</span><span class="hljs-variable">&amp;dynamic</span>=true<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.l
agou.service.HelloService<span class="hljs-variable">&amp;methods</span>=sayHello,sayHelloWithPrint,sayHelloWithTransmi
ssion,sayHelloWithException<span class="hljs-variable">&amp;pid</span>=<span class="hljs-number">25917</span><span class="hljs-variable">&amp;release</span>=<span class="hljs-number">2.7</span><span class="hljs-number">.5</span><span class="hljs-variable">&amp;side</span>=provider<span class="hljs-variable">&amp;telnet</span>=clear,e
xit,help,status,log,ls,ps,cd,pwd,invoke,trace,count,select,shutdown<span class="hljs-variable">&amp;timestamp</span>=<span class="hljs-number">15</span>
<span class="hljs-number">83896023597</span>
| | +- configuration
| | +- routers</code></pre></div>

<p>结构很明显，都在dubbo节点下，全限定接口名作为服务，底下有4个配置</p>
<ul>
<li>consumers:的消费者列表(URL)</li>
<li>providers:提供者列表(URL)</li>
<li>configuration:配置信息，provider或者consumer会通过读取这里的配<br>置信息来获取配置</li>
<li>routers:当消费者在进行获取提供者的时，会通过这里配置好的路由来进行适配匹配规则。</li>
</ul>
<p><strong>dubbo基本上很多时候都是通过URL的形式来进行交互获取数据的，在URL中也会保存<br>很多的信息。</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352c8c0c0cfe9e?w=1548&h=878&f=png&s=484882" srcset="/img/loading.gif" alt></p>
<p>如图所示：</p>
<ul>
<li>提供者会在providers 目录下进行自身的进行注册。</li>
<li>消费者会在consumers 目录下进行自身注册，并且监听provider 目录，以此通过监听提供者增加或者减少，实现服务发现。</li>
<li>Monitor模块会对整个服务级别做监听，用来得知整体的服务情况。以此就能更多的对整体情况做<br>监控。</li>
</ul>
<h4 id="3-2-服务的注册过程分析"><a href="#3-2-服务的注册过程分析" class="headerlink" title="3.2 服务的注册过程分析"></a>3.2 服务的注册过程分析</h4><p>服务注册(暴露)过程</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352cb7860b7678?w=1508&h=914&f=png&s=739178" srcset="/img/loading.gif" alt></p>
<p>debug调试分析下具体流程：</p>
<ol>
<li>启动源码的provider-demo</li>
<li>进入到org/apache/dubbo/config/ServiceConfig.java，服务配置</li>
<li>通过ProxyFactory 调用接口实现类中的 getInvoker 方法使用 ref 生成一个 AbstractProxyInvoker 实例，到这一步就完成具体服务到 Invoker 的转化。接下来就是 Invoker 转换到 Exporter 的过程。</li>
<li>最终调用 org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol 把Invoker 转换成 Exporter</li>
<li>服务配置组装完成后，通过org.apache.dubbo.registry.integration.RegistryProtocol#export 将我们需要执行的信息注册并且导出。</li>
<li>调用AbstractRegistry的继承类org.apache.dubbo.registry.support.FailbackRegistry#register，像zk 完成create注册</li>
</ol>
<p><strong>详细说下Registry中的类目录结构 :</strong></p>
<div class="hljs"><pre><code class="hljs undefined">+- RegistryService
|<span class="hljs-string"> +- Registry
</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- AbstractRegistry
</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- FailbackRegistry
</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- ZookeeperRegistry
</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- NacosRegistry
</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- ...</span></code></pre></div>

<p>注册就是使用的FailbackRegistry#register，从名字中可以看出来，失败自动恢复，后台记录失败请求，调用<strong>addFailedRegistered内部通过 Timer定时器去定时重发功能</strong>。</p>
<h4 id="3-3-URL规则详解-和-服务本地缓存"><a href="#3-3-URL规则详解-和-服务本地缓存" class="headerlink" title="3.3 URL规则详解 和 服务本地缓存"></a>3.3 URL规则详解 和 服务本地缓存</h4><h5 id="3-3-1-URL规则详解"><a href="#3-3-1-URL规则详解" class="headerlink" title="3.3.1 URL规则详解"></a>3.3.1 URL规则详解</h5><p>URL demo :</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">protocol:</span><span class="hljs-comment">//host:port/path?key=value&amp;key=value // 模版</span>
<span class="hljs-symbol">
provider:</span><span class="hljs-comment">//192.168.20.1:20883/com.zjn.service.HelloService?</span>
anyhost=true<span class="hljs-variable">&amp;application</span>=serviceprovider2&amp;
bind.ip=<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.1</span><span class="hljs-variable">&amp;bind</span>.port=<span class="hljs-number">20883</span><span class="hljs-variable">&amp;category</span>=configurators<span class="hljs-variable">&amp;check</span>=fals
e<span class="hljs-variable">&amp;deprecated</span>=false<span class="hljs-variable">&amp;dubbo</span>=<span class="hljs-number">2.0</span><span class="hljs-number">.2</span><span class="hljs-variable">&amp;dynamic</span>=true<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.zjn.service</code></pre></div>

<p>详解URL组成：</p>
<ul>
<li>protocol: 协议，一般像我们的provider 或者consumer 在这里都是人为具体的协议</li>
<li>host: 当前provider 或者其他协议所具体针对的地址，比较特殊的像override 协议所指定的</li>
<li>host就是0.0.0.0 代表所有的机器都生效</li>
<li>port: 和上面相同，代表所处理的端口号</li>
<li>path: 服务路径，在provider 或者consumer 等其他中代表着我们真实的业务接口</li>
<li>key=value: 这些则代表具体的参数，这里我们可以理解为对这个地址的配置。比如我们provider中需要具体机器的服务应用名，就可以是一个配置的方式设置上去。</li>
</ul>
<p><strong>注意：Dubbo中的URL与java中的URL是有一些区别的，如下：</strong></p>
<ul>
<li>这里提供了针对于参数的parameter 的增加和减少(支持动态更改)</li>
<li>提供缓存功能，对一些基础的数据做缓存.</li>
</ul>
<h5 id="3-3-2-服务本地缓存"><a href="#3-3-2-服务本地缓存" class="headerlink" title="3.3.2 服务本地缓存"></a>3.3.2 服务本地缓存</h5><p>上面说了会对基础数据进行缓存，dubbo调用者需要通过注册中心（例如：ZK）注册信息，获取提供者，但是如果频繁往从ZK获取信息，<strong>肯定会存在单点故障问题，所以dubbo提供了将提供者信息缓存在本地的方法。</strong> </p>
<ul>
<li>Dubbo在订阅注册中心的回调处理逻辑当中会保存服务提供者信息到本地缓存文件当中（同步/异步两种方式），以URL纬度进行全量保存。</li>
<li>Dubbo在服务引用过程中会创建registry对象并加载本地缓存文件，会优先订阅注册中心，订阅注册中<br>心失败后会访问本地缓存文件内容获取服务提供信息。</li>
</ul>
<p>保存缓存流程如下：</p>
<ul>
<li>通过 org.apache.dubbo.registry.support.AbstractRegistry#AbstractRegistry#loadProperties加载已存在配置文件</li>
<li>在通过 notify 方法 调用saveProperties</li>
<li>doSaveProperties 进行保存文件，加锁 将配置的文件信息保存到文件中。执行出现错误时，则交给专门的线程去进行重试</li>
</ul>
<h4 id="3-4-Dubbo-消费过程分析"><a href="#3-4-Dubbo-消费过程分析" class="headerlink" title="3.4 Dubbo 消费过程分析"></a>3.4 Dubbo 消费过程分析</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/17355929f6b2debf?w=1740&h=986&f=png&s=975668" srcset="/img/loading.gif" alt></p>
<p>首先 ReferenceConfig 类的 init 方法调用 createProxy() ,期间 使用Protocol 调用 refer 方法生成 Invoker实例(如上图中的红色部分)，这是服务消费的关键。接下来使用ProxyFactory把 Invoker转换为客户端需要的接口(如：HelloService)。</p>
<h3 id="4-Dubbo扩展SPI源码剖析"><a href="#4-Dubbo扩展SPI源码剖析" class="headerlink" title="4. Dubbo扩展SPI源码剖析"></a>4. Dubbo扩展SPI源码剖析</h3><p>SPI在之前都有使用过，其中最重要的类就是ExtensionLoader，它是所有Dubbo中SPI的入口。</p>
<p>getExtensionLoader 获取扩展点加载器 并加载所对应的所有的扩展点实现</p>
<p>getExtension 根据name 获取扩展的指定实现</p>
<h4 id="4-1-getExtensionLoader-加载过程"><a href="#4-1-getExtensionLoader-加载过程" class="headerlink" title="4.1 getExtensionLoader 加载过程"></a>4.1 getExtensionLoader 加载过程</h4><ul>
<li><p>org/apache/dubbo/common/extension/ExtensionLoader.java这里的构造函数 获取ExtensionFactory 对象：</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ExtensionLoader</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;
    <span class="hljs-keyword">this</span>.type = type;
    <span class="hljs-comment">// 这里需要对对象的工厂做额外的创建，可以看到扩展的工厂也是一个扩展点</span>
    objectFactory = (type == ExtensionFactory.class ? <span class="hljs-keyword">null</span> :
    ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());
&#125;</code></pre></div>
</li>
<li><p>ExtensionFactory 通过传入扩展点类型和真正的名称来获取扩展的。这里就和我们SPI中的具体名称实现相挂钩。</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExtensionFactory</span> </span>&#123;
    <span class="hljs-comment">/**
    * Get extension.
    *
    * <span class="hljs-doctag">@param</span> type object type.
    * <span class="hljs-doctag">@param</span> name object name.
    * <span class="hljs-doctag">@return</span> object instance.
    */</span>
    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getExtension</span><span class="hljs-params">(Class&lt;T&gt; type, String name)</span></span>;
&#125;</code></pre></div>
</li>
<li><p>dubbo-common/src/main/resources/METAINF/<br>dubbo/internal/org.apache.dubbo.common.extension.ExtensionFactory 中看到，他默认有三个实现的提供</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined">spring=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.SpringExtensionFactory</span>
adaptive=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.AdaptiveExtensionFactory</span>
spi=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.SpiExtensionFactory</span></code></pre></div>

<ul>
<li><p>AdaptiveExtensionFactory实现类上有@Adaptive，优先最高的默认实现类。作用是代理其他的ExtensionFactory。其中比较重要的方法在于<br>getSupportedExtensions 方法，获取所有支持的扩展信息实现。</p>
</li>
<li><p>org.apache.dubbo.common.extension.ExtensionLoader#getSupportedExtensions 获取所有的扩展类信息，返回所有的扩展点名称</p>
</li>
<li><p>getExtensionClasses() 双重检查为空从进行加载信息 加载扩展类</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;
    <span class="hljs-comment">// 从缓存中获取已加载的扩展类</span>
    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();
        <span class="hljs-comment">// 双重检查</span>
        <span class="hljs-keyword">if</span> (classes == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// 为空的话，则锁住，标识只会被执行一次</span>
            <span class="hljs-keyword">synchronized</span> (cachedClasses) &#123;
            classes = cachedClasses.get();
            <span class="hljs-keyword">if</span> (classes == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-comment">// 进行加载信息 加载扩展类</span>
            classes = loadExtensionClasses();
            cachedClasses.set(classes);
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> classes;
&#125;</code></pre></div>
</li>
<li><p>进入到loadExtensionClasses,主要做了两件事情。1: 加载当前SPI的默认实现。2:<br>加载这个类的所有扩展点实现，并且按照name和Class对象的形式存储</p>
</li>
<li><p>之后就是各种load…从指定META-INF下几个子目录找并加载，最终到达loadClass类的实现，可以看到这里是最终进行完成类映射的地方。</p>
</li>
</ul>
<p>当执行完这几个方法之后，会对一下几个字段进行更新:</p>
<ul>
<li>cachedAdaptiveClass: 当前Extension类型对应的AdaptiveExtension类型(只能一个)</li>
<li>cachedWrapperClasses: 当前Extension类型对应的所有Wrapper实现类型(无顺序)</li>
<li>cachedActivates: 当前Extension实现自动激活实现缓存(map,无序)</li>
<li>cachedNames: 扩展点实现类对应的名称(如配置多个名称则值为第一个)</li>
</ul>
<h4 id="4-2-根据name获取扩展点的方法-getExtension"><a href="#4-2-根据name获取扩展点的方法-getExtension" class="headerlink" title="4.2 根据name获取扩展点的方法 getExtension"></a>4.2 根据name获取扩展点的方法 getExtension</h4><ul>
<li><p>getExtension 方法实现。这里面同样主要作用是根据name对扩展点进行处理和进行加锁来创建真实的引用，其中都是有使用缓存来处理。<strong>可见真正的实例对象在getExtension</strong></p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getExtension</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> wrap)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Extension name == null"</span>);
        &#125;
        <span class="hljs-keyword">if</span> (<span class="hljs-string">"true"</span>.equals(name)) &#123;
            <span class="hljs-keyword">return</span> getDefaultExtension();
        &#125;
        <span class="hljs-comment">// 获取当前类的holder，实现原理和cachedClasses的方式相同，都是建立同一个引用后再进行加锁</span>
        <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);
        Object instance = holder.get();
        <span class="hljs-comment">// 双重检查</span>
        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">synchronized</span> (holder) &#123;
                instance = holder.get();
                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;
                    instance = createExtension(name, wrap);
                    holder.set(instance);
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> (T) instance;
    &#125;</code></pre></div>
</li>
<li><p>getOrCreateHolder 保证缓存</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Holder&lt;Object&gt; <span class="hljs-title">getOrCreateHolder</span><span class="hljs-params">(String name)</span> </span>&#123;
    <span class="hljs-comment">// 获取当前名称的和对象Holder的映射关系</span>
    Holder&lt;Object&gt; holder = cachedInstances.get(name);
    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;
    <span class="hljs-comment">// 如果不存在的话，则使用putIfAbsent的原子操作来设置值，这个值可以保证多线程的额情</span>
    况下有值的时候不处理，没有值进行保存
    cachedInstances.putIfAbsent(name, <span class="hljs-keyword">new</span> Holder&lt;&gt;());
    <span class="hljs-comment">// 获取真实的holder处理器</span>
    holder = cachedInstances.get(name);
    &#125;
    <span class="hljs-keyword">return</span> holder;
&#125;</code></pre></div>
</li>
<li><p>进入到createExtension根据扩展的class名称来进行创建实例的类。这里也是创建扩展点类的主要实现。</p>
<div class="hljs"><pre><code class="hljs java">private T createExtension(String name) &#123;
    // 从配置文件中加载所有的扩展类 可以得到配置项名称 到配置类的映射关系
    Class&lt;?&gt; clazz = getExtensionClasses().get(name);
    if (clazz == null) &#123;
         throw findException(name);
    &#125;
    try &#123;
        // 获取是否已经有实例了
        T instance = (T) EXTENSION_INSTANCES.get(clazz);
        if (instance == null) &#123;
        // 没有的话，同样适用putIfAbsent的方式来保证只会创建一个对象并且保存
        EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
        instance = (T) EXTENSION_INSTANCES.get(clazz);
        &#125;
        // 注入其他扩展点的实体，用于扩展点和其他的扩展点相互打通
        injectExtension(instance);
        // 进行遍历所有的包装类信息，分别对包装的类进行包装实例化，并且返回自身引用
        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;
        if (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;
            for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;
            // 同样进行注册其他扩展点的功能
            （4） injectExtension 方法观察
            instance = injectExtension((T)
            wrapperClass.getConstructor(type).newInstance(instance));
            &#125;
        &#125;
        // 对扩展点进行初始化操作
        initExtension(instance);
        return instance;
    &#125; catch (Throwable t) &#123;
        throw new IllegalStateException("Extension instance (name: " + name + ",
        class: " +
        type + ") couldn't be instantiated: " + t.getMessage(), t);
    &#125;
&#125;</code></pre></div>
</li>
<li><p>injectExtension 方法观察,检查类中的方法扩展点…</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">injectExtension</span><span class="hljs-params">(T instance)</span> </span>&#123;
    <span class="hljs-keyword">if</span> (objectFactory <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">return</span> instance;
    &#125;
    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 遍历其中的所有方法</span>
        <span class="hljs-keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;
            <span class="hljs-comment">// 是否是set方法</span>
            <span class="hljs-comment">// 1. 以"set"开头</span>
            <span class="hljs-comment">// 2. 参数长度为1</span>
            <span class="hljs-comment">// 3. 是公开的方法</span>
            <span class="hljs-keyword">if</span> (!isSetter(method)) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-comment">/**
            * Check &#123;<span class="hljs-doctag">@link</span> DisableInject&#125; to see if we need auto injection for
            this property
            */</span>
            <span class="hljs-comment">// 如果设置了取消注册，则不进行处理</span>
            <span class="hljs-keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-comment">// 获取参数类型，并且非基础类型(String, Integer等类型)</span>
            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];
            <span class="hljs-keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;
                <span class="hljs-keyword">continue</span>;
            &#125;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 获取需要set的扩展点名称</span>
                String property = getSetterProperty(method);
                <span class="hljs-comment">// 从ExtensionLoader中加载指定的扩展点</span>
                <span class="hljs-comment">// 比如有一个方法为setRandom(LoadBalance loadBalance)，那么则以为着需</span>
                要加载负载均衡中名为random的扩展点
                Object object = objectFactory.getExtension(pt, property);
                <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span>) &#123;
                    <span class="hljs-number">4.3</span> Adaptive功能实现原理
                    Adaptive的主要功能是对所有的扩展点进行封装为一个类，通过URL传入参数的时动态选择需要使用的
                    扩展点。其底层的实现原理就是动态代理，这里我们会通过源码的形式告诉大家，他是如何通过动态代
                    理进行加载的。
                    （<span class="hljs-number">1</span>）这里我们getAdaptiveExtension 方法讲起，这个里面就是真正获取该类。这里可以看到，
                    ExtentionLoader 中大量的使用了Holder和加锁的方式去进行唯一创建。
                    method.invoke(instance, object);
                &#125;
            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
                logger.error(<span class="hljs-string">"Failed to inject via method "</span> + method.getName()
                + <span class="hljs-string">" of interface "</span> + type.getName() + <span class="hljs-string">": "</span> +
                e.getMessage(), e);
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;
        logger.error(e.getMessage(), e);
    &#125;
    <span class="hljs-keyword">return</span> instance;
&#125;</code></pre></div>

<ul>
<li>最后完成实例化类</li>
</ul>
<h4 id="4-3-Adaptive功能实现原理"><a href="#4-3-Adaptive功能实现原理" class="headerlink" title="4.3 Adaptive功能实现原理"></a>4.3 Adaptive功能实现原理</h4><p>Adaptive的主要功能是对所有的扩展点进行封装为一个类，通过URL传入参数的时动态选择需要使用的扩展点。其底层的实现原理就是动态代理，这里我们会通过源码的形式告诉大家，他是如何通过动态代理进行加载的。</p>
<p>开始追源码：</p>
<ul>
<li>org.apache.dubbo.common.extension.ExtensionLoader#getAdaptiveExtension这个里面就是真正获取该类。这里可以看到，ExtentionLoader中大量的使用了Holder和加锁的方式去进行唯一创建。</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined">public T getAdaptiveExtension() &#123;
    // 和原先是用相同的方式，进行Holder和加锁的方式来保证只会被创建一次
    Object<span class="hljs-built_in"> instance </span>= cachedAdaptiveInstance.get();
   <span class="hljs-built_in"> if </span>(instance == null) &#123;
        // 如果直接已经有创建并且错误的情况，则直接返回错误信息，防止重复没必要的创建
       <span class="hljs-built_in"> if </span>(createAdaptiveInstanceError != null) &#123;
           <span class="hljs-built_in"> throw </span>new IllegalStateException(<span class="hljs-string">"Failed to create adaptive instance:
            "</span> +
            createAdaptiveInstanceError.toString(),
            createAdaptiveInstanceError);
        &#125;
        synchronized (cachedAdaptiveInstance) &#123;
           <span class="hljs-built_in"> instance </span>= cachedAdaptiveInstance.get();
               <span class="hljs-built_in"> if </span>(instance == null) &#123;
                try &#123;
                    // 这里真实的进行创建操作
                   <span class="hljs-built_in"> instance </span>= createAdaptiveExtension();
                    cachedAdaptiveInstance.set(instance);
                &#125; catch (Throwable t) &#123;
                    createAdaptiveInstanceError = t;
                   <span class="hljs-built_in"> throw </span>new IllegalStateException(<span class="hljs-string">"Failed to create adaptive
                    instance: "</span> + t.toString(), t);
                &#125;
            &#125;
        &#125;
    &#125;
   <span class="hljs-built_in"> return </span>(T) instance;
&#125;</code></pre></div>

<ul>
<li>进入createAdaptiveExtension,主要是进行了一些方法封装。</li>
<li>进入createAdaptiveExtensionClass，主要是进行生成Adaptive的代码，并且<br>进行编译生成class。</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;
    <span class="hljs-comment">// 实例化一个新的Adaptive的代码生成器，并且进行代码生成</span>
    String code = <span class="hljs-keyword">new</span> AdaptiveClassCodeGenerator(type,cachedDefaultName).generate();
    <span class="hljs-comment">// 获取类加载器</span>
    ClassLoader classLoader = findClassLoader();
    <span class="hljs-comment">// 通过扩展点，寻找编译器, 目前有Java自带的编译器和Javassist的编译器，这里不做细展开</span>
    org.apache.dubbo.<span class="hljs-keyword">common</span>.compiler.Compiler compiler =
    ExtensionLoader.getExtensionLoader(org.apache.dubbo.<span class="hljs-keyword">common</span>.compiler.Compiler.cla
    ss).getAdaptiveExtension();
    <span class="hljs-comment">// 编译并且生成class</span>
    <span class="hljs-keyword">return</span> compiler.compile(code, classLoader);
&#125;</code></pre></div>

<ul>
<li><p>体通过AdaptiveClassLoaderCodeGenerator.generate方法来进行实现真正的代码生成。</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> generate() &#123;
    <span class="hljs-comment">// 如果没有任何方法标记为Adaptive，则不做处理</span>
    <span class="hljs-keyword">if</span> (!hasAdaptiveMethod()) &#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No adaptive method exist on extension "</span>
        + type.getName() + <span class="hljs-string">", refuse to create the adaptive class!"</span>);
    &#125;
    <span class="hljs-comment">// 进行编写代码</span>
    StringBuilder code = <span class="hljs-keyword">new</span> StringBuilder();
    <span class="hljs-comment">// 生成包信息</span>
    code.<span class="hljs-built_in">append</span>(generatePackageInfo());
    <span class="hljs-comment">// 生成引用信息</span>
    code.<span class="hljs-built_in">append</span>(generateImports());
    <span class="hljs-comment">// 生成类声明</span>
    （<span class="hljs-number">5</span>）这里主要对其中的每一个方法来做处理。具体主要观看generateMethod 方法。这里的很多方法
    主要是依赖反射机制去进行方法封装，最终拼接为一个最终字符串。其中最关键的方法在于
    generateMethodContent 方法来生成代理功能。
    （<span class="hljs-number">6</span>） generateMethodContent 方法解读。这块儿更推荐通过debug的形式走进来, 看代码也更直接了
    当(就可以直接按照常用功能中的SPI章节来debug)。这部分也是整个Adaptive中最为核心的代码，包括
    获取扩展点名称并且执行。
    code.<span class="hljs-built_in">append</span>(generateClassDeclaration());
    <span class="hljs-comment">// 生成每一个方法</span>
    Method[] methods = type.getMethods();
    <span class="hljs-keyword">for</span> (Method method : methods) &#123;
        code.<span class="hljs-built_in">append</span>(generateMethod(method));
    &#125;
    <span class="hljs-comment">// 输出最后的一个"&#125;"来结束当前类</span>
    code.<span class="hljs-built_in">append</span>(<span class="hljs-string">"&#125;"</span>);
    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;
        logger.debug(code.toString());
    &#125;
    <span class="hljs-keyword">return</span> code.toString();
&#125;</code></pre></div>
</li>
<li><p>具体主要观看generateMethod 方法。这里的很多方法<br>主要是依赖反射机制去进行方法封装，最终拼接为一个最终字符串。其中最关键的方法在于generateMethodContent 方法来生成代理功能。</p>
</li>
<li><p>generateMethodContent 整个Adaptive中最为核心的代码,拼接需要的部分类字符串，如下</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (arg0 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);
org.apache.dubbo.common.URL <span class="hljs-built_in">url</span> = arg0;
<span class="hljs-built_in">String</span> extName = <span class="hljs-built_in">url</span>.getParameter(<span class="hljs-string">"hello.service"</span>, <span class="hljs-string">"human"</span>);
<span class="hljs-keyword">if</span>(extName == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to get extension (com.lagou.service.HelloService) name from url ("</span> + <span class="hljs-built_in">url</span>.toString() + <span class="hljs-string">") use keys([hello.service])"</span>);
com.lagou.service.HelloService extension = (com.lagou.service.HelloService)ExtensionLoader.getExtensionLoader(com.lagou.service.HelloService.class).getExtension(extName);
<span class="hljs-keyword">return</span> extension.sayHello(arg0);</code></pre></div>

<p><strong>总结：Adaptive功能实现原理就是把带有@Adaptive请求的接口转化字符串重新生产dubbo所需要的类字符串，使用ExtensionLoader#compile去编译生成最终目的是去extension执行 url所需要的实现类。</strong></p>
<h3 id="5-集群容错源码剖析"><a href="#5-集群容错源码剖析" class="headerlink" title="5. 集群容错源码剖析"></a>5. 集群容错源码剖析</h3><p>集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735787a133e2995?w=1454&h=724&f=png&s=690153" srcset="/img/loading.gif" alt></p>
<p>集群工作过程可分为两个阶段：</p>
<ul>
<li>第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。</li>
<li>第二个阶段是在服务消费者进行远程调用<br>时。以 FailoverClusterInvoker 为例，<ul>
<li>该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举<br>Invoker 列表可感知注册中心配置的变化。每次变化后，RegistryDirectory 会动态增删Invoker。</li>
<li>调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker</li>
<li>FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列<br>表中选择一个 Invoker。</li>
<li>最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker<br>实例的 invoke 方法，进行真正的远程调用。</li>
</ul>
</li>
</ul>
<p>Dubbo 主要提供了这样几种容错方式：</p>
<ul>
<li>Failover Cluster - 失败自动切换 失败时会重试其它服务器</li>
<li>Failfast Cluster - 快速失败 请求失败后快速返回异常结果 不重试</li>
<li>Failsafe Cluster - 失败安全 出现异常 直接忽略 会对请求做负载均衡</li>
<li>Failback Cluster - 失败自动恢复 请求失败后 会自动记录请求到失败队列中</li>
<li>Forking Cluster - 并行调用多个服务提供者 其中有一个返回 则立即返回结果</li>
</ul>
<h4 id="5-1-信息缓存接口Directory"><a href="#5-1-信息缓存接口Directory" class="headerlink" title="5.1 信息缓存接口Directory"></a>5.1 信息缓存接口Directory</h4><p>Directory是Dubbo中的一个接口，主要用于缓存当前可以被调用的提供者列表信息。我们在消费者进<br>行调用时都会通过这个接口来获取所有的提供者列表，再进行后续处理。</p>
<p>源码追踪：</p>
<ul>
<li>Directory 接口，通过Directory 来找到指定服务中的提<br>供者信息列表。</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Directory</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>&#123;
    <span class="hljs-comment">// 获取服务的类型,也就是我们demo中所使用的HelloService</span>
    <span class="hljs-function">Class&lt;T&gt; <span class="hljs-title">getInterface</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">// 根据本次调用的信息来获取所有可以被执行的提供者信息</span>
    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="hljs-keyword">throws</span> RpcException;
    <span class="hljs-comment">// 获取所有的提供者信息</span>
    List&lt;Invoker&lt;T&gt;&gt; getAllInvokers();
&#125;</code></pre></div>

<ul>
<li>Directory实现类 -&gt; AbstractDirectory中的list#doList,依靠routerChain去决定真实返回的提供者列表。</li>
<li>到org/apache/dubbo/rpc/cluster/RouterChain.java#route，追到这里，发现invokers，我们先要去知道invoker 列表是从哪里生成获取的</li>
<li>根据开始调用链路图，发现 RegistryProtocol#refer#doRefer是Invoker 生成的部分关键代码。</li>
<li>url 绑定directory，cluster.join(directory) 加入到集群，生产Invoker，如下：</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doRefer</span><span class="hljs-params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;
        <span class="hljs-comment">// 实例化Directory</span>
        RegistryDirectory&lt;T&gt; directory = <span class="hljs-keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);
        <span class="hljs-comment">// 设置注册中心和所使用的协议</span>
        directory.setRegistry(registry);
        directory.setProtocol(protocol);
        <span class="hljs-comment">// all attributes of REFER_KEY</span>
        <span class="hljs-comment">//生成监听路径URL</span>
        Map&lt;String, String&gt; parameters = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());
        URL subscribeUrl = <span class="hljs-keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="hljs-number">0</span>, type.getName(), parameters);
        <span class="hljs-keyword">if</span> (directory.isShouldRegister()) &#123;
            <span class="hljs-comment">// 在Directory中设置监听的consumerurl地址</span>
            directory.setRegisteredConsumerUrl(subscribeUrl);
            <span class="hljs-comment">// 在注册中心中注册消费者URL</span>
            <span class="hljs-comment">// 也就是我们之前的Zookeeper的node中看到的consumer://</span>
            registry.register(directory.getRegisteredConsumerUrl());
        &#125;
        <span class="hljs-comment">// 构建路由链</span>
        directory.buildRouterChain(subscribeUrl);
        <span class="hljs-comment">// 进行监听所有的的provider</span>
        directory.subscribe(toSubscribeUrl(subscribeUrl));
        <span class="hljs-comment">// 加入到集群中</span>
        Invoker&lt;T&gt; invoker = cluster.join(directory);
        List&lt;RegistryProtocolListener&gt; listeners = findRegistryProtocolListeners(url);
        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(listeners)) &#123;
            <span class="hljs-keyword">return</span> invoker;
        &#125;

        RegistryInvokerWrapper&lt;T&gt; registryInvokerWrapper = <span class="hljs-keyword">new</span> RegistryInvokerWrapper&lt;&gt;(directory, cluster, invoker, subscribeUrl);

        <span class="hljs-keyword">for</span> (RegistryProtocolListener listener : listeners) &#123;
            listener.onRefer(<span class="hljs-keyword">this</span>, registryInvokerWrapper);
        &#125;
        <span class="hljs-keyword">return</span> registryInvokerWrapper;
    &#125;</code></pre></div>

<ul>
<li>回到RouterChain#route方法。这里所做的就是依次遍历所有的路由，然后分别执行并返回。这也就是整体的路由规则的实现。</li>
</ul>
<h4 id="5-2-路由规则实现原理"><a href="#5-2-路由规则实现原理" class="headerlink" title="5.2 路由规则实现原理"></a>5.2 路由规则实现原理</h4><ul>
<li>通过 org.apache.dubbo.rpc.cluster.router.condition.ConditionRouter#route 去map中判断是url是否在其中，如果不存在任何invoker则直接返回，有则加入到list</li>
<li>生成整个路由规则，ConditionRouter#init，解析根据”=&gt;”来判断when或者then条件，符合条件的加入到values列表中</li>
</ul>
<h4 id="5-3-Cluster组件"><a href="#5-3-Cluster组件" class="headerlink" title="5.3 Cluster组件"></a>5.3 Cluster组件</h4><p>主要用于代理真正的Invoker执行时做处理，提供了多种容错方案。源码追：</p>
<ul>
<li><p>接口</p>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 默认使用failover作为实现</span>
<span class="hljs-meta">@SPI</span>(FailoverCluster.NAME)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cluster</span> </span>&#123;
    <span class="hljs-comment">// 生成一个新的invoker</span>
    <span class="hljs-meta">@Adaptive</span>
    &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">join</span><span class="hljs-params">(Directory&lt;T&gt; directory)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&#125;</code></pre></div>
</li>
<li><p>failover 只是进行new了一个新的Invoker。</p>
</li>
<li><p>AbstractClusterInvoker.invoke</p>
</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;
    <span class="hljs-comment">// 检查是否已经关闭了</span>
    checkWhetherDestroyed();
    <span class="hljs-comment">// 拷贝当前RPCContext中的附加信息到当前的invocation中</span>
    Map&lt;String, String&gt; contextAttachments =
    RpcContext.getContext().getAttachments();
    <span class="hljs-keyword">if</span> (contextAttachments != <span class="hljs-keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="hljs-number">0</span>) &#123;
        ((RpcInvocation) invocation).addAttachments(contextAttachments);
    &#125;
    <span class="hljs-comment">// 找寻出所有支持的invoker，已经路由过的</span>
    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);
    <span class="hljs-comment">// 初始化负载均衡器</span>
    LoadBalance loadbalance = initLoadBalance(invokers, invocation);
    <span class="hljs-comment">// 用于适配异步请求使用</span>
    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);
    <span class="hljs-comment">// 交给子类进行真正处理请求</span>
    <span class="hljs-keyword">return</span> doInvoke(invocation, invokers, loadbalance);
&#125;</code></pre></div>

<ul>
<li>FailoverClusterInvoker#doInvoke,获取这个方法最大的重试次数,通过for循环的形式表示可以重试的次数,选择具体的invoker(交给负载均衡),最终实现 invoke代理执行。</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, <span class="hljs-keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;
        <span class="hljs-comment">// 如果没有任何的invoker则抛出异常</span>
        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;
        checkInvokers(copyInvokers, invocation);

        <span class="hljs-comment">// 获取这个方法最大的重试次数</span>
        String methodName = RpcUtils.getMethodName(invocation);
        <span class="hljs-keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;
            len = <span class="hljs-number">1</span>;
        &#125;

        <span class="hljs-comment">// 通过for循环的形式表示可以重试的次数</span>
        RpcException le = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// last exception.</span>
        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="hljs-keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="hljs-comment">// invoked invokers.</span>
        Set&lt;String&gt; providers = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(len);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;
            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;
                <span class="hljs-comment">// 每次都执行一次是否关闭当前consumer的判断</span>
                checkWhetherDestroyed();
                <span class="hljs-comment">// 重新获取一遍invoker列表</span>
                copyInvokers = list(invocation);
                <span class="hljs-comment">// 再次进行一次存在invoker的检查</span>
                checkInvokers(copyInvokers, invocation);
            &#125;

            <span class="hljs-comment">// 选择具体的invoker(交给负载均衡)</span>
            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);

            <span class="hljs-comment">// 增加到已经执行过得invoker列表中</span>
            invoked.add(invoker);
            RpcContext.getContext().setInvokers((List) invoked);
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-comment">// 让其真正的去进行执行操作</span>
                Result result = invoker.invoke(invocation);
                <span class="hljs-keyword">if</span> (le != <span class="hljs-keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;
                    logger.warn(<span class="hljs-string">"Although retry the method "</span> + methodName
                            + <span class="hljs-string">" in the service "</span> + getInterface().getName()
                            + <span class="hljs-string">" was successful by the provider "</span> + invoker.getUrl().getAddress()
                            + <span class="hljs-string">", but there have been failed providers "</span> + providers
                            + <span class="hljs-string">" ("</span> + providers.size() + <span class="hljs-string">"/"</span> + copyInvokers.size()
                            + <span class="hljs-string">") from the registry "</span> + directory.getUrl().getAddress()
                            + <span class="hljs-string">" on the consumer "</span> + NetUtils.getLocalHost()
                            + <span class="hljs-string">" using the dubbo version "</span> + Version.getVersion() + <span class="hljs-string">". Last error is: "</span>
                            + le.getMessage(), le);
                &#125;
                <span class="hljs-keyword">return</span> result;
            &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;
                <span class="hljs-comment">// 如果是业务异常则直接抛出</span>
                <span class="hljs-keyword">if</span> (e.isBiz()) &#123;
                    <span class="hljs-keyword">throw</span> e;
                &#125;
                le = e;
            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;
                le = <span class="hljs-keyword">new</span> RpcException(e.getMessage(), e);
            &#125; <span class="hljs-keyword">finally</span> &#123;
                providers.add(invoker.getUrl().getAddress());
            &#125;
        &#125;

        <span class="hljs-comment">// 如果重试了指定次数后依旧失败，则直接认定为失败</span>
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(le.getCode(), <span class="hljs-string">"Failed to invoke the method "</span>
                + methodName + <span class="hljs-string">" in the service "</span> + getInterface().getName()
                + <span class="hljs-string">". Tried "</span> + len + <span class="hljs-string">" times of the providers "</span> + providers
                + <span class="hljs-string">" ("</span> + providers.size() + <span class="hljs-string">"/"</span> + copyInvokers.size()
                + <span class="hljs-string">") from the registry "</span> + directory.getUrl().getAddress()
                + <span class="hljs-string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="hljs-string">" using the dubbo version "</span>
                + Version.getVersion() + <span class="hljs-string">". Last error is: "</span>
                + le.getMessage(), le.getCause() != <span class="hljs-keyword">null</span> ? le.getCause() : le);
    &#125;</code></pre></div>

<h4 id="5-4-负载均衡实现原理"><a href="#5-4-负载均衡实现原理" class="headerlink" title="5.4 负载均衡实现原理"></a>5.4 负载均衡实现原理</h4><p>过程比较简单就是选择具体负载均衡策略实现类，可以关注下策略算法：</p>
<ul>
<li>LoadBalance接口定义。这里默认选择了随机算法。</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 默认使用随机算法</span>
<span class="hljs-meta">@SPI</span>(RandomLoadBalance.NAME)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalance</span> </span>&#123;
    <span class="hljs-comment">// 进行选择真正的invoker</span>
    <span class="hljs-meta">@Adaptive</span>(<span class="hljs-string">"loadbalance"</span>)
    &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation
    invocation)</span> <span class="hljs-keyword">throws</span> RpcException</span>;
&#125;</code></pre></div>

<ul>
<li>LoadBalance 依旧选择了AbstractLoadBalance 作为基础的实现类。select 最终交给子类默认实现doSelect方法去执行。</li>
<li>默认算法走起：</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;
        <span class="hljs-comment">// 总计的invoker列表数量</span>
        <span class="hljs-keyword">int</span> length = invokers.size();
        <span class="hljs-comment">// 默认每个invoker的权重都是相同的</span>
        <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;
        <span class="hljs-comment">// 所有的权重列表</span>
        <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];
        <span class="hljs-comment">// 首个invoker的权重信息</span>
        <span class="hljs-keyword">int</span> firstWeight = getWeight(invokers.get(<span class="hljs-number">0</span>), invocation);
        weights[<span class="hljs-number">0</span>] = firstWeight;
        <span class="hljs-comment">// 计算总共的权重，并且吧每一个invoker的权重进行设置到列表中</span>
        <span class="hljs-keyword">int</span> totalWeight = firstWeight;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;
            <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);
            <span class="hljs-comment">// save for later use</span>
            weights[i] = weight;
            <span class="hljs-comment">// Sum</span>
            totalWeight += weight;
            <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;
                sameWeight = <span class="hljs-keyword">false</span>;
            &#125;
        &#125;
        <span class="hljs-comment">// 如果权重不相同    10   30   50   100</span>
        <span class="hljs-keyword">if</span> (totalWeight &gt; <span class="hljs-number">0</span> &amp;&amp; !sameWeight) &#123;
            <span class="hljs-comment">// 通过总共的权重来随机分配</span>
            <span class="hljs-keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);
            <span class="hljs-comment">// 看看最终落到哪一个机器上去</span>
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;
                offset -= weights[i];
                <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;
                    <span class="hljs-keyword">return</span> invokers.get(i);
                &#125;
            &#125;
        &#125;
        <span class="hljs-comment">// 如果权重都是相同的话，则随机选取一个即可</span>
        <span class="hljs-keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));
    &#125;</code></pre></div>

<h4 id="5-5-Invoker执行逻辑"><a href="#5-5-Invoker执行逻辑" class="headerlink" title="5.5 Invoker执行逻辑"></a>5.5 Invoker执行逻辑</h4><p>Invoker就是我们真实执行请求的组件。这里也会衍生出我们真正的Dubbo 或者Grpc 等其他协议的请求。</p>
<ul>
<li>找到Invoker接口</li>
<li>查看实现类org.apache.dubbo.rpc.protocol.AbstractInvoker#invoke主要做的<br>是基础信息封装，并且将请求真正的子类。</li>
<li>来到 org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker#doInvoke </li>
<li>来到 org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel#send</li>
<li>最终选择Netty 的channel 实现</li>
</ul>
<h3 id="6-网络通信原理剖析"><a href="#6-网络通信原理剖析" class="headerlink" title="6. 网络通信原理剖析"></a>6. 网络通信原理剖析</h3><p>dubbo协议采用固定长度的消息头（16字节）和不定长度的消息体来进行数据传输，消息头定义了底层框架（netty）在IO线程处理时需要的信息，协议的报文格式如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735848d5bc97ab4?w=1896&h=1300&f=png&s=1040013" srcset="/img/loading.gif" alt></p>
<h4 id="6-1-数据包结构"><a href="#6-1-数据包结构" class="headerlink" title="6.1 数据包结构"></a>6.1 数据包结构</h4><p>协议详情:</p>
<ul>
<li>Magic - Magic High &amp; Magic Low (16 bits)<br>标识协议版本号，Dubbo 协议：0xdabb</li>
<li>Serialization ID (5 bit)<br>标识序列化类型：比如 fastjson 的值为6。</li>
<li>Event (1 bit)<br>标识是否是事件消息，例如，心跳事件。如果这是一个事件，则设置为1。</li>
<li>Two Way (1 bit)<br>仅在 Req/Res 为1（请求）时才有用，标记是否期望从服务器返回值。如果需要来自服务器的返回值，则设置为1。</li>
<li>Req/Res (1 bit)<br>标识是请求或响应。请求： 1; 响应： 0。</li>
<li>Status (8 bits)<br>仅在 Req/Res 为0（响应）时有用，用于标识响应的状态。<ul>
<li>20 - OK</li>
<li>30 - CLIENT_TIMEOUT</li>
<li>31 - SERVER_TIMEOUT</li>
<li>40 - BAD_REQUEST</li>
<li>50 - BAD_RESPONSE</li>
<li>60 - SERVICE_NOT_FOUND</li>
<li>70 - SERVICE_ERROR</li>
<li>80 - SERVER_ERROR</li>
<li>90 - CLIENT_ERROR</li>
<li>100 - SERVER_THREADPOOL_EXHAUSTED_ERROR</li>
</ul>
</li>
<li>Request ID (64 bits) 标识唯一请求。类型为long。</li>
<li>Data Length (32 bits) 序列化后的内容长度（可变部分），按字节计数。int类型。</li>
<li>Variable Part 被特定的序列化类型（由序列化ID标识）序列化后，每个部分都是一个 byte [] 或者 byte <ul>
<li>如果是请求包 ( Req/Res = 1)，则每个部分依次为：<ul>
<li>Dubbo version</li>
<li>Service name</li>
<li>Service version</li>
<li>Method name</li>
<li>Method parameter types</li>
<li>Method arguments</li>
<li>Attachments</li>
</ul>
</li>
<li>如果是响应包（Req/Res = 0）则每个部分依次为：<ul>
<li>返回值类型(byte)，标识从服务器端返回的值类型：</li>
<li>返回空值：RESPONSE_NULL_VALUE 2</li>
<li>正常响应值： RESPONSE_VALUE 1</li>
<li>异常：RESPONSE_WITH_EXCEPTION 0</li>
<li>返回值：从服务端返回的响应bytes</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="hljs"><pre><code class="hljs !">注意：对于(Variable Part)变长部分，当前版本的Dubbo 框架使用json序列化时，在每部分内容间
额外增加了换行符作为分隔，请在Variable Part的每个part后额外增加换行符， 如
： Dubbo version bytes (换行符) Service name bytes (换行符)</code></pre></div>

<p><strong>优点：</strong></p>
<ul>
<li>协议设计上很紧凑，能用 1 个 bit 表示的，不会用一个 byte 来表示，比如 boolean 类型的标识。</li>
<li>请求、响应的 header一致，通过序列化器对content组装特定的内容，代码实现起来简单。</li>
</ul>
<p><strong>可以改进的点 :</strong></p>
<ul>
<li><p>类似于 http 请求，通过 header 就可以确定要访问的资源，而 Dubbo 需要涉及到用特定序列化协议才可以将服务名、方法、方法签名解析出来，并且这些资源定位符是 string 类型或者 string数组，很容易转成 bytes，因此可以组装到 header 中。类似于 http2的header压缩，对于rpc调用的资源也可以协商出来一个int来标识，从而提升性能，如果在header 上组装资源定位符的话，该功能则更易实现。</p>
</li>
<li><p>通过 req/res 是否是请求后，可以精细定制协议，去掉一些不需要的标识和添加一些特定的标识。<br>比如status , twoWay 标识可以严格定制，去掉冗余标识。还有超时时间是作为 Dubbo 的attachment 进行传输的，理论上应该放到请求协议的header中，因为超时是网络请求中必不可少的。提到 attachment ，通过实现可以看到 attachment 中有一些是跟协议 content 中已有的字段是重复的，比如 path 和version等字段，这些会增大协议尺寸。</p>
</li>
<li><p>Dubbo 会将服务名<br>com.alibaba.middleware.hsf.guide.api.param.ModifyOrderPriceParam ，转换为Lcom/alibaba/middleware/hsf/guide/api/param/ModifyOrderPriceParam; ，理论上是不必要的，最后追加一个; 即可。</p>
</li>
<li><p>Dubbo 协议没有预留扩展字段，没法新增标识，扩展性不太好，比如新增响应上下文的功能，只有改协议版本号的方式，但是这样要求客户端和服务端的版本都进行升级，对于分布式场景很不友好。</p>
</li>
</ul>
<h4 id="6-2-数据协议ExchangeCodec详解"><a href="#6-2-数据协议ExchangeCodec详解" class="headerlink" title="6.2 数据协议ExchangeCodec详解"></a>6.2 数据协议ExchangeCodec详解</h4><p>ExchangeCodec 类，这个也是Dubbo在进行数据传输中的数据协议类。</p>
<ul>
<li>常量定义</li>
</ul>
<div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// header length.</span>
<span class="hljs-comment">// 请求头的长度</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEADER_LENGTH = <span class="hljs-number">16</span>;
<span class="hljs-comment">// magic header.</span>
<span class="hljs-comment">// 标示为0-15位  魔数</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">short</span> MAGIC = (<span class="hljs-keyword">short</span>) <span class="hljs-number">0xdabb</span>;
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class="hljs-number">0</span>];
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class="hljs-number">1</span>];
<span class="hljs-comment">// message flag.</span>
<span class="hljs-comment">// 消息中的标示</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_REQUEST = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x80</span>;
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_TWOWAY = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x40</span>;
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_EVENT = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x20</span>;
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERIALIZATION_MASK = <span class="hljs-number">0x1f</span>;</code></pre></div>

<ul>
<li>这个类中encode 和decode 分别用于将数据发送到ByteBuffer 中，还有就是将其反向的转换为对象。encode中的Request就是我们之前所讲的Request对象。</li>
</ul>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// 处理请求对象</span>
    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Request) &#123;
        encodeRequest(channel, buffer, (Request) msg);
    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Response) &#123;
        <span class="hljs-comment">// 处理响应</span>
        encodeResponse(channel, buffer, (Response) msg);
    &#125; <span class="hljs-keyword">else</span> &#123;
        <span class="hljs-comment">// 其他的交给上级处理，用于telnet模式</span>
        <span class="hljs-keyword">super</span>.encode(channel, buffer, msg);
    &#125;
&#125;

<span class="hljs-meta">@Override</span>
 <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// 可读字节数</span>
    <span class="hljs-keyword">int</span> readable = buffer.readableBytes();
    <span class="hljs-comment">// 选取可读字节数 和  HEADER_LENGTH 中小的</span>
    <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];
    buffer.readBytes(header);
    <span class="hljs-keyword">return</span> decode(channel, buffer, readable, header);
&#125;</code></pre></div>

<ul>
<li>encodeRequest 方法。这里也验证了我们之前所讲的header内容</li>
</ul>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequest</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// 请求的序列化类型</span>
    Serialization serialization = getSerialization(channel);
    <span class="hljs-comment">// header.   // 写入header信息</span>
    <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];
    <span class="hljs-comment">// set magic number. 设置魔数</span>
    Bytes.short2bytes(MAGIC, header);

    <span class="hljs-comment">// set request and serialization flag.   // 标记为请求</span>
    header[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());
    <span class="hljs-comment">// 是否是单向还是双向的(异步)</span>
    <span class="hljs-keyword">if</span> (req.isTwoWay()) &#123;
        header[<span class="hljs-number">2</span>] |= FLAG_TWOWAY;
    &#125;
    <span class="hljs-comment">// 是否为事件(心跳)</span>
    <span class="hljs-keyword">if</span> (req.isEvent()) &#123;
        header[<span class="hljs-number">2</span>] |= FLAG_EVENT;
    &#125;

    <span class="hljs-comment">// set request id.</span>
    <span class="hljs-comment">// 写入当前的请求ID</span>
    Bytes.long2bytes(req.getId(), header, <span class="hljs-number">4</span>);

    <span class="hljs-comment">// encode request data.</span>
    <span class="hljs-comment">// 保存当前写入的位置，将其写入的位置往后面偏移,保留出写入内容大小的位置，先进行写入body内容</span>
    <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();
    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
    ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);
    ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
    <span class="hljs-comment">// 按照数据内容的不同，来写入不同的内容</span>
    <span class="hljs-keyword">if</span> (req.isEvent()) &#123;
        encodeEventData(channel, out, req.getData());
    &#125; <span class="hljs-keyword">else</span> &#123;
        encodeRequestData(channel, out, req.getData(), req.getVersion());
    &#125;
    out.flushBuffer();
    <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) &#123;
        ((Cleanable) out).cleanup();
    &#125;
    bos.flush();
    bos.close();
    <span class="hljs-comment">// 记录body中写入的长度</span>
    <span class="hljs-keyword">int</span> len = bos.writtenBytes();
    checkPayload(channel, len);
    <span class="hljs-comment">// 将其写入到header中的位置中</span>
    Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);

    <span class="hljs-comment">// write   // 发送到buffer中</span>
    buffer.writerIndex(savedWriteIndex);
    buffer.writeBytes(header); <span class="hljs-comment">// write header.</span>
    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
&#125;</code></pre></div>

<ul>
<li>org.apache.dubbo.remoting.exchange.codec.ExchangeCodec#encodeRequestData,在子类DubboCodec 中</li>
</ul>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequestData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    RpcInvocation inv = (RpcInvocation) data;

    <span class="hljs-comment">// 写入版本</span>
    out.writeUTF(version);
    <span class="hljs-comment">// 接口全名称</span>
    out.writeUTF(inv.getAttachment(PATH_KEY));
    <span class="hljs-comment">// 接口版本号</span>
    out.writeUTF(inv.getAttachment(VERSION_KEY));
    <span class="hljs-comment">// 写入方法名称</span>
    out.writeUTF(inv.getMethodName());
    <span class="hljs-comment">// 调用参数描述信息</span>
    out.writeUTF(inv.getParameterTypesDesc());
    <span class="hljs-comment">// 所有的请求参数写入</span>
    Object[] args = inv.getArguments();
    <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;
            out.writeObject(encodeInvocationArgument(channel, inv, i));
        &#125;
    &#125;
    <span class="hljs-comment">// 写入所有的附加信息</span>
    out.writeAttachments(inv.getObjectAttachments());
&#125;</code></pre></div>

<ul>
<li>再看encodeResponse 方法实现。一样的，这里可以看到和写入request相似。</li>
</ul>
<div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeResponse</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();
    <span class="hljs-keyword">try</span> &#123;
        Serialization serialization = getSerialization(channel);

        <span class="hljs-comment">// 和之前的参数一致</span>
        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];
        Bytes.short2bytes(MAGIC, header);
        header[<span class="hljs-number">2</span>] = serialization.getContentTypeId();
        <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;
            header[<span class="hljs-number">2</span>] |= FLAG_EVENT;
        &#125;

        <span class="hljs-comment">// 写入状态码</span>
        <span class="hljs-keyword">byte</span> status = res.getStatus();
        header[<span class="hljs-number">3</span>] = status;

        <span class="hljs-comment">// 写入内容</span>
        Bytes.long2bytes(res.getId(), header, <span class="hljs-number">4</span>);

        <span class="hljs-comment">// 和Request一样的内容写入方式，先写入内容，再写入长度</span>
        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
        ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);
        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
        <span class="hljs-comment">// encode response data or error message.</span>
        <span class="hljs-keyword">if</span> (status  == Response.OK) &#123;
            <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;
                encodeEventData(channel, out, res.getResult());
            &#125; <span class="hljs-keyword">else</span> &#123;
                encodeResponseData(channel, out, res.getResult(), res.getVersion());
            &#125;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-comment">// 这里不太一样的地方在于，如果错误的时候，则直接将错误信息写入，不需要再交由序列化</span>
            out.writeUTF(res.getErrorMessage());
        &#125;
        out.flushBuffer();
        <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) &#123;
            ((Cleanable) out).cleanup();
        &#125;
        bos.flush();
        bos.close();

        <span class="hljs-comment">// 一样的写入模式</span>
        <span class="hljs-keyword">int</span> len = bos.writtenBytes();
        checkPayload(channel, len);
        Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);
        buffer.writerIndex(savedWriteIndex);
        buffer.writeBytes(header); <span class="hljs-comment">// write header.</span>
        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        <span class="hljs-comment">// 写入出现异常</span>
        buffer.writerIndex(savedWriteIndex);
        <span class="hljs-comment">// send error message to Consumer, otherwise, Consumer will wait till timeout.</span>
        <span class="hljs-keyword">if</span> (!res.isEvent() &amp;&amp; res.getStatus() != Response.BAD_RESPONSE) &#123;
            Response r = <span class="hljs-keyword">new</span> Response(res.getId(), res.getVersion());
            r.setStatus(Response.BAD_RESPONSE);

            <span class="hljs-comment">// 如果是超过内容长度则重新设置内容大小并写入</span>
            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ExceedPayloadLimitException) &#123;
                logger.warn(t.getMessage(), t);
                <span class="hljs-keyword">try</span> &#123;
                    r.setErrorMessage(t.getMessage());
                    channel.send(r);
                    <span class="hljs-keyword">return</span>;
                &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;
                    logger.warn(<span class="hljs-string">"Failed to send bad_response info back: "</span> + t.getMessage() + <span class="hljs-string">", cause: "</span> + e.getMessage(), e);
                &#125;
            &#125;
        &#125;
        <span class="hljs-comment">// Rethrow exception</span>
        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> IOException) &#123;
            <span class="hljs-keyword">throw</span> (IOException) t;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;
            <span class="hljs-keyword">throw</span> (RuntimeException) t;
        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> Error) &#123;
            <span class="hljs-keyword">throw</span> (Error) t;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(t.getMessage(), t);
        &#125;
    &#125;
&#125;</code></pre></div>

<ul>
<li>解码在同样的类中，不做详细介绍了…</li>
</ul>
<h4 id="6-3-处理粘包和拆包问题"><a href="#6-3-处理粘包和拆包问题" class="headerlink" title="6.3 处理粘包和拆包问题"></a>6.3 处理粘包和拆包问题</h4><p><strong>拆包：</strong></p>
<div class="hljs"><pre><code>当发生TCP拆包问题时候 这里假设之前还没有发生过任何数据交互，系统刚刚初始化好，那么这个时候在
InternalDecoder里面的buffer属性会是EMPTY_BUFFER。当发生第一次inbound数据的时候，第一次
在InternalDecoder里面接收的肯定是dubbo消息头的部分（这个由TCP协议保证），由于发生了拆包情
况，那么此时接收的inbound消息可能存在一下几种情况
1、当前inbound消息只包含dubbo协议头的一部分
2、当前inbound消息只包含dubbo的协议头
3、当前inbound消息只包含dubbo消息头和部分payload消息

通过上面的讨论，我们知道发生上面三种情况，都会触发ExchangeCodec返回NEED_MORE_INPUT，由于
在DubboCountCodec对于返回NEED_MORE_INPUT会回滚读索引，所以此时的buffer里面的数据可以当作
并没有发生过读取操作，并且DubboCountCodec的decode也会返回NEED_MORE_INPUT，在
InternalDecoder对于当判断返回NEED_MORE_INPUT，也会进行读索引回滚，并且退出循环，最后会执
行finally内容，这里会判断inbound消息是否还有可读的，由于在DubboCountCodec里面进行了读索引
回滚，所以此时的buffer里面不是完整的inbound消息，等待第二次的inbound消息的到来，当第二次
inbound消息过来的时候，再次经过上面的判断。</code></pre></div><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, <span class="hljs-keyword">int</span> readable, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;
    <span class="hljs-comment">// 检查魔数</span>
    <span class="hljs-keyword">if</span> (readable &gt; <span class="hljs-number">0</span> &amp;&amp; header[<span class="hljs-number">0</span>] != MAGIC_HIGH
            || readable &gt; <span class="hljs-number">1</span> &amp;&amp; header[<span class="hljs-number">1</span>] != MAGIC_LOW) &#123;
        <span class="hljs-keyword">int</span> length = header.length;
        <span class="hljs-keyword">if</span> (header.length &lt; readable) &#123;
            header = Bytes.copyOf(header, readable);
            buffer.readBytes(header, length, readable - length);
        &#125;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; header.length - <span class="hljs-number">1</span>; i++) &#123;
            <span class="hljs-keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="hljs-number">1</span>] == MAGIC_LOW) &#123;
                buffer.readerIndex(buffer.readerIndex() - header.length + i);
                header = Bytes.copyOf(header, i);
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.decode(channel, buffer, readable, header);
    &#125;
    <span class="hljs-comment">// check length. 不完整的包</span>
    <span class="hljs-keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;
        <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;
    &#125;

    <span class="hljs-comment">// 获取数据长度</span>
    <span class="hljs-keyword">int</span> len = Bytes.bytes2int(header, <span class="hljs-number">12</span>);
    checkPayload(channel, len);

    <span class="hljs-keyword">int</span> tt = len + HEADER_LENGTH;
    <span class="hljs-comment">// 需要继续读取</span>
    <span class="hljs-keyword">if</span> (readable &lt; tt) &#123;
        <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;
    &#125;

    <span class="hljs-comment">// limit input stream.</span>
    ChannelBufferInputStream is = <span class="hljs-keyword">new</span> ChannelBufferInputStream(buffer, len);

    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-comment">// 解码数据</span>
        <span class="hljs-keyword">return</span> decodeBody(channel, is, header);
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-keyword">if</span> (is.available() &gt; <span class="hljs-number">0</span>) &#123;
            <span class="hljs-keyword">try</span> &#123;
                <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;
                    logger.warn(<span class="hljs-string">"Skip input stream "</span> + is.available());
                &#125;
                StreamUtils.skipUnusedStream(is);
            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
                logger.warn(e.getMessage(), e);
            &#125;
        &#125;
    &#125;
&#125;</code></pre></div>

<div class="hljs"><pre><code class="hljs !">说明：如果解码返回DecodeResult.NEED_MORE_INPUT，说明信息不完整，需要读索引回滚，并且退出循环，最后会执 行finally内容，这里会判断inbound消息是否还有可读的，由于在DubboCountCodec里面进行了读索引 回滚，所以此时的buffer里面不是完整的inbound消息，等待第二次的inbound消息的到来，当第二次inbound消息过来的时候，再次经过上面的判断，如下代码：</code></pre></div>

<div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;
    <span class="hljs-comment">// decode object.</span>
    <span class="hljs-keyword">do</span> &#123;
        saveReaderIndex = message.readerIndex();
        <span class="hljs-keyword">try</span> &#123;
            msg = codec.decode(channel, message);
        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;
            buffer = org.apache.dubbo.remoting.buffer.ChannelBuffers.EMPTY_BUFFER;
            <span class="hljs-keyword">throw</span> e;
        &#125;
        <span class="hljs-keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123;

            <span class="hljs-comment">// 回滚重读</span>
            message.readerIndex(saveReaderIndex);
            <span class="hljs-keyword">break</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            <span class="hljs-keyword">if</span> (saveReaderIndex == message.readerIndex()) &#123;
                buffer = org.apache.dubbo.remoting.buffer.ChannelBuffers.EMPTY_BUFFER;
                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Decode without read data."</span>);
            &#125;
            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;
                Channels.fireMessageReceived(ctx, msg, event.getRemoteAddress());
            &#125;
        &#125;
    &#125; <span class="hljs-keyword">while</span> (message.readable());
&#125; <span class="hljs-keyword">finally</span> &#123;
    <span class="hljs-comment">// 判断消息是否可读</span>
    <span class="hljs-keyword">if</span> (message.readable()) &#123;
        message.discardReadBytes();
        buffer = message;
    &#125; <span class="hljs-keyword">else</span> &#123;
        buffer = org.apache.dubbo.remoting.buffer.ChannelBuffers.EMPTY_BUFFER;
    &#125;
    NettyChannel.removeChannelIfDisconnected(ctx.getChannel());
&#125;</code></pre></div>

<p>messageReceived的核心就是message.readerIndex(saveReaderIndex) ，回滚重读。最后判断消息是否可读。</p>
<p><strong>粘包：</strong></p>
<div class="hljs"><pre><code>当发生TCP粘包的时候 是tcp将一个dubbo协议栈放在一个tcp包中，那么有可能发生下面几种情况
1、当前inbound消息只包含一个dubbo协议栈
2、当前inbound消息包含一个dubbo协议栈，同时包含部分另一个或者多个dubbo协议栈内容
如果发生只包含一个协议栈，那么当前buffer通过ExchangeCodec解析协议之后，当前的buffer的
readeIndex位置应该是buffer尾部，那么在返回到InternalDecoder中message的方法readable返回
的是false,那么就会对buffer重新赋予EMPTY_BUFFER实体，而针对包含一个以上的dubbo协议栈，当然
也会解析出其中一个dubbo协议栈，但是经过ExchangeCodec解析之后，message的readIndex不在
message尾部，所以message的readable方法返回的是true。那么则会继续遍历message，读取下面的
信息。最终要么message刚好整数倍包含完整的dubbo协议栈，要不ExchangeCodec返回
NEED_MORE_INPUT,最后将未读完的数据缓存到buffer中,等待下次inbound事件，将buffer中的消息合
并到下次的inbound消息中，种类又回到了拆包的问题上。
dubbo在处理tcp的粘包和拆包时是借助InternalDecoder的buffer缓存对象来缓存不完整的dubbo协议
栈数据，等待下次inbound事件，合并进去。</code></pre></div><p>总结 ： </p>
<p>在dubbo中解决TCP拆包和粘包的时候是通过buffer 变量来解决的。</p>
<ul>
<li>发生拆包肯定是接收消息不完整的，通过检查信息完整度返回NEED_MORE_INPUT消息，知道整合完整。</li>
<li>发生粘包也是消息包含一个完整或又同时包含多个dubbo协议内容，循环读取。如果还有不完整的最后解决不完整协议内容会又回到拆包问题上，等待下次inbound事件进行合并。</li>
</ul>
<div class="hljs"><pre><code class="hljs !">TCP拆包粘包问题：</code></pre></div>

<ul>
<li>接收到的是一个报文，它是由发送的两个报文组成的，这样对于应用程序来说就很难处理了（粘包）</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/17/1735a8e319dfac39?w=1314&h=256&f=png&s=28108" srcset="/img/loading.gif" alt></p>
<ul>
<li>还有可能出现上面这样的虽然收到了两个包，但是里面的内容却是互相包含，对于应用来说依然无法解析（拆包）。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2020/7/17/1735a8e80c9385b8?w=1304&h=450&f=png&s=74029" srcset="/img/loading.gif" alt></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Dubbo/">Dubbo</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/07/28/Spring-Cloud-全家桶/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Spring Cloud 全家桶</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/07/09/精细Zookeeper/">
                        <span class="hidden-mobile">精细Zookeeper </span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Dubbo从实战->源码分析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
