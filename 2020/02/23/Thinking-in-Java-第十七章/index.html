

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;dark&#34;>



<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="来啦，老弟，这里是 AKA 190">
  <meta name="author" content="190coder">
  <meta name="keywords" content="Java Php hexo Thinking in Java">
  <title>Thinking in Java 第十七章 - 190呐</title>

  <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css">


  <link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css">
  <link rel="stylesheet" href="/lib/hint/hint.min.css">

  
    
    <link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css">
  

  


<!-- 主题依赖的图标库，不要自行修改 -->
<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css">

<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">

<link rel="stylesheet" href="/css/main.css">

<!-- 自定义样式保持在最底部 -->


  <script src="/js/utils.js"></script>
  <script src="/js/color-schema.js"></script>
</head>


<body>
  <header style="height: 60vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>190coder</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2020-02-23 20:11" pubdate>
      2020年2月23日 晚上
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      61
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Thinking in Java 第十七章</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h1><p>Java容器类库成熟 完备 易用。</p>
<h2 id="17-1-完整的容器分类法"><a href="#17-1-完整的容器分类法" class="headerlink" title="17.1 完整的容器分类法"></a>17.1 完整的容器分类法</h2><p>Java SE5新添加了：</p>
<ul>
<li>Queue接口及其实现PriorityQueue及各种风格的BlockingQueue（多线程）；</li>
<li>ConcurrentMap及其实现的ConcurrentHashMap（多线程）；</li>
<li>CopyOnWriteArrayList和CopyOnWriteArraySet（多线程）；</li>
<li>EnumSet和EnumMap（enum）；</li>
<li>Collection类中的多个便利方法。</li>
</ul>
<h2 id="17-2-填充容器"><a href="#17-2-填充容器" class="headerlink" title="17.2 填充容器"></a>17.2 填充容器</h2><p>Collections.nCopies() 所有引用都被设置为指向相同的对象；例： </p>
<div class="hljs"><pre><code class="hljs undefined">List&lt;StringAddress&gt;  ls = Collections.nCopies(<span class="hljs-number">4</span>, new StringAddress(<span class="hljs-string">"helli"</span>));
<span class="hljs-comment">//output ls</span>
[StringAddress@<span class="hljs-number">82</span>ba41 Hello,StringAddress@<span class="hljs-number">82</span>ba41 Hello,StringAddress@<span class="hljs-number">82</span>ba41 Hello,StringAddress@<span class="hljs-number">82</span>ba41 Hello]</code></pre></div>

<p>Collections.fill() 只能替换已经存在的元素，而不能添加新元素。</p>
<h4 id="17-2-1-一种Generator解决方案"><a href="#17-2-1-一种Generator解决方案" class="headerlink" title="17.2.1 一种Generator解决方案"></a>17.2.1 一种Generator解决方案</h4><p>Collection生成器CollectionData：</p>
<p><strong>所有collection子类都有一个接受另一个Collection对象的构造器，用来填充数据</strong></p>
<p>CollectionData体现了适配器模式的设计思想，它能把实现Generator接口的类的对象(包括上一章数组中的各种RandomGenerator)都复制到自身当中</p>
<p><strong>直接上代码，看完代码在看中文解释会更清晰（tij 的心得，哈哈，上来看简介是真看不懂，再不济可以Google ，只要弄明白他要说的 再回来看解析就会清晰很多）</strong></p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.LinkedHashSet;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    T next();
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionData</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">ArrayList</span></span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long serialVersionUID = <span class="hljs-number">1</span>L;
    <span class="hljs-keyword">public</span> CollectionData(Generator&lt;T&gt; gen, int quantity) &#123;
        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; quantity; i++)
            add(gen.next());
    &#125;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CollectionData&lt;T&gt; list(Generator&lt;T&gt; gen, int quantity) &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">CollectionData</span>&lt;T&gt;(gen, quantity);
    &#125;
&#125;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Generator</span></span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span>[] items = &#123; <span class="hljs-string">"Dog"</span>, <span class="hljs-string">"Pig"</span>, <span class="hljs-string">"Cat"</span> &#125;;
    <span class="hljs-keyword">private</span> int index;
    @Override
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> next() &#123;
        <span class="hljs-keyword">return</span> items[index++];
    &#125;
&#125;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;
        Set&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedHashSet</span>&lt;<span class="hljs-keyword">String</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">CollectionData</span>&lt;<span class="hljs-keyword">String</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>(), <span class="hljs-number">2</span>));
        System.out.println(<span class="hljs-keyword">set</span>); <span class="hljs-comment">// [Dog, Pig, Cat]</span>
        <span class="hljs-keyword">set</span>.addAll(CollectionData.list(<span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>(), <span class="hljs-number">3</span>));
        System.out.println(<span class="hljs-keyword">set</span>); <span class="hljs-comment">// [Dog, Pig, Cat]</span>
    &#125;
&#125;</code></pre></div>

<h4 id="17-2-12-Map生成器"><a href="#17-2-12-Map生成器" class="headerlink" title="17.2.12 Map生成器"></a>17.2.12 Map生成器</h4><p>思想与2.1 相同</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MapData</span><span class="hljs-params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="hljs-keyword">int</span> quantity)</span></span>&#123;
    Pair&lt;K,V&gt; p=gen.next();
    put(p.key,p.vaule);
&#125;</code></pre></div>

<h4 id="17-2-3-使用Abstract类"><a href="#17-2-3-使用Abstract类" class="headerlink" title="17.2.3 使用Abstract类"></a>17.2.3 使用Abstract类</h4><p><strong>享元模式</strong>使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或整体。</p>
<p>书中的代码和解析比较不容易理解和啰嗦。用网上一段例子说明<br>典型的享元工厂类的代码如下：</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;
    <span class="hljs-comment">//定义一个HashMap用于存储享元对象，实现享元池</span>
    <span class="hljs-keyword">private</span> HashMap flyweights = <span class="hljs-keyword">new</span><span class="hljs-type">HashMap</span>();
    <span class="hljs-keyword">public</span> Flyweight getFlyweight(<span class="hljs-keyword">String</span> key)&#123;
        <span class="hljs-comment">//如果对象存在，则直接从享元池获取</span>
        <span class="hljs-keyword">if</span>(flyweights.containsKey(key))&#123;
            <span class="hljs-keyword">return</span>(Flyweight)flyweights.<span class="hljs-keyword">get</span>(key);
        &#125;
        <span class="hljs-comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span>
        <span class="hljs-keyword">else</span> &#123;
            Flyweight fw = <span class="hljs-keyword">new</span><span class="hljs-type">ConcreteFlyweight</span>();
            flyweights.put(key,fw);
            <span class="hljs-keyword">return</span> fw;
        &#125;
    &#125;
&#125;</code></pre></div>

<p>不存在才创建，存在就get出来。</p>
<h2 id="17-3-Collection的功能方法"><a href="#17-3-Collection的功能方法" class="headerlink" title="17.3 Collection的功能方法"></a>17.3 Collection的功能方法</h2><p>主要介绍Collection的主要方法，子类可以拿来即用。</p>
<h2 id="17-4-可选操作"><a href="#17-4-可选操作" class="headerlink" title="17.4 可选操作"></a>17.4 可选操作</h2><p>实现类并不需要为这些方法提供功能定义。简单的说就是 List Map Set 都可以共用 Collection接口的方法，但是 就像 List 不能使用set 一样,虽然编译器不会检查，但是运行会抛出异常。</p>
<h2 id="17-5-List-的功能方法"><a href="#17-5-List-的功能方法" class="headerlink" title="17.5 List 的功能方法"></a>17.5 List 的功能方法</h2><p>常用list方法 iterator 等等。</p>
<h2 id="17-6-Set和存储顺序"><a href="#17-6-Set和存储顺序" class="headerlink" title="17.6 Set和存储顺序"></a>17.6 Set和存储顺序</h2><p>良好的编码风格：应该在覆盖equals()方法时，总是同时覆盖hashCode()方法。</p>
<p>SortedSet</p>
<ol>
<li>Comparator comparator() 返回当前Set中使用的Comparator；或者返回null表示以自然方式排序。</li>
<li>Object first() 返回容器中第一个元素。</li>
<li>Object last() 返回容器中第末一个元素。</li>
<li>SortedSet subSet(fromElement, toElement) 生成此Set的子集，范围从fromElement（包含）到toElement（不包含）。</li>
<li>SortedSet headSet(toElement) 生成此Set的子集，由小于toElement的元素组成。</li>
<li>SortedSet tailSet(fromElement) 生成此Set的子集，由大于或等于formElement的元素组成。</li>
</ol>
<p><strong>SortedSet的意思是按对象比较函数对元素排序，而不是元素插入次序，插入顺序可以用LinkedHashSet保存。</strong><br><a href="https://blog.csdn.net/trbbadboy/article/details/6939598" target="_blank" rel="noopener">https://blog.csdn.net/trbbadboy/article/details/6939598</a><br>贴上简单明了的例子</p>
<h2 id="17-7-队列"><a href="#17-7-队列" class="headerlink" title="17.7 队列"></a>17.7 队列</h2><ol>
<li><p>优先级队列 PriorityQueue  <a href="https://www.jianshu.com/p/c577796e537a" target="_blank" rel="noopener">https://www.jianshu.com/p/c577796e537a</a> 这篇文章讲解到位。<br>Queue指先进先出的队列。Java中Queue为一个接口，集成Collection接口，实现可以为LinkedBlockingQueue,LinkedList,PriorityQueue等。<br>普通队列特点，先进先出。插入队列和移出队列的时间复杂度都为O(1)。<br>优先级队列，不同于普通队列，优先级队列默认按照元素的自然顺序排序（也可以重写comparator接口compare方法进行自定义排序）插入。移出队列和普通队列一样，但插入队列的时间复杂度与元素个数N有关，时间复杂度为O（logN）。</p>
</li>
<li><p>双向队列 Deque<br> 两端放入元素并提取他们，不是特别常用</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deque</span>&lt;T&gt; &#123;</span> 
    <span class="hljs-keyword">private</span> LinkedList&lt;T&gt; <span class="hljs-built_in">deque</span> = <span class="hljs-keyword">new</span> LinkedList&lt;T&gt;(); 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(T e)</span> </span>&#123; <span class="hljs-built_in">deque</span>.addFirst(e); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(T e)</span> </span>&#123; <span class="hljs-built_in">deque</span>.addLast(e); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.getFirst(); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.getLast(); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.removeFirst(); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.removeLast(); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.size(); &#125; 
    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.toString(); &#125; 
    <span class="hljs-comment">// And other methods as necessary... </span>
&#125;</code></pre></div>

</li>
</ol>
<h2 id="17-8-理解Map"><a href="#17-8-理解Map" class="headerlink" title="17.8 理解Map"></a>17.8 理解Map</h2><p>开始的Map 用get 取值 效率最低 因为要从头轮询equals比较key值 ，只是简单并没有效率。</p>
<h4 id="17-8-1-性能"><a href="#17-8-1-性能" class="headerlink" title="17.8.1 性能"></a>17.8.1 性能</h4><p>get()线性搜索，效率低下，HsahMap 因此而生。HsahMap使用了散列码，，hashcode() 是 Object中的方法，因此所有的Java对象都能产生散列码。</p>
<p>Treemap 查询键值对他们会被排序（由Comparable 或者 Comparator决定）。</p>
<h4 id="17-8-2-SortedMap"><a href="#17-8-2-SortedMap" class="headerlink" title="17.8.2 SortedMap"></a>17.8.2 SortedMap</h4><p>使用SortedMap（TreeMap是其现阶段的唯一实现），可以确保键处于排序状态。</p>
<ol>
<li>Comparator comparator() 返回当前Map中使用的Comparator；或者返回null表示以自然方式排序。</li>
<li>T firstKey() 返回Map中的第一个键。</li>
<li>T lastKey() 返回Map中的第末一个键。</li>
<li>SortedMap subMap(fromKey, toKey) 生成此Map的子集，范围从fromKey（包含）到toKey（不包含）的键确定。</li>
<li>SortedMap headMap(toKey) 生成此Map的子集，由小于toKey的键确定的键值对组成。</li>
<li>SortedMap tailMap(fromKey) 生成此Map的子集，由大于或等于fromKey的键确定的键值对组成。</li>
</ol>
<h4 id="17-8-2-LinkedHashMap"><a href="#17-8-2-LinkedHashMap" class="headerlink" title="17.8.2 LinkedHashMap"></a>17.8.2 LinkedHashMap</h4><p>两个特点：</p>
<ol>
<li>为了提高速度，散列化所有元素，，遍历时候又以元素的插入顺序返回键值对，</li>
<li>可以在构造器里第三个参数设置accessOrder true，在我们访问了一个Entry&lt;K,V&gt;时，我们会调用afterNodeAccess()方法，将我们当前访问的节点放入到链表的末尾，利用这个特性便可以区分谁是最近访问，谁是最近最不常访问元素了。boolean removeEldestEntry(Map.Entry)该方法返回值为true时，会删除最近最不常使用的元素，也就是double-link的头部节点，当插入一个新节点之后removeEldestEntry()方法会被put()、putAll()方法调用，我们可以通过override该方法，来控制删除最旧节点的条件。<br>同redis淘汰策略的 <strong>LRU 算法</strong>。没有访问的放在最前面。对于定期清理节省空间或实现LRU缓存以下案例得以实现。</li>
</ol>
<p>简单案例：</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Iterator;
<span class="hljs-keyword">import</span> java.util.LinkedHashMap;
<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.Map.Entry;
<span class="hljs-keyword">import</span> java.util.Set;

<span class="hljs-comment">/*
 * 为最近最少使用（LRU）缓存策略设计一个数据结构，
 * 它应该支持以下操作：获取数据（get）和写入数据（set）。
 * 获取数据get(key)：如果缓存中存在key，则获取其数据值（通常是正数），否则返回-1。
 * 写入数据set(key, value)：如果key还没有在缓存中，则写入其数据值。
 * 当缓存达到上限，它应该在写入新数据之前删除最近最少使用的数据用来腾出空闲位置。 
 *
 */</span>
<span class="hljs-keyword">public</span> class LRUCache&lt;K, V&gt;&#123;
    LinkedHashMap&lt;K,V&gt; cache = <span class="hljs-keyword">null</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> cacheSize;
    <span class="hljs-keyword">public</span> LRUCache(<span class="hljs-built_in">int</span> cacheSize)&#123;
        <span class="hljs-keyword">this</span>.cacheSize = (<span class="hljs-built_in">int</span>) Math.<span class="hljs-built_in">ceil</span> (cacheSize / <span class="hljs-number">0.75</span>f) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// ceil浮点数向上取整数</span>
        cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;K,V&gt;(<span class="hljs-keyword">this</span>.cacheSize,<span class="hljs-number">0.75</span>f,<span class="hljs-keyword">true</span>)&#123;  <span class="hljs-comment">//boolean accessOrder用来控制访问顺序的，默认设置为false，在访问之后，不会将当前访问的元素插入到链表尾部</span>
          <span class="hljs-comment">//内部类来重写removeEldestEntry()方法</span>
        @Override
          <span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> removeEldestEntry (Map.Entry&lt;K, V&gt; eldest)&#123;
              System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"size="</span>+<span class="hljs-built_in">size</span>());
              <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() &gt; cacheSize; <span class="hljs-comment">//当前size()大于了cacheSize便删掉头部的元素</span>
          &#125;
        &#125;;
    &#125;
    
    <span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(K <span class="hljs-built_in">key</span>)&#123;   <span class="hljs-comment">//如果使用继承的话就用getE而不是get，防止覆盖了父类的该方法</span>
       <span class="hljs-keyword">return</span> (V) cache.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>);
    &#125;
    <span class="hljs-keyword">public</span> V <span class="hljs-built_in">set</span>(K <span class="hljs-built_in">key</span>,V value)&#123;
       <span class="hljs-keyword">return</span> cache.put(<span class="hljs-built_in">key</span>, value);
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> getCacheSize() &#123;
        <span class="hljs-keyword">return</span> cacheSize;
    &#125;

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setCacheSize(<span class="hljs-built_in">int</span> cacheSize) &#123;
        <span class="hljs-keyword">this</span>.cacheSize = cacheSize;
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> printCache()&#123;
        <span class="hljs-keyword">for</span>(Iterator it = cache.entrySet().iterator();it.hasNext();)&#123;
            Entry&lt;K,V&gt; entry = (Entry&lt;K, V&gt;)it.next();
            <span class="hljs-keyword">if</span>(!<span class="hljs-string">""</span>.equals(entry.getValue()))&#123;
                System.out.<span class="hljs-built_in">println</span>(entry.getKey() + <span class="hljs-string">"\t"</span> + entry.getValue()); 
            &#125;
        &#125;
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"------"</span>);
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> PrintlnCache()&#123;
        Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="hljs-built_in">set</span> = cache.entrySet();
        <span class="hljs-keyword">for</span>(Entry&lt;K,V&gt; entry : <span class="hljs-built_in">set</span>)&#123;
            K <span class="hljs-built_in">key</span> = entry.getKey();
            V value = entry.getValue();
            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"key:"</span>+<span class="hljs-built_in">key</span>+<span class="hljs-string">"value:"</span>+value);
        &#125;
        
    &#125;
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;
        LRUCache&lt;<span class="hljs-keyword">String</span>,Integer&gt; lrucache = <span class="hljs-keyword">new</span> LRUCache&lt;<span class="hljs-keyword">String</span>,Integer&gt;(<span class="hljs-number">3</span>);
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">1</span>);
        lrucache.printCache();
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"bbb"</span>, <span class="hljs-number">2</span>);
        lrucache.printCache();
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"ccc"</span>, <span class="hljs-number">3</span>);
        lrucache.printCache();
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"ddd"</span>, <span class="hljs-number">4</span>);
        lrucache.printCache();
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"eee"</span>, <span class="hljs-number">5</span>);
        lrucache.printCache();
        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"这是访问了ddd后的结果"</span>);
        lrucache.<span class="hljs-built_in">get</span>(<span class="hljs-string">"ddd"</span>);
        lrucache.printCache();
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"fff"</span>, <span class="hljs-number">6</span>);
        lrucache.printCache();
        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">7</span>);
        lrucache.printCache();
    &#125;

&#125;</code></pre></div>

<h2 id="17-9-散列与散列码"><a href="#17-9-散列与散列码" class="headerlink" title="17.9 散列与散列码"></a>17.9 散列与散列码</h2><p>Object的hashCode()默认使用当前对象的地址计算散列码，equals()比较对象的地址。</p>
<p>覆盖hashCode()的同时覆盖equals()方法，正确的equals()方法的五个条件：</p>
<ul>
<li>自反性</li>
<li>对称性</li>
<li>传递性</li>
<li>一致性</li>
<li>对任何不是null的x，x.equals(null)一定返回false</li>
</ul>
<h4 id="17-9-1-理解hashcode-散列码"><a href="#17-9-1-理解hashcode-散列码" class="headerlink" title="17.9.1 理解hashcode()散列码"></a>17.9.1 理解hashcode()散列码</h4><p>hashMap 使用 key 的 hashcode 来保存键值对。</p>
<h4 id="17-9-2-为速度而散列"><a href="#17-9-2-为速度而散列" class="headerlink" title="17.9.2 为速度而散列"></a>17.9.2 为速度而散列</h4><p>通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在Object中的、且可被覆盖的hashCode()（散列函数）方法生成。</p>
<p>查询一个值的过程首先是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突（如果值的数量是固定的，那么就有可能），那就有了一个完美的散列函数，但是这种情况是特例。通常，冲突由外部链接处理：数组并不直接保存值，而是保存值的List。</p>
<p>由于散列表中的“槽位”（slot）通常被称为桶位（bucket），因此我们将表示实际散列表的数组命名为bucket。为使散列分布均匀，桶的数量通常使用质数。</p>
<p><strong>保证时间复杂度O(1) 是在 没有hash冲突的情况下。</strong></p>
<hr>
<p><strong>HashMap源码分析：</strong><br>（引用自网络）</p>
<p>在这之前，先介绍一下负载因子和容量的属性。大家都知道其实一个HashMap的实际容量就是因子×容量，其默认值是16×0.75=12；这个很重要，对效率很一定影响！当存入HashMap的对象超过这个容量时，HashMap就会重新构造存取表。这就是一个大问题，我后面慢慢介绍，反正，如果你已经知道你大概要存放多少个对象，最好设为该实际容量的能接受的数字。</p>
<p>两个关键的方法，put和get：</p>
<p>先有这样一个概念，HashMap是声明了Map，Cloneable, Serializable接口，继承AbstractMap类，里面的Iterator其实主要都是其内部类HashIterator和其他几个iterator类实现，当然还有一个很重要的继承了Map.Entry的Entry内部类。Entry内部类包含了hash、value、key和next这四个属性，很重要。put的源码如下：</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> put(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>, <span class="hljs-keyword">Object</span> value) &#123;
    <span class="hljs-keyword">Object</span> k = maskNull(<span class="hljs-built_in">key</span>); <span class="hljs-comment">// 这个就是判断键值是否为空，如果为空，它会返回一个static Object作为键值，这就是为什么HashMap允许空键值的原因。</span>
    <span class="hljs-built_in">int</span> hash = hash(k);
    <span class="hljs-built_in">int</span> i = indexFor(hash, table.length);
    <span class="hljs-comment">// 其中hash就是通过key这个Object的hashCode()进行hash，然后通过indexFor获得在Object table的索引值。</span>
    <span class="hljs-comment">// put其实是一个有返回的方法，它会把相同键值的put覆盖掉并返回旧的值。如下方法彻底说明了HashMap的结构，其实就是一个表加上在相应位置的Entry的链表：</span>
    <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;
        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; eq(k, e.<span class="hljs-built_in">key</span>)) &#123;
            <span class="hljs-keyword">Object</span> oldvalue = e.value;
            e.value = value; <span class="hljs-comment">// 把新的值赋予给对应键值。</span>
            e.recordAccess(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 空方法，留待实现</span>
            <span class="hljs-keyword">return</span> oldvalue; <span class="hljs-comment">// 返回相同键值的对应的旧的值。</span>
        &#125;
    &#125;
    modCount++; <span class="hljs-comment">// 结构性更改的次数</span>
    addEntry(hash, k, value, i); <span class="hljs-comment">// 添加新元素，关键所在！</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 没有相同的键值返回</span>
&#125;</code></pre></div>

<p>我们把关键的方法拿出来分析：</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">void</span> addEntry(<span class="hljs-built_in">int</span> hash, <span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>, <span class="hljs-keyword">Object</span> value, <span class="hljs-built_in">int</span> bucketIndex) &#123;
    
    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry(hash, <span class="hljs-built_in">key</span>, value, table[bucketIndex]);
    <span class="hljs-comment">// 因为hash的算法有可能令不同的键值有相同的hash码并有相同的table索引，它们经过indexfor之后的索引一定为i，这样在new的时候这个Entry的next就会指向这个原本的table[i]，再有下一个也如此，形成一个链表，和put的循环对定e.next获得旧的值。</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>++ &gt;= threshold) <span class="hljs-comment">// 这个threshold就是能实际容纳的量</span>
        resize(<span class="hljs-number">2</span> * table.length); <span class="hljs-comment">// 超出这个容量就会将Object table重构</span>
        <span class="hljs-comment">// 所谓的重构也不神，就是建一个两倍大的table，然后再一个个indexfor进去。注意，这就是效率，如果你能让你的HashMap不需要重构那么多次，效率会大大提高！</span></code></pre></div>

<p> <strong>所谓的重构也不神，就是建一个两倍大的table，然后再一个个indexfor进去。注意，这就是效率，如果你能让你的HashMap不需要重构那么多次，效率会大大提高！</strong></p>
<h4 id="17-9-2-覆盖hashCode"><a href="#17-9-2-覆盖hashCode" class="headerlink" title="17.9.2 覆盖hashCode()"></a>17.9.2 覆盖hashCode()</h4><p>无论何时，对同一个对象调用hashCode()都应该生成相同的值。</p>
<p>要使hashCode()实用，它必须速度快，并且有意义。（即必须基于对象内容生成散列码）。</p>
<p>那么如何设计一个 hashCode 算法，书中设计了一个算法：</p>
<ol>
<li><p>把某个非 0 的常数值，比如 17，保存在一个名为 result 的 int 类型的变量中。</p>
</li>
<li><p>对于对象中的每个域，做如下操作：</p>
<ul>
<li><p>为该域计算 int 类型的哈希值 c ：</p>
<ul>
<li><p>如果该域是 boolean 类型，则计算 (f?1:0)</p>
</li>
<li><p>如果该域是 byte、char、short 或者 int 类型，则计算 (int)f</p>
</li>
<li><p>如果该域是 long 类型，则计算 (int)(f^(f&gt;&gt;&gt;32))</p>
</li>
<li><p>如果该域是 float 类型，则计算 Float.floatToIntBits(f)</p>
</li>
<li><p>如果该域是 double 类型，则计算 Double.doubleToLongBits(f)，然后重复第三个步骤。</p>
</li>
<li><p>如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 方法来比较这个域，同样为这个域递归的调用 hashCode，如果这个域为 null，则返回0。</p>
</li>
<li><p>如果该域是数组，则要把每一个元素当作单独的域来处理，递归的运用上述规则，如果数组域中的每个元素都很重要，那么可以使用 Arrays.hashCode 方法。</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<div class="hljs"><pre><code>* 按照公式 result = 31 * result + c，把上面步骤 2.1 中计算得到的散列码 c 合并到 result 中。

**选择值31是因为它是奇数质数。如果是偶数且乘法运算溢出，则信息将丢失，因为乘以2等于移位。使用质数的优势尚不清楚，但这是传统的。31的一个不错的特性是乘法可以用移位和减法来代替，以获得更好的性能：31 * i == (i &lt;&lt; 5) - i。JVM自动执行这种优化。**</code></pre></div><ol start="3">
<li>返回 result</li>
</ol>
<h2 id="17-10-选择接口的不同实现"><a href="#17-10-选择接口的不同实现" class="headerlink" title="17.10 选择接口的不同实现"></a>17.10 选择接口的不同实现</h2><p>Map、List、Set和Queue</p>
<h4 id="17-10-1-性能测试框架"><a href="#17-10-1-性能测试框架" class="headerlink" title="17.10.1 性能测试框架"></a>17.10.1 性能测试框架</h4><p>计算所有操作所需的纳秒数。封装好Test 对象 使用。输出各种容器的纳秒数。</p>
<h4 id="17-10-2-对List-的选择"><a href="#17-10-2-对List-的选择" class="headerlink" title="17.10.2 对List 的选择"></a>17.10.2 对List 的选择</h4><p>将ArrayList作为默认首选，只有需要使用额外的功能，或者当程序的性能因为经常从表中间进行插入和删除操作而变差时，才去选择LinkedList。如果使用的是固定数量的元素，那么既可以使用背后有数组支撑的List，也可以选择真正的数组。</p>
<h4 id="17-10-3-微基准测试的危险"><a href="#17-10-3-微基准测试的危险" class="headerlink" title="17.10.3  微基准测试的危险"></a>17.10.3  微基准测试的危险</h4><p>剖析器可以把性能分析工作做得更好。Java Profiler</p>
<h4 id="17-10-4-对Set的选择"><a href="#17-10-4-对Set的选择" class="headerlink" title="17.10.4 对Set的选择"></a>17.10.4 对Set的选择</h4><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是最重要的操作。TreeSet存在的唯一原因是它可以维持元素的排序状态，所以当需要一个排好序的Set时，才应该使用TreeSet。</p>
<h4 id="17-10-5-对Map的选择"><a href="#17-10-5-对Map的选择" class="headerlink" title="17.10.5 对Map的选择"></a>17.10.5 对Map的选择</h4><p>调整HashMap以提高性能：</p>
<ul>
<li>容量：表中的桶位数。</li>
<li>初始容量：表在创建时所拥有的桶位数。</li>
<li>尺寸：表中当前存储的项数。</li>
<li>负载因子：尺寸/容量。（如0.75 是达到3/4再散列）</li>
</ul>
<h2 id="17-11-实用方法"><a href="#17-11-实用方法" class="headerlink" title="17.11 实用方法"></a>17.11 实用方法</h2><p>介绍 Collections 详细方法。</p>
<h4 id="17-11-1-List的排序和查询"><a href="#17-11-1-List的排序和查询" class="headerlink" title="17.11.1 List的排序和查询"></a>17.11.1 List的排序和查询</h4><p>List的排序和查询所使用的方法与对象数组所使用的相应方法有相同的名字和语法，只是用Collections的static方法替换为Arrays的方法而已。</p>
<h4 id="17-11-2-设定Collection或Map为不可修改"><a href="#17-11-2-设定Collection或Map为不可修改" class="headerlink" title="17.11.2 设定Collection或Map为不可修改"></a>17.11.2 设定Collection或Map为不可修改</h4><p>Collections.unmodifiableCollection() 有时候需要对它进行保护，避免返回结果被人修改。</p>
<p>Collections.unmodifiableCollection这个可以得到一个集合的镜像，它的返回结果不可直接被改变，否则会提示 :<br>Exception in thread “main” java.lang.UnsupportedOperationException</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsTest</span> &#123;  
      
    @<span class="hljs-function">Test  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;  
        Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();  
          
        Collection&lt;String&gt; s = Collections.unmodifiableCollection(c);  
          
        c.<span class="hljs-keyword">add</span>(<span class="hljs-string">"str"</span>);  
          
        System.<span class="hljs-keyword">out</span>.println(s);  
    &#125;  
  
&#125;</code></pre></div>

<h4 id="17-11-3-Collection或Map同步控制"><a href="#17-11-3-Collection或Map同步控制" class="headerlink" title="17.11.3 Collection或Map同步控制"></a>17.11.3 Collection或Map同步控制</h4><p>Collections.synchronizedCollection() 采用装饰者模式实现 线程安全几个操作方法。</p>
<p>快速报错</p>
<p>获取遍历对象前添加元素 会抛出异常 ConcurrentModificationException，防止多个进程同时修改同一个容器的内容。</p>
<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;

        <span class="hljs-keyword">try</span> &#123;
            <span class="hljs-comment">// creating object of List&lt;String&gt;</span>
            List&lt;<span class="hljs-keyword">String</span>&gt; vector = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();

            Iterator&lt;<span class="hljs-keyword">String</span>&gt; iterator = vector.iterator();

            vector.<span class="hljs-built_in">add</span>(<span class="hljs-string">"A"</span>);

            <span class="hljs-keyword">String</span> next = iterator.next();

        &#125;

        <span class="hljs-keyword">catch</span> (ConcurrentModificationException e) &#123;
            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Exception thrown : "</span> + e);
        &#125;
    &#125;</code></pre></div>

<p>ConcurrentHashMap  CopyOnWriteArrayList  CopyOnWriteArraySet 都是使用了避免 ConcurrentModificationException 的错误。</p>
<h2 id="17-12-持有引用"><a href="#17-12-持有引用" class="headerlink" title="17.12 持有引用"></a>17.12 持有引用</h2><p>StrongReference SoftReference  WeakReference PhantomReference （后三个使用暂时有些迷糊 继续往后看）<br>WeakHashMap<br>这是一种节约存储空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利。</p>
<h2 id="17-13-Java-1-0-1-1-的容器"><a href="#17-13-Java-1-0-1-1-的容器" class="headerlink" title="17.13 Java 1.0/1.1 的容器"></a>17.13 Java 1.0/1.1 的容器</h2><ol>
<li><p>Vector和Enumeration<br> Vector基本可看做ArrayList。<br> Enumeration（枚举）只是接口而不是实现，应尽量使用iterator。</p>
</li>
<li><p>Hashtable</p>
</li>
<li><p>Stack<br> 继承Vector，而不是用Vector创建Stack。</p>
</li>
<li><p>BitSet<br> 高效存储大量“开/关”信息。其效率仅对空间而言，如果需要高效的访问时间，BitSet比本地数组稍慢一点。<br>BitSet的最小容量是long：64位。<br>如果拥有一个可以命名的固定的标志集合，那么EnumSet与BitSet相比，通常是一个更好的选择。</p>
</li>
</ol>
<h2 id="17-14-总结"><a href="#17-14-总结" class="headerlink" title="17.14 总结"></a>17.14 总结</h2><p>java容器对于面向对象来说是最重要的类库。最重要的hashcode 和如何编写 hashcode.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Java/">Java</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/02/28/Thinking-in-Java-第十八章/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Thinking in Java 第十八章</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/02/23/Thinking-in-Java-第十六章/">
                        <span class="hidden-mobile">Thinking in Java 第十六章</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


    
  <!-- 备案信息 -->
  <div class="beian">
    <a href="http://beian.miit.gov.cn/" target="_blank"
       rel="nofollow noopener">京ICP证123456号</a>
    
      <a
        href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
        rel="nofollow noopener"
        class="beian-police"
        target="_blank"
      >
        <span class="beian-police-sep">&nbsp;|&nbsp;</span>
        
          <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon" />
        
        <span>京公网安备12345678号</span>
      </a>
     
  </div>


    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Thinking in Java 第十七章&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
