<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>微服务统⼀认证⽅案 Spring Cloud OAuth2 + JWT</title>
    <link href="/2020/07/31/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%9F%E2%BC%80%E8%AE%A4%E8%AF%81%E2%BD%85%E6%A1%88-Spring-Cloud-OAuth2-JWT/"/>
    <url>/2020/07/31/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%9F%E2%BC%80%E8%AE%A4%E8%AF%81%E2%BD%85%E6%A1%88-Spring-Cloud-OAuth2-JWT/</url>
    
    <content type="html"><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">一、微服务架构下统⼀认证思路</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">基于Session的认证⽅式：在分布式的环境下，基于session的认证会出现⼀个问题，每个应⽤服务都需要在session中存储⽤户身份信息，通过负载均衡将本地的请求分配到另⼀个应⽤服务需要将session信息带过去，否则会重新认证。我们可以使⽤Session共享、Session黏贴等⽅案。</p><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Session⽅案也有缺点，⽐如基于cookie，移动端不能有效使⽤等</strong></p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">基于token的认证⽅式 ： 基于token的认证⽅式，服务端不⽤存储认证数据，易维护扩展性强， 客户端可以把token 存在任意地⽅，并且可以实现web和app统⼀认证机制。其缺点也很明显，token由于⾃包含信息，因此⼀般数据量较⼤，⽽且每次请求 都需要传递，因此⽐较占带宽。另外，token的签名验签操作也会给cpu带来额外的处理负担。</p></section></li></ul><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">二、OAuth2开放授权协议/标准</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">1. OAuth2介绍</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">OAuth（开放授权）<strong style="font-weight: bold; color: black;">是⼀个开放协议/标准</strong>，允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容。</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">OAuth2是OAuth协议的延续版本，但不向后兼容OAuth1即完全废⽌了OAuth1。</strong></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">允许⽤户授权第三⽅应⽤访问他们存储在另外的服务提供者上的信息，⽽不需要将⽤户名和密码提供给第三⽅应⽤或分享他们数据的所有内容</strong></p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">举例：所有的第三方登陆授权都算OAuth，不想注册在第三方网站，可以用QQ、微信授权登陆，开放部分功能。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">2. OAuth2协议⻆⾊和流程</span><span class="suffix" style="display: none;"></span></h3><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgkr.cn-bj.ufileos.com/bc928198-f8c5-40f3-8a33-b50e3ff2bfdf.png" srcset="/img/loading.gif" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">资源所有者（Resource Owner）：可以理解为⽤户⾃⼰</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">客户端（Client）：我们想登陆的⽹站或应⽤，⽐如拉勾⽹</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">认证服务器（Authorization Server）：可以理解为微信或者QQ</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">资源服务器（Resource Server）：可以理解为微信或者QQ</section></li></ul><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">3. 什么情况下需要使⽤OAuth2？</span><span class="suffix" style="display: none;"></span></h3><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">第三⽅授权登录的场景 ： 微信授权登录、QQ授权登录、微博授权登录等，这是典型的 OAuth2 使⽤场景。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">单点登录的场景 ：微服务场景，可以专⻔做⼀个认证中⼼（充当认证平台⻆⾊），所有的服务都要到这个认证中⼼做认证，只做⼀次登录，就可以在多个授权范围内的服务中⾃由串⾏。</section></li></ul><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">4. OAuth2的颁发Token授权⽅式</span><span class="suffix" style="display: none;"></span></h3><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">授权码（authorization-code）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">密码式（password）提供⽤户名+密码换取token令牌</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">隐藏式（implicit）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">客户端凭证（client credentials）</section></li></ol><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">授权码模式使⽤到了回调地址，是最复杂的授权⽅式，微博、微信、QQ等第三⽅登录就是这种模式。一般都是使用密码模式（提供⽤户名+密码换取token）。</p><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">三、Spring Cloud OAuth2 + JWT 实现</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">1. Spring Cloud OAuth2介绍</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">Spring Cloud OAuth2 是 Spring Cloud 体系对OAuth2协议的实现，可以⽤来做多个微服务的统⼀认证（验证身份合法性）授权（验证权限）。通过向OAuth2服务（统⼀认证授权服务）发送某个类型的grant_type进⾏集中认证和授权，从⽽获得access_token（访问令牌），⽽这个token是受其他微服务信任的。</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">注意：使⽤OAuth2解决问题的本质是，引⼊了⼀个认证授权层，认证授权层连接了资源的拥有者，在授权层⾥⾯，资源的拥有者可以给第三⽅应⽤授权去访问我们的某些受保护资源。</strong></p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">2. Spring Cloud OAuth2构建微服务统⼀认证服务思路</span><span class="suffix" style="display: none;"></span></h3><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgkr.cn-bj.ufileos.com/077b2f96-786c-450f-aa90-abd459282659.png" srcset="/img/loading.gif" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">注意：如果比喻成第三方登陆，在我们统⼀认证的场景中，Resource Server其实就是我们的各种受保护的微服务，微服务中的各种API访问接⼝就是资源，发起http请求的浏览器就是Client客户端（对应为第三⽅应⽤），资源服务器就是从三方登陆（比如QQ）那里拿到的头像姓名等信息。</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">3. （进入开发）搭建认证服务器（Authorization Server）和 资源服务器 （Resource Server）</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">搭建 认证服务器（Authorization Server），负责颁发token</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">新建项⽬lagou-cloud-oauth-server-9999</p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">引入依赖 pom.xml</p></section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--导入Eureka Client依赖--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span><span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--导入spring cloud oauth2依赖--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusions</span>&gt;</span><span>                <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusion</span>&gt;</span><span>                    <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.security.oauth.boot<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>                    <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-security-oauth2-autoconfigure<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>                <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusion</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusions</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.security.oauth.boot<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-security-oauth2-autoconfigure<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>2.1.11.RELEASE<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--引入security对oauth2的支持--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.security.oauth<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-security-oauth2<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>2.3.4.RELEASE<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">application.yml（构建认证服务器，配置⽂件⽆特别之处）</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-attr" style="line-height: 26px;">server:</span><span><span class="hljs-attr" style="line-height: 26px;">  port:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">9999</span><span><span class="hljs-attr" style="line-height: 26px;">Spring:</span><span><span class="hljs-attr" style="line-height: 26px;">  application:</span><span><span class="hljs-attr" style="line-height: 26px;">    name:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">lagou-cloud-oauth-server</span><span><span class="hljs-attr" style="line-height: 26px;">  datasource:</span><span><span class="hljs-attr" style="line-height: 26px;">    driver-class-name:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">com.mysql.jdbc.Driver</span><span><span class="hljs-attr" style="line-height: 26px;">    url:</span> <span class="hljs-attr" style="line-height: 26px;">jdbc:mysql://localhost:3306/oauth2?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowMultiQueries=true</span><span><span class="hljs-attr" style="line-height: 26px;">    username:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">root</span><span><span class="hljs-attr" style="line-height: 26px;">    password:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">123456</span><span><span class="hljs-attr" style="line-height: 26px;">    druid:</span><span><span class="hljs-attr" style="line-height: 26px;">      initialSize:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">10</span><span><span class="hljs-attr" style="line-height: 26px;">      minIdle:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">10</span><span><span class="hljs-attr" style="line-height: 26px;">      maxActive:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">30</span><span><span class="hljs-attr" style="line-height: 26px;">      maxWait:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">50000</span><span><span class="hljs-attr" style="line-height: 26px;">eureka:</span><span><span class="hljs-attr" style="line-height: 26px;">  client:</span><span><span class="hljs-attr" style="line-height: 26px;">    serviceUrl:</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;"># eureka server的路径</span><span><span class="hljs-attr" style="line-height: 26px;">      defaultZone:</span> <span class="hljs-attr" style="line-height: 26px;">http://lagoucloudeurekaservera:8761/eureka/,http://lagoucloudeurekaserverb:8762/eureka/</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#把 eureka 集群中的所有 url 都填写了进来，也可以只写一台，因为各个 eureka server 可以同步注册表</span><span><span class="hljs-attr" style="line-height: 26px;">  instance:</span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip）</span><span><span class="hljs-attr" style="line-height: 26px;">    prefer-ip-address:</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">true</span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress</span><span><span class="hljs-attr" style="line-height: 26px;">    instance-id:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">${spring.cloud.client.ip-address}:${spring.application.name}:${server.port}:@project.version@</span><span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">⼊⼝类⽆特殊之处（@SpringBootApplication @EnableDiscoveryClient还是老二位）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">认证服务器配置类</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">package</span> config;<span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.beans.factory.annotation.Autowired;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.context.annotation.Configuration;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.http.HttpMethod;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.authentication.AuthenticationManager;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.provider.token.AuthorizationServerTokenServices;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.provider.token.DefaultTokenServices;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.provider.token.TokenStore;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.provider.token.store.InMemoryTokenStore;<span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@author</span>: 190coder &lt;190coder.cn&gt;<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@description</span>:  当前类为Oauth2 server的配置类（需要继承特定的⽗类)<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@create</span>: 2020-07-30 20:03<span> */</span><span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Configuration</span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@EnableAuthorizationServer</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 开启认证服务器功能</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">class</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">OauthServerConfiger</span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">extends</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">AuthorizationServerConfigurerAdapter</span> </span>{<span><span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Autowired</span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> AuthenticationManager authenticationManager;<span>    <span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 认证服务器最终是以api接⼝的⽅式对外提供服务（校验合法性并⽣成令牌、校验令牌等）<span>     * 那么，以api接⼝⽅式对外的话，就涉及到接⼝的访问权限，我们需要在这⾥进⾏必要的配置<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> security<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">super</span>.configure(security);<span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 相当于打开endpoints 访问接⼝的开关，这样的话后期我们能够访问该接⼝</span><span>        security.<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 允许客户端表单认证</span><span>                allowFormAuthenticationForClients()<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 开启端⼝/oauth/token_key的访问权限（允许）</span><span>                .tokenKeyAccess(<span class="hljs-string" style="color: #d14; line-height: 26px;">"permitAll()"</span>)<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 开启端⼝/oauth/check_token的访问权限（允许）</span><span>                .checkTokenAccess(<span class="hljs-string" style="color: #d14; line-height: 26px;">"permitAll()"</span>);<span><span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 客户端详情配置，<span>     * ⽐如client_id，secret<span>     * 当前这个服务就如同QQ平台，拉勾⽹作为客户端需要qq平台进⾏登录授权认证等，提前需<span>       要到QQ平台注册，QQ平台会给拉勾⽹<span>     * 颁发client_id等必要参数，表明客户端是谁<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> clients<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     *<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">super</span>.configure(clients);<span><span>        clients.<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 客户端信息存储在什么地⽅，可以在内存中，可以在数据库⾥</span><span>                inMemory()<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 添加⼀个client配置,指定其client_id</span><span>                .withClient(<span class="hljs-string" style="color: #d14; line-height: 26px;">"client_lagou"</span>)<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 指定客户端的密码/安全码</span><span>                .secret(<span class="hljs-string" style="color: #d14; line-height: 26px;">"abcxyz"</span>)<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 指定客户端所能访问资源</span><span>                .resourceIds(<span class="hljs-string" style="color: #d14; line-height: 26px;">"autodeliver"</span>)<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 认证类型/令牌颁发模式，可以配置多个在这⾥，但是不⼀定都⽤，具体使⽤哪种⽅式颁发token，需要客户端调⽤的时候传递参数指定</span><span>                .authorizedGrantTypes(<span class="hljs-string" style="color: #d14; line-height: 26px;">"password"</span>,<span class="hljs-string" style="color: #d14; line-height: 26px;">"refresh_token"</span>)<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 客户端的权限范围，此处配置为all全部即可</span><span>                .scopes(<span class="hljs-string" style="color: #d14; line-height: 26px;">"all"</span>);<span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 认证服务器是玩转token的，那么这⾥配置token令牌管理相关（token此时就是⼀个字符<span>        串，当下的token需要在服务器端存储，那么存储在哪⾥呢？都是在这⾥配置）<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> endpoints<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">super</span>.configure(endpoints);<span><span>        endpoints<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 指定token的存储⽅法</span><span>                .tokenStore(tokenStore())<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//token服务的⼀个描述，可以认为是token⽣成细节的描述，⽐如有效时间多少等</span><span>                .tokenServices(authorizationServerTokenServices())<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 指定认证管 理器，随后注⼊⼀个到当前类使⽤即可</span><span>                .authenticationManager(authenticationManager)<span>                .allowedTokenEndpointRequestMethods(HttpMethod.GET,HttpMethod.POST);<span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 该⽅法⽤户获取⼀个token服务对象（该对象描述了token有效期等信息）<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@return</span><span>     */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> AuthorizationServerTokenServices <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">authorizationServerTokenServices</span><span class="hljs-params" style="line-height: 26px;">()</span> </span>{<span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 使⽤默认实现</span><span>        DefaultTokenServices defaultTokenServices = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> DefaultTokenServices();<span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 是否开启令牌刷新</span><span>        defaultTokenServices.setSupportRefreshToken(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">true</span>);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// token以什么形式存储</span><span>        defaultTokenServices.setTokenStore(tokenStore());<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// access_token就是我们请求资源需要携带的令牌</span><span>        defaultTokenServices.setAccessTokenValiditySeconds(<span class="hljs-number" style="color: #008080; line-height: 26px;">30</span>);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 设置刷新令牌的有效时间 3天</span><span>        defaultTokenServices.setRefreshTokenValiditySeconds(<span class="hljs-number" style="color: #008080; line-height: 26px;">259200</span>);<span><span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> defaultTokenServices;<span><span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 该⽅法⽤于创建tokenStore对象（令牌存储对象）token以什么形式存储<span>    */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> TokenStore <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">tokenStore</span><span class="hljs-params" style="line-height: 26px;">()</span></span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> InMemoryTokenStore();<span>    }<span>}<span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">配置类解读：</p></blockquote><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">关于三个configure⽅法</p><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">configure(ClientDetailsServiceConfigurer clients) : 客户端详情信息在 这⾥进⾏初始化，你能够把客户端详情信息写死在这⾥或者是通过数据库来存储调取详情信息</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">configure(AuthorizationServerEndpointsConfigurer endpoints) : 配置令牌（token）的访问端点和令牌服务(token services) 和存储介质</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">configure(AuthorizationServerSecurityConfigurer oauthServer) ： 配置访问权限和令牌服务(token services)</section></li></ul></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">关于 TokenStore</p><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">InMemoryTokenStore ：<strong style="font-weight: bold; color: black;">存放内存中。</strong> 默认采⽤，它可以完美的⼯作在单服务器上（即访问并发量 压⼒不⼤的情况下，并且它在失败的时候不会进⾏备份），⼤多数的项⽬都可以使⽤这个版本的实现来进⾏ 尝试，你可以在开发的时候使⽤它来进⾏管理，因为不会被保存到磁盘中，所以更易于调试。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JdbcTokenStore ： 这是⼀个基于JDBC的实现版本，令牌会被<strong style="font-weight: bold; color: black;">保存进关系型数据库</strong>。使⽤这个版本的实现时， 你可以在不同的服务器之间共享令牌信息，使⽤这个版本的时候请注意把"springjdbc"这个依赖加⼊到你的 classpath当中。</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JwtTokenStore ： 全称是 JSON Web Token（JWT），它可以把令牌相关的数据进⾏编码（因此对于后端服务来说，<strong style="font-weight: bold; color: black;">它不需要进⾏存储</strong>，这将是⼀个重⼤优势），缺点就是这个令牌占⽤的空间会⽐较⼤，如果你加⼊了⽐较多⽤户凭证信息，JwtTokenStore 不会保存任何数据。</section></li></ul></section></li></ul><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"></blockquote><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">认证服务器安全配置类</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">package</span> config;<span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.beans.factory.annotation.Autowired;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.context.annotation.Bean;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.context.annotation.Configuration;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.authentication.AuthenticationManager;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.core.userdetails.User;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.core.userdetails.UserDetails;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.crypto.password.NoOpPasswordEncoder;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.crypto.password.PasswordEncoder;<span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> java.util.ArrayList;<span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@author</span>: 190coder &lt;190coder.cn&gt;<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@description</span>: 该配置类，主要处理⽤户名和密码的校验等事宜<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@create</span>: 2020-07-30 20:52<span> */</span><span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Configuration</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">class</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">SecurityConfiger</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">extends</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">WebSecurityConfigurerAdapter</span> </span>{<span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Autowired</span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> PasswordEncoder passwordEncoder;<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 注册⼀个认证管理器对象到容器<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Bean</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> AuthenticationManager <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">authenticationManagerBean</span><span class="hljs-params" style="line-height: 26px;">()</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">super</span>.authenticationManagerBean();<span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * <span>     * 处理⽤户名和密码验证事宜<span>     * 1）客户端传递username和password参数到认证服务器<span>     * 2）⼀般来说，username和password会存储在数据库中的⽤户表中<span>     * 3）根据⽤户表中数据，验证当前传递过来的⽤户信息的合法性<span>     *<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">protected</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 在这个⽅法中就可以去关联数据库了，当前我们先把⽤户信息配置在内存中</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 实例化⼀个⽤户对象(相当于数据表中的⼀条⽤户记录)</span><span>        UserDetails user = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> User(<span class="hljs-string" style="color: #d14; line-height: 26px;">"admin"</span>,<span class="hljs-string" style="color: #d14; line-height: 26px;">"123456"</span>,<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> ArrayList&lt;&gt;());<span>        auth.inMemoryAuthentication()<span>                .withUser(user).passwordEncoder(passwordEncoder);<span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 密码编码对象（密码不进⾏加密处理）<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@return</span><span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Bean</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> PasswordEncoder <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">passwordEncoder</span><span class="hljs-params" style="line-height: 26px;">()</span> </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> NoOpPasswordEncoder.getInstance();<span>    }<span>}<span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">测试：启动Eureka Server 注册中心，和认证服务</section></li></ul><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">访问：http://localhost:9998/oauth/token?client_secret=abcxyz&amp;grant_type=password&amp;username=admin&amp;password=123456&amp;client_id=client_lagou</p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">endpoint：/oauth/token</p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">获取token携带的参数</p><ul style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: square;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">client_id：客户端id</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">client_secret：客户单密码</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">grant_type：指定使⽤哪种颁发类型，password</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">username：⽤户名</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">password：密码</section></li></ul></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">校验token：http://localhost:9998/oauth/check_token?token=1068b57c-0b2d-4789-8ce5-fa968c402d0a</p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">刷新 token ： http://localhost:9998/oauth/token?grant_type=refresh_token&amp;client_id=client_lagou&amp;client_secret=abcxyz&amp;refresh_token=7c47f959-17a6-4a09-8e7b-0f49bfaef725</p></section></li></ul><hr data-tool="mdnice编辑器" style="height: 1px; margin: 0; margin-top: 10px; margin-bottom: 10px; border: none; border-top: 1px solid black;"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">搭建 资源服务器（希望访问被认证的微服务）Resource Server配置</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">引入outh2对应jar包</p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">资源服务配置类</p></section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">package</span> com.lagou.edu.config;<span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.context.annotation.Configuration;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.config.http.SessionCreationPolicy;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">import</span> org.springframework.security.oauth2.provider.token.RemoteTokenServices;<span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@author</span>: 190coder &lt;190coder.cn&gt;<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@description</span>: 资源服务配置类<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@create</span>: 2020-07-30 21:20<span> */</span><span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Configuration</span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@EnableResourceServer</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 开启资源服务器功能</span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@EnableWebSecurity</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 开启web访问安全</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">class</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">ResourceServerConfiger</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">extends</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">ResourceServerConfigurerAdapter</span> </span>{<span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> String sign_key = <span class="hljs-string" style="color: #d14; line-height: 26px;">"190coder.cn"</span>; <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// jwt签名密钥</span><span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 该⽅法⽤于定义资源服务器向远程认证服务器发起请求，进⾏token校验等事宜<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> resources<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        resources.resourceId(<span class="hljs-string" style="color: #d14; line-height: 26px;">"autodeliver"</span>);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 定义token服务对象（token校验就应该靠token服务对象）</span><span>        RemoteTokenServices remoteTokenServices = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> RemoteTokenServices();<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 校验端点/接⼝设置</span><span>        remoteTokenServices.setCheckTokenEndpointUrl(<span class="hljs-string" style="color: #d14; line-height: 26px;">"http://localhost:9998/oauth/check_token"</span>);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 携带客户端id和客户端安全码</span><span>        remoteTokenServices.setClientId(<span class="hljs-string" style="color: #d14; line-height: 26px;">"client_lagou"</span>);<span>        remoteTokenServices.setClientSecret(<span class="hljs-string" style="color: #d14; line-height: 26px;">"abcxyz"</span>);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 别忘了这⼀步</span><span>        resources.tokenServices(remoteTokenServices);<span><span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 场景：⼀个服务中可能有很多资源（API接⼝）<span>     * 某⼀些API接⼝，需要先认证，才能访问<span>     * 某⼀些API接⼝，压根就不需要认证，本来就是对外开放的接⼝<span>     * 我们就需要对不同特点的接⼝区分对待（在当前configure⽅法中完成），设置<span>     是否需要经过认证<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> http<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(HttpSecurity http)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        http<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 设置session的创建策略（根据需要创建即可）</span><span>                .sessionManagement()<span>                .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)<span>                .and()<span>                .authorizeRequests()<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// autodeliver为前缀的请求需要认证</span><span>                .antMatchers(<span class="hljs-string" style="color: #d14; line-height: 26px;">"/autodeliver/**"</span>).authenticated()<span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// demo为前缀的请求需要认证</span><span>                .antMatchers(<span class="hljs-string" style="color: #d14; line-height: 26px;">"/demo/**"</span>).authenticated()<span>                .anyRequest().permitAll(); <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 其他请求不认证</span><span>    }<span>}<span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">思考：当我们第⼀次登陆之后，认证服务器颁发token并将其存储在认证服务器中，后期我们访问资源服务器时会携带token，资源服务器会请求认证服务器验证token有效性，如果资源服务器有很多，那么认证服务器压⼒会很⼤.......</p></blockquote><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">另外，资源服务器向认证服务器check_token，获取的也是⽤户信息UserInfo，能否把⽤户信息存储到令牌中，让客户端⼀直持有这个令牌，令牌的验证也在资源服务器进⾏，这样避免和认证服务器频繁的交互......</p></blockquote><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">我们可以考虑使⽤ JWT 进⾏改造，使⽤JWT机制之后资源服务器不需要访问认证服务器......</p></blockquote><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">5. JWT改造统⼀认证授权中⼼的令牌存储机制</span><span class="suffix" style="display: none;"></span></h3><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">5.1 JWT令牌介绍：</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">通过上边的测试我们发现，当资源服务和授权服务不在⼀起时资源服务使⽤RemoteTokenServices 远程请求授权 服务验证token，如果访问量较⼤将会影响系统的性能。解决上边问题： 令牌采⽤JWT格式即可解决上边的问题，⽤户认证通过会得到⼀个JWT令牌，JWT令牌中已经包括了⽤户相关的信 息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法⾃⾏完成令牌校验，⽆需每次都请求认证 服务完成授权。</p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">5.2 什么是JWT？</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">JSON Web Token（JWT）是⼀个开放的⾏业标准（RFC 7519），它定义了⼀种简介的、⾃包含的协议格式，⽤于 在通信双⽅传递json对象，传递的信息经过数字签名可以被验证和信任。<strong style="font-weight: bold; color: black;">JWT可以使⽤HMAC算法或使⽤RSA的公钥/私钥对来签名，防⽌被篡改</strong>。</p><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">5.3 JWT令牌结构</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">JWT令牌由三部分组成，每部分中间使⽤点（.）分隔，⽐如：xxxxx.yyyyy.zzzzz</p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Header ： 头部包括令牌的类型（即JWT）及使⽤的哈希算法（如HMAC SHA256或RSA），例如</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">{<span><span class="hljs-attr" style="line-height: 26px;">"alg"</span>: <span class="hljs-string" style="color: #d14; line-height: 26px;">"HS256"</span>,<span><span class="hljs-attr" style="line-height: 26px;">"typ"</span>: <span class="hljs-string" style="color: #d14; line-height: 26px;">"JWT"</span><span>}<span></span></span></span></span></code></pre></div><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">将上边的内容使⽤Base64Url编码，得到⼀个字符串就是JWT令牌的第⼀部分。</p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Payload第⼆部分是负载，内容也是⼀个json对象，它是存放有效信息的地⽅，它可以存放jwt提供的现成字段，⽐ 如：iss（签发者）,exp（过期时间戳）, sub（⾯向的⽤户）等，也可⾃定义字段。 此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。 最后将第⼆部分负载使⽤Base64Url编码，得到⼀个字符串就是JWT令牌的第⼆部分。 ⼀个例⼦：</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">{<span><span class="hljs-attr" style="line-height: 26px;">"sub"</span>: <span class="hljs-string" style="color: #d14; line-height: 26px;">"1234567890"</span>,<span><span class="hljs-attr" style="line-height: 26px;">"name"</span>: <span class="hljs-string" style="color: #d14; line-height: 26px;">"John Doe"</span>,<span><span class="hljs-attr" style="line-height: 26px;">"iat"</span>: <span class="hljs-number" style="color: #008080; line-height: 26px;">1516239022</span><span>}<span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Signature第三部分是签名，此部分⽤于防⽌jwt内容被篡改。 这个部分使⽤base64url将前两部分进⾏编码，编码后使⽤点（.）连接组成字符串，最后使⽤header中声明 签名算法进⾏签名。</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">HMACSHA<span class="hljs-number" style="color: #008080; line-height: 26px;">2</span><span class="hljs-number" style="color: #008080; line-height: 26px;">5</span><span class="hljs-number" style="color: #008080; line-height: 26px;">6</span>(<span>  base<span class="hljs-number" style="color: #008080; line-height: 26px;">6</span><span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>UrlEncode(header) + <span class="hljs-string" style="color: #d14; line-height: 26px;">"."</span> +<span>  base<span class="hljs-number" style="color: #008080; line-height: 26px;">6</span><span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>UrlEncode(payload),<span>  secret)<span></span></span></span></span></code></pre></div><div class="hljs"><pre><code style="display: -webkit-box; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; border-radius: 0px; font-size: 12px; -webkit-overflow-scrolling: touch;">- base64UrlEncode(header)：jwt令牌的第⼀部分。- base64UrlEncode(payload)：jwt令牌的第⼆部分。- secret：签名所使⽤的密钥。</code></pre></div><h4 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 18px;"><span class="prefix" style="display: none;"></span><span class="content">5.4 代码改造 （认证服务器 和 资源服务器）</span><span class="suffix" style="display: none;"></span></h4><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">认证服务器端JWT改造(改造主配置类)</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">改造存token的介质，改为jwt，再配置转换器，将信息转化jwt token</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 该⽅法⽤于创建tokenStore对象（令牌存储对象）token以什么形式存储<span>    */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> TokenStore <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">tokenStore</span><span class="hljs-params" style="line-height: 26px;">()</span></span>{<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//return new InMemoryTokenStore();</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 使⽤jwt令牌</span><span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> JwtTokenStore(jwtAccessTokenConverter());<span>    }<span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> String sign_key = <span class="hljs-string" style="color: #d14; line-height: 26px;">"xxxxx"</span>; <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// jwt签名密钥</span><span>    <span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 返回jwt令牌转换器（帮助我们⽣成jwt令牌的）<span>     * 在这⾥，我们可以把签名密钥传递进去给转换器对象<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@return</span><span>     */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> JwtAccessTokenConverter <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">jwtAccessTokenConverter</span><span class="hljs-params" style="line-height: 26px;">()</span> </span>{<span><span>        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> JwtAccessTokenConverter();<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 签名密钥</span><span>        jwtAccessTokenConverter.setSigningKey(sign_key);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 验证时使⽤的密钥，和签名密钥保持⼀致</span><span>        jwtAccessTokenConverter.setVerifier(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> MacSigner(sign_key));<span><span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> jwtAccessTokenConverter;<span>    }<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">修改 JWT 令牌服务⽅法，主要是添加jwt 转换器</section></li></ul><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgkr.cn-bj.ufileos.com/e0e283f4-bfc3-4798-8c57-df7a8063ef34.png" srcset="/img/loading.gif" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">资源服务器校验JWT令牌</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">不需要和远程认证服务器交互，添加本地tokenStore，修改configure 方法</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 该⽅法⽤于定义资源服务器向远程认证服务器发起请求，进⾏token校验等事宜<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> resources<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(ResourceServerSecurityConfigurer resources)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        resources.resourceId("autodeliver");</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        // 定义token服务对象（token校验就应该靠token服务对象）</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        RemoteTokenServices remoteTokenServices = new RemoteTokenServices();</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        // 校验端点/接⼝设置</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        remoteTokenServices.setCheckTokenEndpointUrl("http://localhost:9998/oauth/check_token");</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        // 携带客户端id和客户端安全码</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        remoteTokenServices.setClientId("client_lagou");</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        remoteTokenServices.setClientSecret("abcxyz");</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        // 别忘了这⼀步</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        resources.tokenServices(remoteTokenServices);</span><span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// JWT 令牌改造</span><span>        resources.resourceId(<span class="hljs-string" style="color: #d14; line-height: 26px;">"autodeliver"</span>).tokenStore(tokenStore()).stateless(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">true</span>);<span><span>    }<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">添加 和认证服务器一样的就问他token 存储</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">     <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 该⽅法⽤于创建tokenStore对象（令牌存储对象）token以什么形式存储<span>     */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> TokenStore <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">tokenStore</span><span class="hljs-params" style="line-height: 26px;">()</span></span>{<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//return new InMemoryTokenStore();</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 使⽤jwt令牌</span><span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> JwtTokenStore(jwtAccessTokenConverter());<span>    }<span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> String sign_key = <span class="hljs-string" style="color: #d14; line-height: 26px;">"190coder.cn"</span>; <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// jwt签名密钥</span><span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 返回jwt令牌转换器（帮助我们⽣成jwt令牌的）<span>     * 在这⾥，我们可以把签名密钥传递进去给转换器对象<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@return</span><span>     */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> JwtAccessTokenConverter <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">jwtAccessTokenConverter</span><span class="hljs-params" style="line-height: 26px;">()</span> </span>{<span><span>        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> JwtAccessTokenConverter();<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 签名密钥</span><span>        jwtAccessTokenConverter.setSigningKey(sign_key);<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 验证时使⽤的密钥，和签名密钥保持⼀致</span><span>        jwtAccessTokenConverter.setVerifier(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> MacSigner(sign_key));<span><span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> jwtAccessTokenConverter;<span>    }<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">6. 从数据库加载Oauth2客户端信息</span><span class="suffix" style="display: none;"></span></h3><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">创建数据表并初始化。 数据根据源码可得出 （表名及字段保持固定）</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NAMES</span> utf8mb4;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number" style="color: #008080; line-height: 26px;">0</span>;<span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span>配置数据源<span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- Table structure for oauth_client_details</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DROP</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">TABLE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">IF</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">EXISTS</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">`oauth_client_details`</span>;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CREATE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">TABLE</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">`oauth_client_details`</span> (<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`client_id`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">48</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`resource_ids`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`client_secret`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`scope`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`authorized_grant_types`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`web_server_redirect_uri`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`authorities`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`access_token_validity`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`refresh_token_validity`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`additional_information`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">4096</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`autoapprove`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">varchar</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">256</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span>PRIMARY <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">KEY</span> (<span class="hljs-string" style="color: #d14; line-height: 26px;">`client_id`</span>)<span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">ENGINE</span>=<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">InnoDB</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CHARSET</span>=utf8;<span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- Records of oauth_client_details</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">BEGIN</span>;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">INSERT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">INTO</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">`oauth_client_details`</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">VALUES</span> (<span class="hljs-string" style="color: #d14; line-height: 26px;">'client_lagou123'</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">'autodeliver,resume'</span>, <span class="hljs-string" style="color: #d14; line-height: 26px;">'abcxyz'</span>, <span class="hljs-string" style="color: #d14; line-height: 26px;">'all'</span>, <span class="hljs-string" style="color: #d14; line-height: 26px;">'password,refresh_token'</span>, <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>, <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-number" style="color: #008080; line-height: 26px;">7200</span>, <span class="hljs-number" style="color: #008080; line-height: 26px;">259200</span>, <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>, <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>);<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">COMMIT</span>;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span>;<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">配置数据源</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-attr" style="line-height: 26px;">Spring:</span><span><span class="hljs-attr" style="line-height: 26px;">  application:</span><span><span class="hljs-attr" style="line-height: 26px;">    name:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">test-oauth2-9998</span><span><span class="hljs-attr" style="line-height: 26px;">  datasource:</span><span><span class="hljs-attr" style="line-height: 26px;">    driver-class-name:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">com.mysql.jdbc.Driver</span><span><span class="hljs-attr" style="line-height: 26px;">    url:</span> <span class="hljs-attr" style="line-height: 26px;">jdbc:mysql://localhost:3306/lagou_homework?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowMultiQueries=true</span><span><span class="hljs-attr" style="line-height: 26px;">    username:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">root</span><span><span class="hljs-attr" style="line-height: 26px;">    password:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">123321</span><span><span class="hljs-attr" style="line-height: 26px;">    druid:</span><span><span class="hljs-attr" style="line-height: 26px;">      initialSize:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">10</span><span><span class="hljs-attr" style="line-height: 26px;">      minIdle:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">10</span><span><span class="hljs-attr" style="line-height: 26px;">      maxActive:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">30</span><span><span class="hljs-attr" style="line-height: 26px;">      maxWait:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">50000</span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">认证服务器主配置类改造</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 客户端详情配置，<span>     * ⽐如client_id，secret<span>     * 当前这个服务就如同QQ平台，拉勾⽹作为客户端需要qq平台进⾏登录授权认证等，提前需<span>       要到QQ平台注册，QQ平台会给拉勾⽹<span>     * 颁发client_id等必要参数，表明客户端是谁<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> clients<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> Exception<span>     *<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(ClientDetailsServiceConfigurer clients)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">super</span>.configure(clients);<span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        clients.</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                // 客户端信息存储在什么地⽅，可以在内存中，可以在数据库⾥</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                inMemory()</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                // 添加⼀个client配置,指定其client_id</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                .withClient("client_lagou")</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                // 指定客户端的密码/安全码</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                .secret("abcxyz")</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                // 指定客户端所能访问资源</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                .resourceIds("autodeliver")</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                // 认证类型/令牌颁发模式，可以配置多个在这⾥，但是不⼀定都⽤，具体使⽤哪种⽅式颁发token，需要客户端调⽤的时候传递参数指定</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                .authorizedGrantTypes("password","refresh_token")</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                // 客户端的权限范围，此处配置为all全部即可</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                .scopes("all");</span><span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 从内存中加载客户端详情改为从数据库中加载客户端详情</span><span>        clients.withClientDetails(createJdbcClientDetailsService());<span>    }<span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Autowired</span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> DataSource dataSource;<span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Bean</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> JdbcClientDetailsService <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">createJdbcClientDetailsService</span><span class="hljs-params" style="line-height: 26px;">()</span> </span>{<span>        JdbcClientDetailsService jdbcClientDetailsService = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span><span>                JdbcClientDetailsService(dataSource);<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> jdbcClientDetailsService;<span>    }<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">7. 从数据库验证⽤户合法性</span><span class="suffix" style="display: none;"></span></h3><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">创建数据表users（表名不需固定），初始化数据</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NAMES</span> utf8mb4;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number" style="color: #008080; line-height: 26px;">0</span>;<span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- Table structure for users</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DROP</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">TABLE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">IF</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">EXISTS</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">`users`</span>;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CREATE</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">TABLE</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">`users`</span> (<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`id`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">int</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">11</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">NOT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span> AUTO_INCREMENT,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`username`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">char</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">10</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span><span class="hljs-string" style="color: #d14; line-height: 26px;">`password`</span> <span class="hljs-built_in" style="color: #0086b3; line-height: 26px;">char</span>(<span class="hljs-number" style="color: #008080; line-height: 26px;">100</span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">NULL</span>,<span>PRIMARY <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">KEY</span> (<span class="hljs-string" style="color: #d14; line-height: 26px;">`id`</span>)<span>) <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">ENGINE</span>=<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">InnoDB</span> AUTO_INCREMENT=<span class="hljs-number" style="color: #008080; line-height: 26px;">5</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">DEFAULT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">CHARSET</span>=utf8;<span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- Records of users</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">-- ----------------------------</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">BEGIN</span>;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">INSERT</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">INTO</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">`users`</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">VALUES</span> (<span class="hljs-number" style="color: #008080; line-height: 26px;">4</span>, <span class="hljs-string" style="color: #d14; line-height: 26px;">'lagou-user'</span>, <span class="hljs-string" style="color: #d14; line-height: 26px;">'iuxyzds'</span>);<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">COMMIT</span>;<span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">SET</span> FOREIGN_KEY_CHECKS = <span class="hljs-number" style="color: #008080; line-height: 26px;">1</span>;<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">开发UserDetailsService接⼝的实现类，根据⽤户名从数据库加载⽤户信息</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@author</span>: 190coder &lt;190coder.cn&gt;<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@description</span>:  UserDetailsService接⼝的实现类<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@create</span>: 2020-07-30 23:19<span> */</span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Service</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">class</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">JdbcUserDetailsService</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">implements</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">UserDetailsService</span> </span>{<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// Jpa 查询</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Autowired</span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> UsersRepository usersRepository;<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 根据username查询出该⽤户的所有信息，封装成UserDetails类型的对象返回，⾄于密码，框<span>     * 架会⾃动匹配<span>     *<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@param</span> s<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@return</span><span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@throws</span> UsernameNotFoundException<span>     */</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> UserDetails <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">loadUserByUsername</span><span class="hljs-params" style="line-height: 26px;">(String s)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> UsernameNotFoundException </span>{<span>        Users users = usersRepository.findByUsername(s);<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> User(users.getUsername(),users.getPassword(),<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span><span>                ArrayList&lt;&gt;());<span>    }<span>}<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">使⽤⾃定义的⽤户详情服务对象 (验证配置类)</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Autowired</span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">private</span> JdbcUserDetailsService jdbcUserDetailsService;<span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     *<span>     * 处理⽤户名和密码验证事宜<span>     * 1）客户端传递username和password参数到认证服务器<span>     * 2）⼀般来说，username和password会存储在数据库中的⽤户表中<span>     * 3）根据⽤户表中数据，验证当前传递过来的⽤户信息的合法性<span>     *<span>     */</span><span>    <span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">protected</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">configure</span><span class="hljs-params" style="line-height: 26px;">(AuthenticationManagerBuilder auth)</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">throws</span> Exception </span>{<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 在这个⽅法中就可以去关联数据库了，当前我们先把⽤户信息配置在内存中</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 实例化⼀个⽤户对象(相当于数据表中的⼀条⽤户记录)</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        UserDetails user = new User("admin","123456",new ArrayList&lt;&gt;());</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//        auth.inMemoryAuthentication()</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">//                .withUser(user).passwordEncoder(passwordEncoder);</span><span><span>        auth.userDetailsService(jdbcUserDetailsService).passwordEncoder(passwordEncoder);<span>    }<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">8. 基于Oauth2的 JWT 令牌信息扩展</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">OAuth2帮我们⽣成的JWT令牌载荷部分信息有限，关于⽤户信息只有⼀个user_name，有些场景下我们希望放⼊⼀些扩展信息项，比如IP （提高安全性） ，UserId...,如下添加扩展信息：</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">认证服务器⽣成JWT令牌时存⼊扩展信息（⽐如clientIp）</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">继承DefaultAccessTokenConverter类，重写convertAccessToken⽅法存⼊扩展信息</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@author</span>: 190coder &lt;190coder.cn&gt;<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@description</span>: 自定义扩展信息<span> * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@create</span>: 2020-07-30 23:41<span> */</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">class</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">LagouAccessTokenConvertor</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">extends</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">DefaultAccessTokenConverter</span> </span>{<span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Override</span><span>    <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> Map&lt;String, ?&gt; convertAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {<span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 获取到request对象</span><span>        HttpServletRequest request = ((ServletRequestAttributes)<span>                (RequestContextHolder.getRequestAttributes())).getRequest();<span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 获取客户端ip（注意：如果是经过代理之后到达当前服务的话，那么这种⽅式获取的并不是真实的浏览器客户端ip）</span><span>        String remoteAddr = request.getRemoteAddr();<span>        Map&lt;String, String&gt; stringMap = (Map&lt;String, String&gt;)<span>                <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">super</span>.convertAccessToken(token, authentication);<span>        stringMap.put(<span class="hljs-string" style="color: #d14; line-height: 26px;">"clientIp"</span>,remoteAddr);<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> stringMap;<span>    }<span>}<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">将⾃定义的转换器对象注⼊到配置jwt返回的类中</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">/**<span>     * 返回jwt令牌转换器（帮助我们生成jwt令牌的）<span>     * 在这里，我们可以把签名密钥传递进去给转换器对象<span>     * <span class="hljs-doctag" style="color: #d14; line-height: 26px;">@return</span><span>     */</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> JwtAccessTokenConverter <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">jwtAccessTokenConverter</span><span class="hljs-params" style="line-height: 26px;">()</span> </span>{<span>        JwtAccessTokenConverter jwtAccessTokenConverter = <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> JwtAccessTokenConverter();<span>        jwtAccessTokenConverter.setSigningKey(sign_key);  <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 签名密钥</span><span>        jwtAccessTokenConverter.setVerifier(<span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> MacSigner(sign_key));  <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 验证时使用的密钥，和签名密钥保持一致</span><span>        jwtAccessTokenConverter.setAccessTokenConverter(lagouAccessTokenConvertor);<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> jwtAccessTokenConverter;<span>    }<span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">9. 资源服务器取出 JWT 令牌扩展信息</span><span class="suffix" style="display: none;"></span></h3><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">资源服务器也需要⾃定义⼀个转换器类，继承DefaultAccessTokenConverter，重写extractAuthentication提取⽅法，把载荷信息设置到认证对象的details属性中</p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">将⾃定义的转换器对象注⼊ （返回jwt令牌转换器）的方法</p></section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">业务类⽐如Controller类中，可以通过SecurityContextHolder.getContext().getAuthentication()获取到认证对象，进⼀步获取到扩展信息</p></section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">Object details = SecurityContextHolder.getContext().getAuthentication().getDetails();<span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">获取到扩展信息后，就可以做其他的处理了，⽐如根据userId进⼀步处理，或者根据clientIp处理，或者其他都是可以的了</section></li></ul><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">10. 注意事项</span><span class="suffix" style="display: none;"></span></h3><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JWT令牌就是⼀种可以被验证的数据组织格式，它的玩法很灵活，我们这⾥是基于Spring Cloud Oauth2 创建、校验JWT令牌</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">我们也可以⾃⼰写⼯具类⽣成、校验JWT令牌</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JWT令牌中不要存放过于敏感的信息，因为我们知道拿到令牌后，我们可以解码看到载荷部分的信息</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">JWT令牌每次请求都会携带，内容过多，会增加⽹络带宽占⽤</section></li></ul><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">lagouedu 应颠大佬 笔记整理</p></blockquote><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);" target="_blank" rel="noopener">mdnice</a> 排版</p></section>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>微服务监控之分布式链路追踪技术 Sleuth + Zipkin</title>
    <link href="/2020/07/30/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF-Sleuth-Zipkin/"/>
    <url>/2020/07/30/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%91%E6%8E%A7%E4%B9%8B%E5%88%86%E5%B8%83%E5%BC%8F%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF-Sleuth-Zipkin/</url>
    
    <content type="html"><![CDATA[<section id="nice" data-tool="mdnice编辑器" data-website="https://www.mdnice.com" style="font-size: 16px; color: black; padding: 0 10px; line-height: 1.6; word-spacing: 0px; letter-spacing: 0px; word-break: break-word; word-wrap: break-word; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, 'PingFang SC', Cambria, Cochin, Georgia, Times, 'Times New Roman', serif;"><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">一、分布式链路追踪技术适⽤场景（问题场景）</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">1. 场景描述</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">在微服务架构下，⼀次请求少则经过三四次服务调⽤完成，多则跨越⼏⼗个甚⾄是上百个服务节点。那么问题接踵⽽来：</p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如何动态展示服务的调⽤链路？（⽐如A服务调⽤了哪些其他的服务---依赖关系）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如何分析服务调⽤链路中的瓶颈节点并对其进⾏调优？(⽐如A—&gt;B—&gt;C，C服务处理时间特别⻓)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">如何快速进⾏服务链路的故障发现？</section></li></ul><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">2. 分布式链路追踪技术</span><span class="suffix" style="display: none;"></span></h3><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">分布式环境下基于这种想法<strong style="font-weight: bold; color: black;">实现的监控技术</strong>就是就是分布式链路追踪（全链路追踪)</p><h3 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; font-size: 20px;"><span class="prefix" style="display: none;"></span><span class="content">3. 市场上的分布式链路追踪⽅案</span><span class="suffix" style="display: none;"></span></h3><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Spring Cloud Sleuth + Twitter Zipkin(社区最活跃、文档最丰富)</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">阿⾥巴巴的“鹰眼”</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">⼤众点评的“CAT”</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">美团的“Mtrace”</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">京东的“Hydra”</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">新浪的“Watchman”</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">Apache Skywalking（最近被提到很多）</section></li></ul><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">二、分布式链路追踪技术核⼼思想</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">本质：记录⽇志，作为⼀个完整的技术，分布式链路追踪也有⾃⼰的理论和概念</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">微服务架构中，针对请求处理的调⽤链可以展现为⼀棵树，示意如下：</p><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgkr.cn-bj.ufileos.com/ac7ff0e4-6d6e-4baa-a95c-d97feb437957.png" srcset="/img/loading.gif" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">上图标识⼀个请求链路，⼀条链路通过TraceId唯⼀标识，span标识发起的请求信息，各span通过parrentId关联起来</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Trace：</strong> request-&gt; response 整个过程</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Trace ID：</strong> 服务跟踪框架为该请求创建⼀个唯⼀的跟踪标识Trace ID，同时在分布式系统内部流转的时候，框架失踪保持该唯⼀标识，直到返回给请求⽅</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Span ID：</strong> 为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过⼀个<strong style="font-weight: bold; color: black;">唯⼀标识SpanID来标记它的开始</strong>，具体过程以及结束。对每⼀个Span来说，它必须有开始和结束两个节点，通过记录开始Span和结束Span的时间戳，就能统计出该Span的时间延迟，除了时间戳记录之外，它还可以包含⼀些其他元数据，⽐如时间名称、请求信息等。每⼀个Span都会有⼀个唯⼀跟踪标识 Span ID,若⼲个有序的 span 就组成了⼀个 trace。</p><hr data-tool="mdnice编辑器" style="height: 1px; margin: 0; margin-top: 10px; margin-bottom: 10px; border: none; border-top: 1px solid black;"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">Span可以认为是⼀个⽇志数据结构，在⼀些特殊的时机点会记录了⼀些⽇志信息，⽐如有时间戳、spanId、TraceId，parentIde等，Span中也抽象出了另外⼀个概念，叫做事件，核⼼事件如下：</p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CS ：client send/start 客户端/消费者发出⼀个请求，描述的是⼀个span开始</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SR: server received/start 服务端/⽣产者接收请求 SR-CS属于请求发送的⽹络延迟</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">SS: server send/finish 服务端/⽣产者发送应答 SS-SR属于服务端消耗时间</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">CR：client received/finished 客户端/消费者接收应答 CR-SS表示回复需要的时间(响应的⽹络延迟)</section></li></ul><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">注意：我们往往把Spring Cloud Sleuth 和 Zipkin ⼀起使⽤，把 Sleuth 的数据信息发送给 Zipkin 进⾏聚合，利⽤ Zipkin 存储并展示数据。</p><figure data-tool="mdnice编辑器" style="margin: 0; margin-top: 10px; margin-bottom: 10px; display: flex; flex-direction: column; justify-content: center; align-items: center;"><img src="https://imgkr.cn-bj.ufileos.com/6c02678e-a272-4d3e-8300-d6e9e70f7898.png" srcset="/img/loading.gif" alt style="display: block; margin: 0 auto; max-width: 100%;"></figure><h2 data-tool="mdnice编辑器" style="margin-top: 30px; margin-bottom: 15px; padding: 0px; font-weight: bold; color: black; border-bottom: 2px solid rgb(239, 112, 96); font-size: 1.3em;"><span class="prefix" style="display: none;"></span><span class="content" style="display: inline-block; font-weight: bold; background: rgb(239, 112, 96); color: #ffffff; padding: 3px 10px 1px; border-top-right-radius: 3px; border-top-left-radius: 3px; margin-right: 3px;">三、Sleuth + Zipkin</span><span class="suffix"></span><span style="display: inline-block; vertical-align: bottom; border-bottom: 36px solid #efebe9; border-right: 20px solid transparent;"> </span></h2><ol data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;"><strong style="font-weight: bold; color: black;">每⼀个</strong>需要被追踪踪迹的微服务⼯程都引⼊依赖坐标</section></li></ol><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--链路追踪--&gt;</span><span><span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>  <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>  <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span><span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span></span></span></span></span></span></code></pre></div><ol start="2" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">每⼀个微服务都修改application.yml配置⽂件，添加⽇志级别</section></li></ol><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#分布式链路追踪</span><span><span class="hljs-attr" style="line-height: 26px;">logging:</span><span><span class="hljs-attr" style="line-height: 26px;">  level:</span><span>    <span class="hljs-string" style="color: #d14; line-height: 26px;">org.springframework.web.servlet.DispatcherServlet:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">debug</span><span>    <span class="hljs-string" style="color: #d14; line-height: 26px;">org.springframework.cloud.sleuth:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">debug</span><span></span></span></span></span></span></code></pre></div><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">请求到来时，我们在控制台可以观察到 Sleuth 输出的⽇志（全局 TraceId、SpanId等）。</p><ol start="3" data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: decimal;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">结合 Zipkin 展示追踪数据</section></li></ol><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;">Zipkin 包括Zipkin Server和 Zipkin Client两部分，Zipkin Server是⼀个单独的服务，Zipkin Client就是具体的微服务</p><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Zipkin Server 构建 :</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">pom.xml</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependencies</span>&gt;</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--zipkin-server的依赖坐标--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>zipkin-server<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>2.12.3<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusions</span>&gt;</span><span>                <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--排除掉log4j2的传递依赖，避免和springboot依赖的日志组件冲突--&gt;</span><span>                <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusion</span>&gt;</span><span>                    <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>                    <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>                <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusion</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">exclusions</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--zipkin-server ui界面依赖坐标--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>2.12.3<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span><span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--zipkin针对mysql持久化的依赖--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>zipkin-autoconfigure-storage-mysql<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>2.12.3<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>mysql<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>1.1.10<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>        <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">&lt;!--操作数据库需要事务控制--&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>            <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>        <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>    <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependencies</span>&gt;</span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">⼊⼝启动类</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@SpringBootApplication</span><span><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@EnableZipkinServer</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 开启Zipkin 服务器功能</span><span><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-class" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">class</span> <span class="hljs-title" style="color: #458; font-weight: bold; line-height: 26px;">ZipkinServerApplication9411</span> </span>{<span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">static</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">void</span> <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">main</span><span class="hljs-params" style="line-height: 26px;">(MysqlxDatatypes.Scalar.String[] args)</span> </span>{<span>        SpringApplication.run(ZipkinServerApplication9411.class,args);<span>    }<span><span>    <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">// 注入事务控制器</span><span>    <span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Bean</span><span>    <span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> PlatformTransactionManager <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">transactionManager</span><span class="hljs-params" style="line-height: 26px;">(DataSource dataSource)</span> </span>{<span>        <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> DataSourceTransactionManager(dataSource);<span>    }<span>}<span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">application.yml</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-attr" style="line-height: 26px;">server:</span><span><span class="hljs-attr" style="line-height: 26px;">  port:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">9411</span><span><span class="hljs-attr" style="line-height: 26px;">management:</span><span><span class="hljs-attr" style="line-height: 26px;">  metrics:</span><span><span class="hljs-attr" style="line-height: 26px;">    web:</span><span><span class="hljs-attr" style="line-height: 26px;">      server:</span><span><span class="hljs-attr" style="line-height: 26px;">        auto-time-requests:</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">false</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;"># 关闭自动检测</span><span></span></span></span></span></span></span></span></code></pre></div><hr data-tool="mdnice编辑器" style="height: 1px; margin: 0; margin-top: 10px; margin-bottom: 10px; border: none; border-top: 1px solid black;"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Zipkin Client 构建 :</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">pom中添加 zipkin 依赖（在具体微服务中修改）</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>  <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>  <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span><span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">application.yml 中添加对zipkin server的引⽤</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-attr" style="line-height: 26px;">spring:</span><span><span class="hljs-attr" style="line-height: 26px;">  application:</span><span><span class="hljs-attr" style="line-height: 26px;">    name:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">lagou-service-autodeliver</span><span><span class="hljs-attr" style="line-height: 26px;">  zipkin:</span><span><span class="hljs-attr" style="line-height: 26px;">    base-url:</span> <span class="hljs-attr" style="line-height: 26px;">http://127.0.0.1:9411/</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;"># zipkin server的请求地址</span><span><span class="hljs-attr" style="line-height: 26px;">    sender:</span><span><span class="hljs-attr" style="line-height: 26px;">      type:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">web</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;"># 请求方式,默认以http的方式向zipkin server发送追踪数据</span><span><span class="hljs-attr" style="line-height: 26px;">  sleuth:</span><span><span class="hljs-attr" style="line-height: 26px;">    sampler:</span><span>      <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;">#采样的百分比，默认为0.1，即10%，这里配置1，是记录全部 的sleuth信息，是为了收集到更多的数据（仅供测试用）。在分布式系统中，过于频繁的采样会影响系 统性能，所以这里配置需要采用一个合适的值。</span><span><span class="hljs-attr" style="line-height: 26px;">      probability:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">1.0</span><span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">对于log⽇志，依然保持开启debug状态</section></li></ul><hr data-tool="mdnice编辑器" style="height: 1px; margin: 0; margin-top: 10px; margin-bottom: 10px; border: none; border-top: 1px solid black;"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">Zipkin server ⻚⾯⽅便我们查看服务调⽤依赖关系及⼀些性能指标和异常信息</strong></p><hr data-tool="mdnice编辑器" style="height: 1px; margin: 0; margin-top: 10px; margin-bottom: 10px; border: none; border-top: 1px solid black;"><p data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black;"><strong style="font-weight: bold; color: black;">追踪数据Zipkin持久化到mysql</strong></p><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">mysql中创建名称为zipkin的数据库，并执⾏如下sql语句（github zipkin stronge 中提供）</section></li><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">pom.xml 引入依赖</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;">  <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>zipkin-autoconfigure-storagemysql<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span>      <span class="hljs-attr" style="color: #008080; line-height: 26px;">artifactId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>2.12.3<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>mysql<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span>1.1.10<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">version</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-tx<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span>org.springframework<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">groupId</span>&gt;</span><span>      <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span>spring-jdbc<span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">artifactId</span>&gt;</span><span>  <span class="hljs-tag" style="color: #000080; font-weight: normal; line-height: 26px;">&lt;/<span class="hljs-name" style="color: #000080; font-weight: normal; line-height: 26px;">dependency</span>&gt;</span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">application.yml</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-attr" style="line-height: 26px;">server:</span><span><span class="hljs-attr" style="line-height: 26px;">  port:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">9411</span><span><span class="hljs-attr" style="line-height: 26px;">management:</span><span><span class="hljs-attr" style="line-height: 26px;">  metrics:</span><span><span class="hljs-attr" style="line-height: 26px;">    web:</span><span><span class="hljs-attr" style="line-height: 26px;">      server:</span><span><span class="hljs-attr" style="line-height: 26px;">        auto-time-requests:</span> <span class="hljs-literal" style="color: #008080; line-height: 26px;">false</span> <span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;"># 关闭自动检测</span><span><span class="hljs-attr" style="line-height: 26px;">spring:</span><span><span class="hljs-attr" style="line-height: 26px;">  datasource:</span><span><span class="hljs-attr" style="line-height: 26px;">    driver-class-name:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">com.mysql.jdbc.Driver</span><span><span class="hljs-attr" style="line-height: 26px;">    url:</span> <span class="hljs-attr" style="line-height: 26px;">jdbc:mysql://localhost:3306/zipkin?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;allowMultiQueries=true</span><span><span class="hljs-attr" style="line-height: 26px;">    username:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">root</span><span><span class="hljs-attr" style="line-height: 26px;">    password:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">123456</span><span><span class="hljs-attr" style="line-height: 26px;">    druid:</span><span><span class="hljs-attr" style="line-height: 26px;">      initialSize:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">10</span><span><span class="hljs-attr" style="line-height: 26px;">      minIdle:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">10</span><span><span class="hljs-attr" style="line-height: 26px;">      maxActive:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">30</span><span><span class="hljs-attr" style="line-height: 26px;">      maxWait:</span> <span class="hljs-number" style="color: #008080; line-height: 26px;">50000</span><span><span class="hljs-comment" style="color: #998; font-style: italic; line-height: 26px;"># 指定zipkin持久化介质为mysql</span><span><span class="hljs-attr" style="line-height: 26px;">zipkin:</span><span><span class="hljs-attr" style="line-height: 26px;">  storage:</span><span><span class="hljs-attr" style="line-height: 26px;">    type:</span> <span class="hljs-string" style="color: #d14; line-height: 26px;">mysql</span><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre></div><ul data-tool="mdnice编辑器" style="margin-top: 8px; margin-bottom: 8px; padding-left: 25px; color: black; list-style-type: disc;"><li><section style="margin-top: 5px; margin-bottom: 5px; line-height: 26px; text-align: left; color: rgb(1,1,1); font-weight: 500;">启动类中注⼊事务管理器</section></li></ul><div class="hljs"><pre class="hljs custom" data-tool="mdnice编辑器" style="margin-top: 10px; margin-bottom: 10px; border-radius: 5px; box-shadow: rgba(0, 0, 0, 0.55) 0px 2px 10px;"><span style="display: block; background: url(https://imgkr.cn-bj.ufileos.com/97e4eed2-a992-4976-acf0-ccb6fb34d308.png); height: 30px; width: 100%; background-size: 40px; background-repeat: no-repeat; background-color: #f8f8f8; margin-bottom: -7px; border-radius: 5px; background-position: 10px 10px;"></span><code class="hljs" style="overflow-x: auto; padding: 16px; color: #333; display: block; font-family: Operator Mono, Consolas, Monaco, Menlo, monospace; font-size: 12px; -webkit-overflow-scrolling: touch; padding-top: 15px; background: #f8f8f8; border-radius: 5px;"><span class="hljs-meta" style="color: #999; font-weight: bold; line-height: 26px;">@Bean</span><span><span class="hljs-function" style="line-height: 26px;"><span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">public</span> PlatformTransactionManager <span class="hljs-title" style="color: #900; font-weight: bold; line-height: 26px;">txManager</span><span class="hljs-params" style="line-height: 26px;">(DataSource dataSource)</span> </span>{<span>  <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">return</span> <span class="hljs-keyword" style="color: #333; font-weight: bold; line-height: 26px;">new</span> DataSourceTransactionManager(dataSource);<span>}<span></span></span></span></span></code></pre></div><blockquote data-tool="mdnice编辑器" style="display: block; font-size: 0.9em; overflow: auto; overflow-scrolling: touch; border-left: 3px solid rgba(0, 0, 0, 0.4); color: #6a737d; padding-top: 10px; padding-bottom: 10px; padding-left: 20px; padding-right: 10px; margin-bottom: 20px; margin-top: 20px; border-left-color: rgb(239, 112, 96); background: #fff9f9;"><p style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0px; color: black; line-height: 26px;">lagouedu 笔记总结</p></blockquote><p id="nice-suffix-juejin-container" class="nice-suffix-juejin-container" data-tool="mdnice编辑器" style="font-size: 16px; padding-top: 8px; padding-bottom: 8px; margin: 0; line-height: 26px; color: black; margin-top: 20px !important;">本文使用 <a href="https://mdnice.com/?from=juejin" style="text-decoration: none; word-wrap: break-word; font-weight: bold; color: rgb(239, 112, 96); border-bottom: 1px solid rgb(239, 112, 96);" target="_blank" rel="noopener">mdnice</a> 排版</p></section>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 全家桶</title>
    <link href="/2020/07/28/Spring-Cloud-%E5%85%A8%E5%AE%B6%E6%A1%B6/"/>
    <url>/2020/07/28/Spring-Cloud-%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h2><h2 id="一、Eureka服务注册中⼼"><a href="#一、Eureka服务注册中⼼" class="headerlink" title="一、Eureka服务注册中⼼"></a>一、Eureka服务注册中⼼</h2><h3 id="1-关于服务注册中⼼"><a href="#1-关于服务注册中⼼" class="headerlink" title="1. 关于服务注册中⼼"></a>1. 关于服务注册中⼼</h3><p><strong>注意：服务注册中⼼本质上是为了解耦服务提供者和服务消费者。</strong></p><p>对于任何⼀个微服务，原则上都应存在或者⽀持多个提供者（⽐如简历微服务部署多个实例），这是由<br>微服务的分布式属性决定的。为了⽀持弹性扩缩容特性，原本在单体应⽤阶段常⽤的静态LB机制就不再适⽤了，引入额外的管理为服务提供者注册发现，而这个就是服务注册中心。</p><h4 id="1-1-服务注册中⼼⼀般原理"><a href="#1-1-服务注册中⼼⼀般原理" class="headerlink" title="1.1 服务注册中⼼⼀般原理"></a>1.1 服务注册中⼼⼀般原理</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/1736248d0d6a965d?w=1196&h=714&f=png&s=198074" srcset="/img/loading.gif" alt></p><p><strong>目前Eureka 支持pull 模式，即定时任务主动拉取。</strong></p><h4 id="1-2-主流服务中⼼对⽐"><a href="#1-2-主流服务中⼼对⽐" class="headerlink" title="1.2 主流服务中⼼对⽐"></a>1.2 主流服务中⼼对⽐</h4><ul><li><p>Zookeeper ：简单来说zookeeper本质=存储+监听通知。。另外，Zookeeper可⽤性也可以，因为只要半数以上的选举节点存活，整个集群就是可⽤的。根据半数原则，固有了集群最优节点个数是奇数（3），不是偶数（4），因为不论是3个节点还是4个节点，都是只允许一个节点服务不可用。容错率是一样的。</p></li><li><p>Eureka ： 由Netflix开源，并被Pivatal集成到SpringCloud体系中，它是基于 RestfulAPI ⻛格开发的服务注册<br>与发现组件。</p></li><li><p>Consul ：是由HashiCorp基于Go语⾔开发的⽀持多数据中⼼分布式⾼可⽤的服务发布和注册服务软<br>件， 采⽤Raft算法保证服务的⼀致性，且⽀持健康检查。</p></li><li><p>Nacos ： Nacos是⼀个更易于构建云原⽣应⽤的动态服务发现、配置管理和服务管理平台。简单来说 Nacos<br>就是 注册中⼼ + 配置中⼼的组合，帮助我们解决微服务开发必会涉及到的服务注册 与发现，服务<br>配置，服务管理等问题。Nacos 是 Spring Cloud Alibaba 核⼼组件之⼀，负责服务注册与发现，<br>还有配置。</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/1736268bc6058022?w=1354&h=386&f=png&s=138746" srcset="/img/loading.gif" alt></p><h3 id="2-Eureka"><a href="#2-Eureka" class="headerlink" title="2. Eureka"></a>2. Eureka</h3><ul><li>Eureka 基础架构</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/1736274000bba7d4?w=1308&h=462&f=png&s=175431" srcset="/img/loading.gif" alt></p><ul><li>Eureka 交互流程及原理</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/18/17362748ff002d72?w=1166&h=538&f=png&s=325066" srcset="/img/loading.gif" alt></p><p><strong>Eureka通过⼼跳检测、健康检查和客户端缓存等机制，提⾼系统的灵活性、可伸缩性和可⽤性。</strong></p><h3 id="3-Eureka应⽤及⾼可⽤集群"><a href="#3-Eureka应⽤及⾼可⽤集群" class="headerlink" title="3. Eureka应⽤及⾼可⽤集群"></a>3. Eureka应⽤及⾼可⽤集群</h3><h4 id="3-1-Eureka-Server-（单实例和集群）搭建注意细节"><a href="#3-1-Eureka-Server-（单实例和集群）搭建注意细节" class="headerlink" title="3.1 Eureka Server （单实例和集群）搭建注意细节"></a>3.1 Eureka Server （单实例和集群）搭建注意细节</h4><p>这里就不详细贴搭建erueka 的服务细节代码了，主要注意下搭建时候，父工程需要<strong>引⼊Jaxb以及cloud和boot两个依赖管理</strong>。如下：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zjn<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--引⼊Jaxb，开始--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun.xml.bind<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxb-runtime<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10-b140310.1920<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.activation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--引⼊Jaxb，结束--&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Greenwich.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-comment">&lt;!--编译插件--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>            <span class="hljs-comment">&lt;!--打包插件--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div><blockquote><p>小贴士：<em>搭建集群时候可以使用同一个yml文件拆分（只适合个人快捷搭建,方便测试，不适合生产环境），如下：</em></p></blockquote><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment">#Eureka server服务端⼝</span><span class="hljs-attr">spring:</span><span class="hljs-attr"> application:</span><span class="hljs-attr">  name:</span> <span class="hljs-string">zjn-cloud-eureka-server</span><span class="hljs-meta">---</span><span class="hljs-attr">spring:</span><span class="hljs-attr"> profiles:</span> <span class="hljs-string">ZjnCloudEurekaServerA</span><span class="hljs-attr">server:</span><span class="hljs-attr"> port:</span> <span class="hljs-number">8761</span><span class="hljs-attr">eureka:</span><span class="hljs-attr"> instance:</span><span class="hljs-attr">  hostname:</span> <span class="hljs-string">zjna</span><span class="hljs-attr"> client:</span><span class="hljs-attr">  service-url:</span><span class="hljs-attr">   defaultZone:</span> <span class="hljs-attr">http://zjnb:8762/eureka/</span><span class="hljs-attr">  register-with-eureka:</span> <span class="hljs-literal">true</span><span class="hljs-attr">  fetch-registry:</span> <span class="hljs-literal">true</span><span class="hljs-meta">---</span><span class="hljs-attr">spring:</span><span class="hljs-attr"> profiles:</span> <span class="hljs-string">ZjnCloudEurekaServerB</span><span class="hljs-attr">server:</span><span class="hljs-attr"> port:</span> <span class="hljs-number">8762</span><span class="hljs-attr">eureka:</span><span class="hljs-attr"> instance:</span><span class="hljs-attr">  hostname:</span> <span class="hljs-string">zjnb</span><span class="hljs-attr"> client:</span><span class="hljs-attr">  service-url:</span><span class="hljs-attr">   defaultZone:</span> <span class="hljs-attr">http://zjna:8761/eureka/</span><span class="hljs-attr">  register-with-eureka:</span> <span class="hljs-literal">true</span><span class="hljs-attr">  fetch-registry:</span> <span class="hljs-literal">true</span></code></pre></div><p>idea启动可设置active-profiles 指定启动文件</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/17364df7529140be?w=1199&h=525&f=png&s=67983" srcset="/img/loading.gif" alt></p><blockquote><p>注意：</p><ul><li>1）从Spring Cloud Edgware版本开始，@EnableDiscoveryClient 或 @EnableEurekaClient 可省<br>略。只需加 上相关依赖，并进⾏相应配置，即可将微服务注册到服务发现组件上。</li><li>2）@EnableDiscoveryClient和@EnableEurekaClient⼆者的功能是⼀样的。但是如果选⽤的是<br>eureka服务器，那么就推荐@EnableEurekaClient，如果是其他的注册中⼼，那么推荐使⽤<br>@EnableDiscoveryClient，考虑到通⽤性，后期我们可以使⽤@EnableDiscoveryClient</li></ul></blockquote><h4 id="3-2-Eureka-Client-搭建注意细节（单注册以及注册到server集群）"><a href="#3-2-Eureka-Client-搭建注意细节（单注册以及注册到server集群）" class="headerlink" title="3.2 Eureka Client 搭建注意细节（单注册以及注册到server集群）"></a>3.2 Eureka Client 搭建注意细节（单注册以及注册到server集群）</h4><ul><li><p>⽗⼯程中引⼊spring-cloud-commons依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-commons<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>client 引入 坐标</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>yml配置</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">9006</span><span class="hljs-attr">eureka:</span><span class="hljs-attr"> client:</span><span class="hljs-attr">  serviceUrl:</span> <span class="hljs-comment"># eureka server的路径</span><span class="hljs-attr">   defaultZone:</span> <span class="hljs-attr">http://zjna:8761/eureka/,http://zjnb:8762/eureka/</span> <span class="hljs-comment">#把 eureka 集群中的所有 url 都填写了进来，也可以只写⼀台，因为各个eureka server 可以同步注册表</span><span class="hljs-attr"> instance:</span>  <span class="hljs-comment">#使⽤ip注册，否则会使⽤主机名注册了（此处考虑到对⽼版本的兼容，新版本经过实验都是ip）</span><span class="hljs-attr">  prefer-ip-address:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment">#⾃定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress</span><span class="hljs-attr">  instance-id:</span> <span class="hljs-string">$&#123;spring.cloud.client.ipaddress&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span><span class="hljs-attr">spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">zjn-client</span></code></pre></div></li><li><p>启动类添加 @EnableDiscoveryClient</p></li><li><p>最后注意下要添加成web应用，不然不会一直运行,上面的instance-id 可自定义实例名称增加@project.version@版本号，进行客户端版本控制</p></li></ul><h3 id="4-Eureka细节详解"><a href="#4-Eureka细节详解" class="headerlink" title="4. Eureka细节详解"></a>4. Eureka细节详解</h3><h4 id="4-1-Eureka元数据详解"><a href="#4-1-Eureka元数据详解" class="headerlink" title="4.1 Eureka元数据详解"></a>4.1 Eureka元数据详解</h4><p>Eureka的元数据有两种：标准元数据和⾃定义元数据。</p><ul><li>标准元数据：主机名、IP地址、端⼝号等信息，这些信息都会被发布在服务注册表中，⽤于服务之间的<br>调⽤。</li><li>⾃定义元数据：可以使⽤eureka.instance.metadata-map配置，符合KEY/VALUE的存储格式。这 些元<br>数据可以在远程客户端中访问。</li></ul><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">instance:</span><span class="hljs-attr"> prefer-ip-address:</span> <span class="hljs-literal">true</span><span class="hljs-attr"> metadata-map:</span>  <span class="hljs-comment"># ⾃定义元数据(kv⾃定义)</span><span class="hljs-attr">  cluster:</span> <span class="hljs-string">cl1</span><span class="hljs-attr">  region:</span> <span class="hljs-string">rn1</span></code></pre></div><h4 id="4-2-Eureka服务端详解"><a href="#4-2-Eureka服务端详解" class="headerlink" title="4.2 Eureka服务端详解"></a>4.2 Eureka服务端详解</h4><ul><li>服务下线<ul><li>当服务正常关闭操作时，会发送服务下线的REST请求给EurekaServer。</li><li>服务中⼼接受到请求后，将该服务置为下线状态</li></ul></li><li>失效剔除<ul><li>Eureka Server会定时（间隔值是eureka.server.eviction-interval-timer-in-ms，默认60s）进⾏检查，<br>如果发现实例在在⼀定时间（此值由客户端设置的eureka.instance.lease-expiration-duration-inseconds<br>定义，默认值为90s）内没有收到⼼跳，则会注销此实例。</li></ul></li><li>自我保护<ul><li>定期的续约（服务提供者和注册中⼼通信），假如服务提供者和注册中⼼之间的⽹络有点问题，不代表<br>服务提供者不可⽤，不代表服务消费者⽆法访问服务提供者</li><li>如果在15分钟内超过85%的客户端节点都没有正常的⼼跳，那么Eureka就认为客户端与注册中⼼出现了<br>⽹络故障，Eureka Server⾃动进⼊⾃我保护机制。</li></ul></li></ul><p>当处于⾃我保护模式时</p><ul><li>1）不会剔除任何服务实例（可能是服务提供者和EurekaServer之间⽹络问题），保证了⼤多数服务依<br>然可⽤</li><li>2）Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节<br>点依然可⽤，当⽹络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。</li><li>3）在Eureka Server⼯程中通过eureka.server.enable-self-preservation配置可⽤关停⾃我保护，默认<br>值是打开</li></ul><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">eureka:</span><span class="hljs-attr">  server:</span><span class="hljs-attr">    enable-self-preservation:</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># 关闭⾃我保护模式（缺省为打开）</span></code></pre></div><h3 id="5-Eureka核⼼源码剖析"><a href="#5-Eureka核⼼源码剖析" class="headerlink" title="5. Eureka核⼼源码剖析"></a>5. Eureka核⼼源码剖析</h3><h4 id="5-1-Eureka-Server启动过程"><a href="#5-1-Eureka-Server启动过程" class="headerlink" title="5.1 Eureka Server启动过程"></a>5.1 Eureka Server启动过程</h4><ul><li>⼊⼝：SpringCloud充分利⽤了SpringBoot的⾃动装配的特点,使用了SPI机制，在boot启动时装载了EurekaServerAutoConfiguration⾃动配置类，如下：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173673e97fc0e2cd?w=1358&h=586&f=png&s=234990" srcset="/img/loading.gif" alt></p><ul><li>EurekaServerAutoConfiguration类  需要有⼀个marker bean，才能装配Eureka Server，那么这个marker其实是由@EnableEurekaServer注解决定<br>的,如下：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173675ff28a43c71?w=1366&h=352&f=png&s=246905" srcset="/img/loading.gif" alt></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/1736766e8d0539c8?w=1424&h=890&f=png&s=363493" srcset="/img/loading.gif" alt></p><p>也就是说只有添加了@EnableEurekaServer注解，才会有后续的动作，这是成为⼀个EurekaServer的前提</p><ul><li><p>重点关注EurekaServerAutoConfiguration，里面把仪表盘、对等节点注册器，封装对等节点的相关操作，如同时更新节点，<br><img src="https://user-gold-cdn.xitu.io/2020/7/19/173676b2ee63ead4?w=1344&h=884&f=png&s=614617" srcset="/img/loading.gif" alt></p></li><li><p>在com.netflix.eureka.cluster.PeerEurekaNodes#start⽅法中会构建线程池</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173677debaf26dcd?w=1404&h=902&f=png&s=349786" srcset="/img/loading.gif" alt></p><ul><li>回到主配置类中，eurekaServerContext 创建eurekaServer上下文</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173677e9328f5190?w=1376&h=302&f=png&s=179096" srcset="/img/loading.gif" alt></p><ul><li>进入到 eurekaServerContext 中，可以看到init方法，会启动上面更新对等节点的线程池start()方法。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173678087c4bf4c3?w=1344&h=918&f=png&s=404983" srcset="/img/loading.gif" alt></p><ul><li>回到主配置类中，看到 eurekaServerBootstrap 也注册成@Bean组件，如下：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/1736783201b707a7?w=1312&h=320&f=png&s=150923" srcset="/img/loading.gif" alt></p><ul><li>接着注册Jersey过滤器，如下：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/19/173678517812abc0?w=1376&h=536&f=png&s=265914" srcset="/img/loading.gif" alt></p><ul><li>重新进入到org.springframework.cloud.netflix.eureka.server.EurekaServerInitializerConfiguration</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a05b8535141c?w=1676&h=1064&f=png&s=480794" srcset="/img/loading.gif" alt></p><ul><li>进入org.springframework.cloud.netflix.eureka.server.EurekaServerBootstrap#contextInitialized</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a077f8462dd9?w=1574&h=584&f=png&s=258813" srcset="/img/loading.gif" alt></p><ul><li>重点关注initEurekaServerContext()</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a0aceade192c?w=1652&h=906&f=png&s=592132" srcset="/img/loading.gif" alt></p><ul><li>研究⼀下上图中的syncUp⽅法</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a213f5e64179?w=1552&h=888&f=png&s=408552" srcset="/img/loading.gif" alt></p><ul><li>研究⼀下上图中的syncUp⽅法<br>继续研究com.netflix.eureka.registry.AbstractInstanceRegistry#register（提供实例注册功能）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a244b237b636?w=1626&h=860&f=png&s=525432" srcset="/img/loading.gif" alt></p><ul><li>继续研究com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#openForTraffic</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a35073c915ac?w=1642&h=852&f=png&s=616557" srcset="/img/loading.gif" alt></p><ul><li>进⼊postInit()⽅法查看</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/20/1736a376535b6eb8?w=1496&h=648&f=png&s=421594" srcset="/img/loading.gif" alt></p><p>总结启动流程 ：</p><ol><li>用SPI机制自动启动时装载了EurekaServerAutoConfiguration⾃动配置类，标记，标记@EnableEurekaServer，可进行自动配置。</li><li>EurekaServerAutoConfiguration，里面把仪表盘、对等节点注册器，封装对等节点的相关操作，如同时更新节点</li><li>PeerEurekaNodes构建线程池，更新对等节点信息</li><li>eurekaServerContext#initiallize 启动PeerEurekaNodes中的线程。</li><li>构建eurekaServerBootstrap启动类</li><li>注册Jersey过滤器</li><li>初始化context，注册统计器</li><li>AbstractInstanceRegistry#register 实例注册到map</li><li>开启定时</li><li></li></ol><h4 id="5-2-Eureka-Server服务接⼝暴露策略"><a href="#5-2-Eureka-Server服务接⼝暴露策略" class="headerlink" title="5.2 Eureka Server服务接⼝暴露策略"></a>5.2 Eureka Server服务接⼝暴露策略</h4><ul><li>在Eureka Server启动过程中主配置类注册了Jersey框架（是⼀个发布restful⻛格接⼝的框架，类似于我<br>们的springmvc）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/1737188ac81161c3?w=1374&h=540&f=png&s=258078" srcset="/img/loading.gif" alt></p><ul><li>进入 Jersey</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/173718bc73b84f39?w=1382&h=1054&f=png&s=567144" srcset="/img/loading.gif" alt></p><ul><li>点击EUREKA_PACKAGES，发现扫包”com.netflix.discovery”, “com.netflix.eureka”</li><li>来到 com.netflix.eureka.resources.ApplicationResource#addInstance <strong>这里就是使⽤Jersey发布的供EurekaClient调⽤的Restful⻛格服务接⼝（完成服务注册、⼼跳续约等接⼝）</strong></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/173719aeb4b802e0?w=1382&h=734&f=png&s=276226" srcset="/img/loading.gif" alt></p><h4 id="5-3-Eureka-Server服务注册接⼝（接受客户端注册服务）"><a href="#5-3-Eureka-Server服务注册接⼝（接受客户端注册服务）" class="headerlink" title="5.3 Eureka Server服务注册接⼝（接受客户端注册服务）"></a>5.3 Eureka Server服务注册接⼝（接受客户端注册服务）</h4><ul><li>点进register 找到实现类 com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#register<br>注册服务信息并同步到其它Eureka节点</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/173719eceabf8c40?w=1342&h=288&f=png&s=198146" srcset="/img/loading.gif" alt></p><ul><li>点击super.register  来到 com.netflix.eureka.registry.AbstractInstanceRegistry#register，注册，实例信息存储到注册表是⼀个ConcurrentHashMap</li></ul><div class="hljs"><pre><code class="hljs java">Lease&lt;InstanceInfo&gt; existingLease = gMap.get(registrant.getId());</code></pre></div><ul><li>回到 com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateToPeers 复制到Eureka对等节点</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371a58ec6a5255?w=1346&h=1362&f=png&s=200992" srcset="/img/loading.gif" alt></p><ul><li>进入 com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateInstanceActionsToPeers</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371a63b181d74c?w=1360&h=826&f=png&s=355008" srcset="/img/loading.gif" alt></p><h4 id="5-4-Eureka-Server服务续约接⼝（接受客户端续约）"><a href="#5-4-Eureka-Server服务续约接⼝（接受客户端续约）" class="headerlink" title="5.4 Eureka Server服务续约接⼝（接受客户端续约）"></a>5.4 Eureka Server服务续约接⼝（接受客户端续约）</h4><ul><li>com.netflix.eureka.resources.InstanceResource#renewLease⽅法中完成客户端的⼼跳（续约）处理，关键代码：<br>registry.renew(app.getName(), id, isFromReplicaNode);</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371b570006930f?w=1388&h=626&f=png&s=290145" srcset="/img/loading.gif" alt></p><ul><li>com.netflix.eureka.registry.PeerAwareInstanceRegistryImpl#replicateToPeers#replicateInstanceActionsToPeers   复制Instance实例操作到其它节点</li></ul><p>总结： <strong>renew()⽅法中—&gt;leaseToRenew.renew()—&gt;对最后更新时间戳进⾏更新</strong></p><h4 id="5-5-Eureka-Client注册服务"><a href="#5-5-Eureka-Client注册服务" class="headerlink" title="5.5 Eureka Client注册服务"></a>5.5 Eureka Client注册服务</h4><ul><li>启动过程：Eureka客户端在启动时也会装载很多配置类，我们通过spring-cloud-netflix-eureka-client-</li></ul><p>2.1.0.RELEASE.jar下的spring.factories⽂件可以看到加载的配置类EurekaClientAutoConfiguration</p><ul><li>如果不想作为客户端，可以设置eureka.client.enabled=false</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371bf008566f62?w=1330&h=384&f=png&s=317917" srcset="/img/loading.gif" alt></p><ul><li>进入 org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371c01f0097a34?w=1358&h=382&f=png&s=235120" srcset="/img/loading.gif" alt></p><ul><li>client启动做的事：<ul><li>1）读取配置⽂件</li><li>2）启动时从EurekaServer获取服务实例信息</li><li>3）注册⾃⼰到EurekaServer（addInstance）</li><li>4）开启⼀些定时任务（⼼跳续约，刷新本地服务缓存列表）</li></ul></li></ul><h4 id="5-5-Eureka-Client下架服务"><a href="#5-5-Eureka-Client下架服务" class="headerlink" title="5.5 Eureka Client下架服务"></a>5.5 Eureka Client下架服务</h4><ul><li>com.netflix.discovery.DiscoveryClient#shutdown</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371dd7eb55bab4?w=1376&h=228&f=png&s=180496" srcset="/img/loading.gif" alt></p><ul><li>com.netflix.discovery.DiscoveryClient#unregister</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371de26697a9b7?w=1372&h=378&f=png&s=106740" srcset="/img/loading.gif" alt></p><hr><h2 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h2><h2 id="一、-负载均衡"><a href="#一、-负载均衡" class="headerlink" title="一、 负载均衡"></a>一、 负载均衡</h2><p>负载均衡⼀般分为服务器端负载均衡和客户端负载均衡</p><ul><li>服务器端负载均衡，⽐如Nginx、F5这些，请求到达服务器之后由这些负载均衡器根据⼀定的算法将请求路由到⽬标服务器处理。</li><li>谓客户端负载均衡，⽐如我们要说的Ribbon，服务消费者客户端会有⼀个服务器地址列表，调⽤⽅在请求前通过⼀定的负载均衡算法选择⼀个服务器进⾏访问，负载均衡算法的执⾏是在请求客户端进⾏。一般指微服务</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371e370c7806bd?w=1716&h=1324&f=png&s=645267" srcset="/img/loading.gif" alt></p><h2 id="二、Ribbon⾼级应⽤"><a href="#二、Ribbon⾼级应⽤" class="headerlink" title="二、Ribbon⾼级应⽤"></a>二、Ribbon⾼级应⽤</h2><ul><li><p>不需要引⼊额外的Jar坐标，因为在服务消费者中我们引⼊过eureka-client，它会引⼊Ribbon相关Jar</p></li><li><p>使用：</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-comment">// Ribbon负载均衡</span><span class="hljs-meta">@LoadBalanced</span><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">getRestTemplate</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();&#125;</code></pre></div><h2 id="三、Ribbon负载均衡策略"><a href="#三、Ribbon负载均衡策略" class="headerlink" title="三、Ribbon负载均衡策略"></a>三、Ribbon负载均衡策略</h2><ul><li>Ribbon内置了多种负载均衡策略，内部负责复杂均衡的顶级接⼝为 com.netflix.loadbalancer.IRule ，类树如下</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371e57165fdf12?w=1616&h=790&f=png&s=647967" srcset="/img/loading.gif" alt></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/21/17371e6683406e6d?w=1640&h=1360&f=png&s=517550" srcset="/img/loading.gif" alt></p><ul><li>修改负载均衡策略</li></ul><div class="hljs"><pre><code class="hljs xml">#针对的被调⽤⽅微服务名称,不加就是全局⽣效lagou-service-resume:  ribbon:    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule#负载策略调整</code></pre></div><h2 id="四、Ribbon核⼼源码剖析"><a href="#四、Ribbon核⼼源码剖析" class="headerlink" title="四、Ribbon核⼼源码剖析"></a>四、Ribbon核⼼源码剖析</h2><h3 id="1-Ribbon⼯作原理"><a href="#1-Ribbon⼯作原理" class="headerlink" title="1.Ribbon⼯作原理"></a>1.Ribbon⼯作原理</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/173756def1ba5205?w=1748&h=848&f=png&s=332194" srcset="/img/loading.gif" alt></p><p><strong>Ribbon给restTemplate添加了⼀个拦截器</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/173756f72e9f56ef?w=1672&h=890&f=png&s=179958" srcset="/img/loading.gif" alt></p><p>图中核⼼是负载均衡管理器LoadBalancer（总的协调者，相当于⼤脑，为了做事情，协调四肢），围绕它周围的多有IRule、IPing等</p><ul><li>IRule：是在选择实例的时候的负载均衡策略对象</li><li>IPing：是⽤来向服务发起⼼跳检测的，通过⼼跳检测来判断该服务是否可⽤</li><li>ServerListFilter：根据⼀些规则过滤传⼊的服务实例列表</li><li>ServerListUpdater：定义了⼀系列的对服务列表的更新操作</li></ul><h3 id="2-LoadBalanced源码剖析"><a href="#2-LoadBalanced源码剖析" class="headerlink" title="2. @LoadBalanced源码剖析"></a>2. @LoadBalanced源码剖析</h3><p>我们在RestTemplate实例上添加了⼀个@LoadBalanced注解，就可以实现负载均衡,现在来来分析这个注解背后的操作（负载均衡过程）</p><ul><li>点击@LoadBalanced注解</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375a7e533b7680?w=1634&h=550&f=png&s=278252" srcset="/img/loading.gif" alt></p><ul><li>SpringCloud充分利⽤了SpringBoot的⾃动装配特点，找spring.factories配置⽂件，进入org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375b3a6fcf36b9?w=1662&h=320&f=png&s=282438" srcset="/img/loading.gif" alt></p><ul><li>进入 org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration </li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375b4f4bd3f18d?w=1650&h=332&f=png&s=296387" srcset="/img/loading.gif" alt></p><ul><li>注⼊resttemplate对象到集合待⽤-&gt; @LoadBalanced @Autowired(required = false)</li><li>注⼊resttemplate定制器</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375b6732f9c7cd?w=1726&h=650&f=png&s=390596" srcset="/img/loading.gif" alt></p><ul><li>使⽤定制器给集合中的每⼀个resttemplate对象添加⼀个拦截器</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375b84dbd2b3a9?w=1724&h=484&f=png&s=282406" srcset="/img/loading.gif" alt></p><ul><li>到这⾥，我们明⽩，添加了注解的RestTemplate对象会被添加⼀个拦截器LoadBalancerInterceptor，该拦截器就是后续拦截请求进⾏负载处理的。<br>所以，下⼀步重点我们该分析拦截器LoadBalancerInterceptor——&gt;&gt;&gt;intercept()⽅法==========》》》》分析LoadBalancerInterceptor.intercept()⽅法</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375b9ad61d3a58?w=1670&h=326&f=png&s=264658" srcset="/img/loading.gif" alt></p><ul><li>最后执行在 org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient#execute </li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375c1c9f5caa36?w=1734&h=522&f=png&s=334858" srcset="/img/loading.gif" alt></p><ul><li>回到 org.springframework.cloud.netflix.ribbon.RibbonAutoConfiguration#springClientFactory 这里装配了RibbonClientConfiguration</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375d199df23153?w=1666&h=378&f=png&s=232207" srcset="/img/loading.gif" alt></p><ul><li>RibbonClientConfiguration中装配了⼤脑和肢⼲</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375d53bc345abd?w=1492&h=1062&f=png&s=539935" srcset="/img/loading.gif" alt></p><ul><li>com.netflix.loadbalancer.ZoneAwareLoadBalancer#chooseServer</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375da5264ef4a0?w=1432&h=502&f=png&s=188659" srcset="/img/loading.gif" alt></p><ul><li>来到区域隔离策略的⽗类choose⽅法中com.netflix.loadbalancer.PredicateBasedRule#choose</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375f68eacbddc7?w=1462&h=288&f=png&s=125060" srcset="/img/loading.gif" alt></p><ul><li>进入com.netflix.loadbalancer.AbstractServerPredicate#getEligibleServers()</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375f7b84b457a8?w=1478&h=400&f=png&s=172303" srcset="/img/loading.gif" alt></p><ul><li>进入com.netflix.loadbalancer.AbstractServerPredicate#incrementAndGetModulo</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17375f8f7b6f195a?w=1484&h=326&f=png&s=180583" srcset="/img/loading.gif" alt></p><ul><li>继续回到org.springframework.cloud.netflix.ribbon.RibbonLoadBalancerClient#execute()</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737610942e2f7f6?w=1480&h=846&f=png&s=452418" srcset="/img/loading.gif" alt></p><ul><li>AbstractClientHttpRequest#execute此处，就已经到了RestTemplate底层执⾏的代码了，由此也将验证最终请求的调⽤还是靠的RestTemplate</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/1737615d17548bb7?w=1500&h=554&f=png&s=284496" srcset="/img/loading.gif" alt></p><ul><li>接下来，在进⾏负载chooseServer的时候，LoadBalancer负载均衡器中已经有了serverList，那么这个<br>serverList是什么时候被注⼊到LoadBalancer中的，它的⼀个机制⼤概是怎样的？来到RibbonClientConfiguration</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bb995b6804e?w=1448&h=996&f=png&s=682445" srcset="/img/loading.gif" alt></p><ul><li>来到默认负载均衡策略 com.netflix.loadbalancer.ZoneAwareLoadBalancer</li><li>一直super点进进来 com.netflix.loadbalancer.DynamicServerListLoadBalancer#restOfInit</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bcbbc355154?w=1440&h=426&f=png&s=161246" srcset="/img/loading.gif" alt></p><ul><li>进⼊enableAndInitLearnNewServersFeature()⽅法,底层com.netflix.loadbalancer.DynamicServerListLoadBalancer#updateAllServerList也是CAS控制并发</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bd50f11dbda?w=1472&h=480&f=png&s=227040" srcset="/img/loading.gif" alt></p><ul><li>回到start()</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376bf29990e0ee?w=1526&h=928&f=png&s=471652" srcset="/img/loading.gif" alt></p><h3 id="3-RoundRobinRule轮询策略源码剖析"><a href="#3-RoundRobinRule轮询策略源码剖析" class="headerlink" title="3. RoundRobinRule轮询策略源码剖析"></a>3. RoundRobinRule轮询策略源码剖析</h3><ul><li>来到com.netflix.loadbalancer.RoundRobinRule#choose</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 负载均衡策略类核⼼⽅法</span><span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(ILoadBalancer lb, Object key)</span> </span>&#123;        <span class="hljs-keyword">if</span> (lb == <span class="hljs-keyword">null</span>) &#123;            log.warn(<span class="hljs-string">"no load balancer"</span>);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        Server server = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (server == <span class="hljs-keyword">null</span> &amp;&amp; count++ &lt; <span class="hljs-number">10</span>) &#123;             <span class="hljs-comment">// 所有可⽤服务实例列表</span>            List&lt;Server&gt; reachableServers = lb.getReachableServers();            <span class="hljs-comment">// 所有服务实例列表</span>            List&lt;Server&gt; allServers = lb.getAllServers();            <span class="hljs-keyword">int</span> upCount = reachableServers.size();            <span class="hljs-keyword">int</span> serverCount = allServers.size();            <span class="hljs-keyword">if</span> ((upCount == <span class="hljs-number">0</span>) || (serverCount == <span class="hljs-number">0</span>)) &#123;                log.warn(<span class="hljs-string">"No up servers available from load balancer: "</span> + lb);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-comment">// 获得⼀个轮询索引(CAS)</span>            <span class="hljs-keyword">int</span> nextServerIndex = incrementAndGetModulo(serverCount);            <span class="hljs-comment">// 根据索引取出服务实例对象</span>            server = allServers.get(nextServerIndex);            <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">/* Transient. */</span>                Thread.yield();                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">if</span> (server.isAlive() &amp;&amp; (server.isReadyToServe())) &#123;                <span class="hljs-keyword">return</span> (server);            &#125;            <span class="hljs-comment">// Next.</span>            server = <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (count &gt;= <span class="hljs-number">10</span>) &#123;            log.warn(<span class="hljs-string">"No available alive servers after 10 tries from load balancer: "</span>                    + lb);        &#125;        <span class="hljs-keyword">return</span> server;    &#125;</code></pre></div><h3 id="4-RandomRule随机策略源码剖析"><a href="#4-RandomRule随机策略源码剖析" class="headerlink" title="4. RandomRule随机策略源码剖析"></a>4. RandomRule随机策略源码剖析</h3><p>来到com.netflix.loadbalancer.RandomRule，跟轮训不一样就是没有循环10次就抛异常，无限循环随取，核心随机方法就是线程随机数如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376ce29162de8c?w=1332&h=736&f=png&s=136993" srcset="/img/loading.gif" alt><br><img src="https://user-gold-cdn.xitu.io/2020/7/22/17376ce08c1f6e99?w=1468&h=184&f=png&s=47310" srcset="/img/loading.gif" alt></p><hr><h2 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud Hystrix"></a>Spring Cloud Hystrix</h2><h2 id="一、微服务中的雪崩效应"><a href="#一、微服务中的雪崩效应" class="headerlink" title="一、微服务中的雪崩效应"></a>一、微服务中的雪崩效应</h2><p>在微服务架构中，⼀个应⽤可能会有多个微服务组成，微服务之间的数据交互通过远程过程调⽤完成。<br>这就带来⼀个问题，假设微服务A调⽤微服务B和微服务C，微服务B和微服务C⼜调⽤其它的微服务，这<br>就是所谓的“扇出”。如果扇出的链路上某个微服务的调⽤响应时间过⻓或者不可⽤，对微服务A的调⽤就<br>会占⽤越来越多的系统资源，进⽽引起系统崩溃，所谓的“雪崩效应”。</p><h2 id="二、雪崩效应解决⽅案"><a href="#二、雪崩效应解决⽅案" class="headerlink" title="二、雪崩效应解决⽅案"></a>二、雪崩效应解决⽅案</h2><ul><li>服务熔断：当扇出链路的某个微服务不可⽤或者响应时间太⻓时，熔断该节点微服务的调⽤，进⾏服务的降级，快速返回错误的响应信息。当检测到该节点微服务调⽤响应正常后，恢复调⽤链路。</li><li>服务降级：通俗讲就是整体资源不够⽤了，先将⼀些不关紧的服务停掉（调⽤我的时候，给你返回⼀个预留的值，也叫做兜底数据），待渡过难关⾼峰过去，再把那些服务打开。</li><li>服务限流 ：限流措施也很多，⽐如<ul><li>限制总并发数（⽐如数据库连接池、线程池）</li><li>限制瞬时并发数（如nginx限制瞬时并发连接数）</li><li>限制时间窗⼝内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）</li><li>限制远程接⼝调⽤速率、限制MQ的消费速率等</li></ul></li></ul><h2 id="三、Hystrix简介"><a href="#三、Hystrix简介" class="headerlink" title="三、Hystrix简介"></a>三、Hystrix简介</h2><p>Hystrix（豪猪—–&gt;刺），宣⾔“defend your app”是由Netflix开源的⼀个延迟和容错库，⽤于隔离访问远程系统、服务或者第三⽅库，防⽌级联失败，从⽽提升系统的可⽤性与容错性。Hystrix主要通过以下⼏点实现延迟和容错。</p><ul><li>包裹请求：使⽤HystrixCommand包裹对依赖的调⽤逻辑。 ⾃动投递微服务⽅法<br>（@HystrixCommand 添加Hystrix控制）  </li><li>跳闸机制：当某服务的错误率超过⼀定的阈值时，Hystrix可以跳闸，停⽌请求该服务⼀段时间。</li><li>资源隔离：Hystrix为每个依赖都维护了⼀个⼩型的线程池(舱壁模式)（或者信号量）。如果该线程池已满，发往该依赖的请求就被⽴即拒绝，⽽不是排队等待，从⽽加速失败判定。</li><li>监控：Hystrix可以近乎实时地监控运⾏指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。</li><li>回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执⾏回退逻辑。回退逻辑由开发⼈员⾃⾏提供，例如返回⼀个缺省值。</li><li>⾃我修复：断路器打开⼀段时间后，会⾃动进⼊“半开”状态。</li></ul><h2 id="四、Hystrix熔断应⽤"><a href="#四、Hystrix熔断应⽤" class="headerlink" title="四、Hystrix熔断应⽤"></a>四、Hystrix熔断应⽤</h2><p>⽬的：简历微服务⻓时间没有响应，服务消费者—&gt;目标微服务快速失败给⽤户提示</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737aa7a16ceab4b?w=1378&h=752&f=png&s=236791" srcset="/img/loading.gif" alt></p><ul><li>服务消费者⼯程（⾃动投递微服务）中引⼊Hystrix依赖坐标（也可以添加在⽗⼯程中）</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--熔断器Hystrix--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>服务消费者⼯程（⾃动投递微服务）的启动类中添加熔断器开启注解</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">@EnableDiscoveryClient</span><span class="hljs-comment">// 开启服务发现</span><span class="hljs-variable">@EnableCircuitBreaker</span> <span class="hljs-comment">// 开启熔断</span></code></pre></div><ul><li><p>定义服务降级处理⽅法，并在业务⽅法上使⽤@HystrixCommand的fallbackMethod属性关联到<br>服务降级处理⽅法</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**    * 提供者模拟处理超时，调用方法添加Hystrix控制    * <span class="hljs-doctag">@param</span> userId    * <span class="hljs-doctag">@return</span>    */</span>   <span class="hljs-comment">// 使用@HystrixCommand注解进行熔断控制</span>   <span class="hljs-meta">@HystrixCommand</span>(           <span class="hljs-comment">// 线程池标识，要保持唯一，不唯一的话就共用了</span>           threadPoolKey = <span class="hljs-string">"findResumeOpenStateTimeout"</span>,           <span class="hljs-comment">// 线程池细节属性配置</span>           threadPoolProperties = &#123;                   <span class="hljs-meta">@HystrixProperty</span>(name=<span class="hljs-string">"coreSize"</span>,value = <span class="hljs-string">"1"</span>), <span class="hljs-comment">// 线程数</span>                   <span class="hljs-meta">@HystrixProperty</span>(name=<span class="hljs-string">"maxQueueSize"</span>,value=<span class="hljs-string">"20"</span>) <span class="hljs-comment">// 等待队列长度</span>           &#125;,           <span class="hljs-comment">// commandProperties熔断的一些细节属性配置</span>           commandProperties = &#123;                   <span class="hljs-comment">// 每一个属性都是一个HystrixProperty</span>                   <span class="hljs-meta">@HystrixProperty</span>(name=<span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="hljs-string">"2000"</span>)           &#125;   )   <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/checkStateTimeout/&#123;userId&#125;"</span>)   <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">findResumeOpenStateTimeout</span><span class="hljs-params">(@PathVariable Long userId)</span> </span>&#123;       <span class="hljs-comment">// 使用ribbon不需要我们自己获取服务实例然后选择一个那么去访问了（自己的负载均衡）</span>       String url = <span class="hljs-string">"http://zjn-service-resume/resume/openstate/"</span> + userId;  <span class="hljs-comment">// 指定服务名</span>       Integer forObject = restTemplate.getForObject(url, Integer.class);       <span class="hljs-keyword">return</span> forObject;   &#125;</code></pre></div></li><li><p>注意 : 降级（兜底）⽅法必须和被降级⽅法相同的⽅法签名（相同参数列表、相同返回值）</p></li><li><p>可以在类上使⽤@DefaultProperties注解统⼀指定整个类中共⽤的降级（兜底）⽅法</p></li><li><p>服务提供者端模拟请求超时（线程休眠3s），只修改8080实例，8081不修改，对<br>⽐观察</p></li></ul><h2 id="五、Hystrix舱壁模式（线程池隔离策略）"><a href="#五、Hystrix舱壁模式（线程池隔离策略）" class="headerlink" title="五、Hystrix舱壁模式（线程池隔离策略）"></a>五、Hystrix舱壁模式（线程池隔离策略）</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737baf47021d899?w=1322&h=960&f=png&s=331037" srcset="/img/loading.gif" alt></p><p>如果不进⾏任何设置，所有熔断⽅法使⽤⼀个Hystrix线程池（10个线程），那么这样的话会导致问<br>题，这个问题并不是扇出链路微服务不可⽤导致的，⽽是我们的线程机制导致的，如果⽅法A的请求把<br>10个线程都⽤了，⽅法2请求处理的时候压根都没法去访问B，因为没有线程可⽤，并不是B服务不可<br>⽤。</p><p>舱壁模式如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bb15a1cd2cf4?w=1068&h=1384&f=png&s=242313" srcset="/img/loading.gif" alt></p><p>为了避免问题服务请求过多导致正常服务⽆法访问，Hystrix 不是采⽤增加线程数，⽽是单独的为每⼀<br>个控制⽅法创建⼀个线程池的⽅式，这种模式叫做“舱壁模式”，也是线程隔离的⼿段。</p><ul><li>我们可以使⽤⼀些⼿段查看线程情况：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bb238176cff2?w=1520&h=1238&f=png&s=837545" srcset="/img/loading.gif" alt></p><p>把默认Hystrix修改舱壁模式程序：</p><p>在每个方法上定义 独自的 线程标识，如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">@HystrixCommand</span>(            <span class="hljs-comment">// 线程池标识，要保持唯一，不唯一的话就共用了</span>            threadPoolKey = <span class="hljs-string">"findResumeOpenStateTimeout"</span>,            <span class="hljs-comment">// 线程池细节属性配置</span>            threadPoolProperties = &#123;                    <span class="hljs-variable">@HystrixProperty</span>(name=<span class="hljs-string">"coreSize"</span>,value = <span class="hljs-string">"1"</span>), <span class="hljs-comment">// 线程数</span>                    <span class="hljs-variable">@HystrixProperty</span>(name=<span class="hljs-string">"maxQueueSize"</span>,value=<span class="hljs-string">"20"</span>) <span class="hljs-comment">// 等待队列长度</span>            &#125;,            <span class="hljs-comment">// commandProperties熔断的一些细节属性配置</span>            commandProperties = &#123;                    <span class="hljs-comment">// 每一个属性都是一个HystrixProperty</span>                    <span class="hljs-variable">@HystrixProperty</span>(name=<span class="hljs-string">"execution.isolation.thread.timeoutInMilliseconds"</span>,value=<span class="hljs-string">"2000"</span>)            &#125;</code></pre></div><p>通过jstack命令查看线程情况，和我们程序设置相符合</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bb5cbb2308c8?w=1506&h=484&f=png&s=194077" srcset="/img/loading.gif" alt></p><h2 id="六、Hystrix⼯作流程与⾼级应⽤"><a href="#六、Hystrix⼯作流程与⾼级应⽤" class="headerlink" title="六、Hystrix⼯作流程与⾼级应⽤"></a>六、Hystrix⼯作流程与⾼级应⽤</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bb64aef1932e?w=1494&h=862&f=png&s=226278" srcset="/img/loading.gif" alt></p><ol><li>当调⽤出现问题时，开启⼀个时间窗（10s）</li><li>在这个时间窗内，统计调⽤次数是否达到最⼩请求数？<br>如果没有达到，则重置统计信息，回到第1步<br>如果达到了，则统计失败的请求数占所有请求数的百分⽐，是否达到阈值？<br>如果达到，则跳闸（不再请求对应服务）<br>如果没有达到，则重置统计信息，回到第1步</li><li>如果跳闸，则会开启⼀个活动窗⼝（默认5s），每隔5s，Hystrix会让⼀个请求通过,到达那个问题服<br>务，看 是否调⽤成功，如果成功，重置断路器回到第1步，如果失败，回到第3步</li></ol><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">/*** 8秒钟内，请求次数达到2个，并且失败率在50%以上，就跳闸* 跳闸后活动窗⼝设置为3s*/</span><span class="hljs-variable">@HystrixCommand</span>(commandProperties = &#123;<span class="hljs-variable">@HystrixProperty</span>(name =<span class="hljs-string">"metrics.rollingStats.timeInMilliseconds"</span>,value = <span class="hljs-string">"8000"</span>),<span class="hljs-variable">@HystrixProperty</span>(name =<span class="hljs-string">"circuitBreaker.requestVolumeThreshold"</span>,value = <span class="hljs-string">"2"</span>),<span class="hljs-variable">@HystrixProperty</span>(name =<span class="hljs-string">"circuitBreaker.errorThresholdPercentage"</span>,value = <span class="hljs-string">"50"</span>),<span class="hljs-variable">@HystrixProperty</span>(name =<span class="hljs-string">"circuitBreaker.sleepWindowInMilliseconds"</span>,value = <span class="hljs-string">"3000"</span>)&#125;)</code></pre></div><p>我们上述通过注解进⾏的配置也可以配置在配置⽂件中</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment"># 配置熔断策略：</span><span class="hljs-attr">hystrix:</span><span class="hljs-attr">  command:</span><span class="hljs-attr">    default:</span><span class="hljs-attr">      circuitBreaker:</span>      <span class="hljs-comment"># 强制打开熔断器，如果该属性设置为true，强制断路器进⼊打开状态，将会拒绝所有的请求。 默认false关闭的</span><span class="hljs-attr">       forceOpen:</span> <span class="hljs-literal">false</span>      <span class="hljs-comment"># 触发熔断错误⽐例阈值，默认值50%</span><span class="hljs-attr">      errorThresholdPercentage:</span> <span class="hljs-number">50</span>      <span class="hljs-comment"># 熔断后休眠时⻓，默认值5秒</span><span class="hljs-attr">      sleepWindowInMilliseconds:</span> <span class="hljs-number">3000</span>      <span class="hljs-comment"># 熔断触发最⼩请求次数，默认值是20</span><span class="hljs-attr">      requestVolumeThreshold:</span> <span class="hljs-number">2</span><span class="hljs-attr">    execution:</span><span class="hljs-attr">      isolation:</span><span class="hljs-attr">        thread:</span>           <span class="hljs-comment"># 熔断超时设置，默认为1秒</span><span class="hljs-attr">           timeoutInMilliseconds:</span> <span class="hljs-number">2000</span></code></pre></div><ul><li>基于springboot的健康检查观察跳闸状态（⾃动投递微服务暴露健康检查细节）</li></ul><div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># springboot中暴露健康检查等断点接⼝</span><span class="hljs-attr">management:</span><span class="hljs-attr">  endpoints:</span><span class="hljs-attr">    web:</span><span class="hljs-attr">      exposure:</span><span class="hljs-attr">        include:</span> <span class="hljs-string">"*"</span>  <span class="hljs-comment"># 暴露健康接⼝的细节</span><span class="hljs-attr">  endpoint:</span><span class="hljs-attr">    health:</span><span class="hljs-attr">      show-details:</span> <span class="hljs-string">always</span></code></pre></div><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bc006b72723b?w=1370&h=1108&f=png&s=369689" srcset="/img/loading.gif" alt></p><h2 id="七、Hystrix-Dashboard断路监控仪表盘"><a href="#七、Hystrix-Dashboard断路监控仪表盘" class="headerlink" title="七、Hystrix Dashboard断路监控仪表盘"></a>七、Hystrix Dashboard断路监控仪表盘</h2><p>正常状态是UP，跳闸是⼀种状态CIRCUIT_OPEN，可以通过/health查看，前提是⼯程中需要引⼊<br>SpringBoot的actuator（健康监控），它提供了很多监控所需的接⼝，可以对应⽤系统进⾏配置查看、<br>相关功能统计等。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>如果我们想看到Hystrix相关数据，⽐如有多少请求、多少成功、多少失败、多少降级等，那么引⼊<br>SpringBoot健康监控之后，访问/actuator/hystrix.stream接⼝可以获取到监控的⽂字信息，但是不直<br>观，所以Hystrix官⽅还提供了基于图形化的DashBoard（仪表板）监控平 台。Hystrix仪表板可以显示<br>每个断路器（被@HystrixCommand注解的⽅法）的状态。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bc17e5c48b81?w=1468&h=586&f=png&s=415296" srcset="/img/loading.gif" alt></p><ol><li>新建⼀个监控服务⼯程，导⼊依赖</li></ol><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--hystrix--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--hystrix 仪表盘--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol start="2"><li>启动类添加@EnableHystrixDashboard激活仪表盘 @EnableHystrixDashboard , 开启hystrix dashboard,配置yml</li></ol><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">9000</span><span class="hljs-attr">Spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">zjn-cloud-hystrix-dashboard</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">  client:</span><span class="hljs-attr">    serviceUrl:</span> <span class="hljs-comment"># eureka server的路径</span><span class="hljs-attr">      defaultZone:</span> <span class="hljs-attr">http://zjna:8761/eureka/,http://zjnb:8762/eureka/</span> <span class="hljs-comment">#把 eureka 集群中的所有 url 都填写了进来，也可以只写一台，因为各个 eureka server 可以同步注册表</span><span class="hljs-attr">  instance:</span>    <span class="hljs-comment">#使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip）</span><span class="hljs-attr">    prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress</span><span class="hljs-attr">    instance-id:</span> <span class="hljs-string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span></code></pre></div><p>3 .在被监测的微服务中注册监控servlet（⾃动投递微服务，监控数据就是来⾃于这个微服务）</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">/**     * 在被监控的微服务中注册一个serlvet，后期我们就是通过访问这个servlet来获取该服务的Hystrix监控数据的     * 前提：被监控的微服务需要引入springboot的actuator功能     * <span class="hljs-doctag">@return</span>     */</span>    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">getServlet</span><span class="hljs-params">()</span></span>&#123;        HystrixMetricsStreamServlet streamServlet = <span class="hljs-keyword">new</span> HystrixMetricsStreamServlet();        ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean(streamServlet);        registrationBean.setLoadOnStartup(<span class="hljs-number">1</span>);        registrationBean.addUrlMappings(<span class="hljs-string">"/actuator/hystrix.stream"</span>);        registrationBean.setName(<span class="hljs-string">"HystrixMetricsStreamServlet"</span>);        <span class="hljs-keyword">return</span> registrationBean;    &#125;</code></pre></div><ol start="4"><li>访问测试<a href="http://localhost:9000/hystrix" target="_blank" rel="noopener">http://localhost:9000/hystrix</a></li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bcd7599e9560?w=1446&h=872&f=png&s=422649" srcset="/img/loading.gif" alt></p><ol start="5"><li>输入监控目标</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bcf691e6954a?w=1596&h=394&f=png&s=124372" srcset="/img/loading.gif" alt></p><ul><li>百分⽐，10s内错误请求百分⽐</li><li>实⼼圆⼤⼩：代表请求流量的⼤⼩，流量越⼤球越⼤</li><li>颜⾊：代表请求处理的健康状态，从绿⾊到红⾊递减，绿⾊代表健康，红⾊就代表很不健康</li><li>曲线波动图：<br>记录了2分钟内该⽅法上流量的变化波动图，判断流量上升或者下降的趋势</li></ul><h2 id="八、-Hystrix-Turbine聚合监控"><a href="#八、-Hystrix-Turbine聚合监控" class="headerlink" title="八、 Hystrix Turbine聚合监控"></a>八、 Hystrix Turbine聚合监控</h2><p>之前，我们针对的是⼀个微服务实例的Hystrix数据查询分析，在微服务架构下，⼀个微服务的实例往往<br>是多个（集群化）</p><div class="hljs"><pre><code>实例1(hystrix) ip1:port1/actuator/hystrix.stream实例2(hystrix) ip2:port2/actuator/hystrix.stream实例3(hystrix) ip3:port3/actuator/hystrix.stream</code></pre></div><p>按照已有的⽅法，我们就可以结合dashboard仪表盘每次输⼊⼀个监控数据流url，进去查看。⼿⼯操作能否被⾃动功能替代？Hystrix Turbine聚合（聚合各个实例上的hystrix监控数据）监控<br>Turbine（涡轮）</p><p>思考：微服务架构下，⼀个微服务往往部署多个实例，如果每次只能查看单个实例的监控，就需要经常<br>切换很不⽅便，在这样的场景下，我们可以使⽤ Hystrix Turbine 进⾏聚合监控，它可以把相关微服务<br>的监控数据聚合在⼀起，便于查看。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bd248f1559ee?w=1496&h=542&f=png&s=72237" srcset="/img/loading.gif" alt></p><ul><li>Turbine服务搭建</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-comment">&lt;!--hystrix turbine聚合监控--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-comment">&lt;!--            引入eureka客户端的两个原因            1、老师说过，微服务架构下的服务都尽量注册到服务中心去，便于统一管理            2、后续在当前turbine项目中我们需要配置turbine聚合的服务，比如，我们希望聚合               zjn-service-autodeliver这个服务的各个实例的hystrix数据流，那随后               我们就需要在application.yml文件中配置这个服务名，那么turbine获取服务下具体实例的数据流的               时候需要ip和端口等实例信息，那么怎么根据服务名称获取到这些信息呢？                  当然可以从eureka服务注册中心获取        --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div><ul><li><p>将需要进⾏Hystrix监控的多个微服务配置起来，在⼯程application.yml中开启Turbine及进⾏相关配置</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">9001</span><span class="hljs-attr">Spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">lagou-cloud-hystrix-turbine</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">  client:</span><span class="hljs-attr">    serviceUrl:</span> <span class="hljs-comment"># eureka server的路径</span><span class="hljs-attr">      defaultZone:</span> <span class="hljs-attr">http://lagoucloudeurekaservera:8761/eureka/,http://lagoucloudeurekaserverb:8762/eureka/</span> <span class="hljs-comment">#把 eureka 集群中的所有 url 都填写了进来，也可以只写一台，因为各个 eureka server 可以同步注册表</span><span class="hljs-attr">  instance:</span>    <span class="hljs-comment">#使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip）</span><span class="hljs-attr">    prefer-ip-address:</span> <span class="hljs-literal">true</span>    <span class="hljs-comment">#自定义实例显示格式，加上版本号，便于多版本管理，注意是ip-address，早期版本是ipAddress</span><span class="hljs-attr">    instance-id:</span> <span class="hljs-string">$&#123;spring.cloud.client.ip-address&#125;:$&#123;spring.application.name&#125;:$&#123;server.port&#125;:@project.version@</span><span class="hljs-comment">#turbine配置</span><span class="hljs-attr">turbine:</span>  <span class="hljs-comment"># appCofing配置需要聚合的服务名称，比如这里聚合自动投递微服务的hystrix监控数据</span>  <span class="hljs-comment"># 如果要聚合多个微服务的监控数据，那么可以使用英文逗号拼接，比如 a,b,c</span><span class="hljs-attr">  appConfig:</span> <span class="hljs-string">lagou-service-autodeliver</span><span class="hljs-attr">  clusterNameExpression:</span> <span class="hljs-string">"'default'"</span>   <span class="hljs-comment"># 集群默认名称</span></code></pre></div></li><li><p>在当前项⽬启动类上添加注解@EnableTurbine，开启仪表盘以及Turbine聚合</p></li><li><p>浏览器访问Turbine项⽬，<a href="http://localhost:9001/turbine.stream，就可以看到监控数据了" target="_blank" rel="noopener">http://localhost:9001/turbine.stream，就可以看到监控数据了</a></p></li><li><p>通过dashboard的⻚⾯查看数据更直观，把刚才的地址输⼊dashboard地址栏</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737bdf16ba35798?w=1558&h=944&f=png&s=443750" srcset="/img/loading.gif" alt></p><h2 id="八、-Hystrix核⼼源码剖析"><a href="#八、-Hystrix核⼼源码剖析" class="headerlink" title="八、 Hystrix核⼼源码剖析"></a>八、 Hystrix核⼼源码剖析</h2><p>springboot装配、⾯向切⾯编程、RxJava响应式编程的知识等等，我们剖析下主体脉络。<br>分析⼊⼝：@EnableCircuitBreaker注解激活了熔断功能，那么该注解就是Hystrix源码追踪的⼊⼝.</p><ul><li>@EnableCircuitBreaker注解激活熔断器</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/23/1737be2ce9564391?w=1382&h=512&f=png&s=242137" srcset="/img/loading.gif" alt></p><ul><li><p>查看EnableCircuitBreakerImportSelector类</p></li><li><p>最终也是 走的boot 自动装配</p></li><li><p>会注⼊org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration</p></li><li><p>关注切⾯：com.netflix.hystrix.contrib.javanica.aop.aspectj.HystrixCommandAspect</p></li><li><p>重点分析环绕通知⽅法</p></li><li><p>最终走到GenericCommand⽅法中根据元数据信息等重写了run#execute⽅法（对⽬标⽅法的调⽤），getFallback⽅法（对回退⽅法的调⽤），在RxJava处理过程中会完成对这两个⽅法的调⽤。</p></li></ul><p>时间紧张，就写了个大致流程… 后续再补</p><hr><h2 id="Spring-Cloud-Feign"><a href="#Spring-Cloud-Feign" class="headerlink" title="Spring Cloud Feign"></a>Spring Cloud Feign</h2><h2 id="一、Feign简介"><a href="#一、Feign简介" class="headerlink" title="一、Feign简介"></a>一、Feign简介</h2><p>Feign是Netflix开发的⼀个轻量级RESTful的HTTP服务客户端（⽤它来发起请求，远程调⽤的），是以Java接⼝注解的⽅式调⽤Http请求，⽽不⽤像Java中通过封装HTTP请求报⽂的⽅式直接调⽤，Feign被⼴泛应⽤在Spring Cloud 的解决⽅案中。<br>类似于Dubbo，服务消费者拿到服务提供者的接⼝，然后像调⽤本地接⼝⽅法⼀样去调⽤，实际发出的是远程的请求。</p><p><strong>常规的RestTemplate请求存在拼接url restTmplate.getForObJect比较模版化，硬编码等不便之处。</strong></p><ul><li>Feign可帮助我们更加便捷，优雅的调⽤HTTP API：不需要我们去拼接url然后呢调⽤<br>restTemplate的api，在SpringCloud中，使⽤Feign⾮常简单，创建⼀个接⼝（在消费者–服务调⽤⽅这⼀端），并在接⼝上添加⼀些注解，代码就完成了</li><li>SpringCloud对Feign进⾏了增强，使Feign⽀持了SpringMVC注解（OpenFeign）</li></ul><p>本质：封装了Http调⽤流程，更符合⾯向接⼝化的编程习惯，类似于Dubbo的服务调⽤<br>Dubbo的调⽤⽅式其实就是很好的⾯向接⼝编程</p><h2 id="二、-Feign配置应⽤"><a href="#二、-Feign配置应⽤" class="headerlink" title="二、 Feign配置应⽤"></a>二、 Feign配置应⽤</h2><p>Feign = RestTemplate+Ribbon+Hystrix</p><ul><li><p>消费者引⼊Feign依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>消费者启动类使⽤注解@EnableFeignClients添加Feign⽀持 @EnableFeignClients,<strong>注意：此时去掉Hystrix熔断的⽀持注解@EnableCircuitBreaker即可包括引⼊的依赖，因为Feign会⾃动引⼊</strong></p></li><li><p>创建Feign接⼝</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// name：调⽤的服务名称，和服务提供者yml⽂件中spring.application.name保持⼀致</span><span class="hljs-meta">@FeignClient</span>(name=<span class="hljs-string">"lagou-service-resume"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResumeFeignClient</span> </span>&#123;<span class="hljs-comment">//调⽤的请求路径</span><span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/resume/openstate/&#123;userId&#125;"</span>,method=RequestMethod.GET)    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">findResumeOpenState</span><span class="hljs-params">(@PathVariable(value = <span class="hljs-string">"userId"</span>)</span>Long userId)</span>;&#125;</code></pre></div></li></ul><p><strong>注意：</strong></p><ol><li>@FeignClient注解的name属性⽤于指定要调⽤的服务提供者名称，和服务提供者yml⽂件中<br>spring.application.name保持⼀致</li><li>接⼝中的接⼝⽅法，就好⽐是远程服务提供者Controller中的Hander⽅法（只不过如同本地调⽤了），那么在进⾏参数绑定的时，可以使⽤@PathVariable、@RequestParam、@RequestHeader等，这也是OpenFeign对SpringMVC注解的⽀持，但是需要注意value必须设置，否则会抛出异常</li></ol><ul><li>使⽤接⼝中⽅法完成远程调⽤</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> ResumeFeignClient resumeFeignClient;<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFeignClient</span><span class="hljs-params">()</span></span>&#123;    Integer resumeOpenState =    resumeFeignClient.findResumeOpenState(<span class="hljs-number">1545132l</span>);    System.out.println(<span class="hljs-string">"=======&gt;&gt;&gt;resumeOpenState："</span> + resumeOpenState);&#125;</code></pre></div><h2 id="三、Feign对负载均衡的⽀持"><a href="#三、Feign对负载均衡的⽀持" class="headerlink" title="三、Feign对负载均衡的⽀持"></a>三、Feign对负载均衡的⽀持</h2><p>Feign 本身已经集成了Ribbon依赖和⾃动配置，因此我们不需要额外引⼊依赖，可以通过 ribbon.xx 来进 ⾏全局配置,也可以通过服务名.ribbon.xx 来对指定服务进⾏细节配置配置（参考之前，此处略）<br><strong>Feign默认的请求处理超时时⻓1s</strong>，有时候我们的业务确实执⾏的需要⼀定时间，那么这个时候，我们就需要调整请求处理超时时⻓，<strong>Feign⾃⼰有超时设置，如果配置Ribbon的超时，则会以Ribbon的为准</strong></p><ul><li>Ribbon设置<div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment">#针对的被调⽤⽅微服务名称,不加就是全局⽣效</span><span class="hljs-attr">lagou-service-resume:</span><span class="hljs-attr">    ribbon:</span>        <span class="hljs-comment">#请求连接超时时间</span>        <span class="hljs-comment">#ConnectTimeout: 2000</span>        <span class="hljs-comment">#请求处理超时时间</span>        <span class="hljs-comment">#ReadTimeout: 5000</span>        <span class="hljs-comment">#对所有操作都进⾏重试</span><span class="hljs-attr">        OkToRetryOnAllOperations:</span> <span class="hljs-literal">true</span>        <span class="hljs-comment">####根据如上配置，当访问到故障请求的时候，它会再尝试访问⼀次当前实例（次数由</span>        <span class="hljs-string">MaxAutoRetries配置），</span>        <span class="hljs-comment">####如果不⾏，就换⼀个实例进⾏访问，如果还不⾏，再换⼀次实例访问（更换次数由</span>        <span class="hljs-string">MaxAutoRetriesNextServer配置），</span>        <span class="hljs-comment">####如果依然不⾏，返回失败信息。</span><span class="hljs-attr">        MaxAutoRetries:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#对当前选中实例重试次数，不包括第⼀次调⽤</span><span class="hljs-attr">        MaxAutoRetriesNextServer:</span> <span class="hljs-number">0</span> <span class="hljs-comment">#切换实例的重试次数</span><span class="hljs-attr">        NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.netflix.loadbalancer.RoundRobinRule</span> <span class="hljs-comment">#负载</span>        <span class="hljs-string">策略调整</span></code></pre></div></li></ul><h2 id="四、Feign对熔断器的⽀持"><a href="#四、Feign对熔断器的⽀持" class="headerlink" title="四、Feign对熔断器的⽀持"></a>四、Feign对熔断器的⽀持</h2><ul><li>在Feign客户端⼯程配置⽂件（application.yml）中开启Feign对熔断器的⽀持<div class="hljs"><pre><code class="hljs yml"><span class="hljs-comment"># 开启Feign的熔断功能</span><span class="hljs-attr">feign:</span><span class="hljs-attr">  hystrix:</span><span class="hljs-attr">   enabled:</span> <span class="hljs-literal">true</span></code></pre></div></li></ul><p><strong>注意：</strong></p><ol><li>开启Hystrix之后，Feign中的⽅法都会被进⾏⼀个管理了，⼀旦出现问题就进⼊对应的回退逻辑处理</li><li>针对超时这⼀点，当前有两个超时时间设置（Feign/hystrix），熔断的时候是根据这两个时间的最<br>⼩值来进⾏的，即处理时⻓超过最短的那个超时时间了就熔断进⼊回退降级逻辑</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/1739104ebef6a638?w=1476&h=430&f=png&s=46400" srcset="/img/loading.gif" alt></p><ul><li>⾃定义FallBack处理类（需要实现FeignClient接⼝）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17391059f7435d6e?w=1472&h=898&f=png&s=123182" srcset="/img/loading.gif" alt></p><ul><li>在@FeignClient注解中关联2）中⾃定义的处理类<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value = <span class="hljs-string">"lagou-service-resume"</span>,fallback =ResumeFallback.class,path = <span class="hljs-string">"/resume"</span>) <span class="hljs-comment">// 使⽤fallback的时候，类上的</span><span class="hljs-meta">@RequestMapping</span>的url前缀限定，改成配置在<span class="hljs-meta">@FeignClient</span>的path属性中<span class="hljs-comment">//@RequestMapping("/resume")</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResumeServiceFeignClient</span> </span>&#123;</code></pre></div></li></ul><h2 id="五、Feign对请求压缩和响应压缩的⽀持"><a href="#五、Feign对请求压缩和响应压缩的⽀持" class="headerlink" title="五、Feign对请求压缩和响应压缩的⽀持"></a>五、Feign对请求压缩和响应压缩的⽀持</h2><p>Feign ⽀持对请求和响应进⾏GZIP压缩，以减少通信过程中的性能损耗。通过下⾯的参数 即可开启请求与响应的压缩功能：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17391072ddb9403c?w=1500&h=482&f=png&s=99144" srcset="/img/loading.gif" alt></p><h2 id="六、Feign的⽇志级别配置"><a href="#六、Feign的⽇志级别配置" class="headerlink" title="六、Feign的⽇志级别配置"></a>六、Feign的⽇志级别配置</h2><p>Feign是http请求客户端，类似于咱们的浏览器，它在请求和接收响应的时候，可以打印出⽐较详细的⼀些⽇志信息（响应头，状态码等等），默认情况下Feign的⽇志没有开启。</p><ul><li><p>开启Feign⽇志功能及级别</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// Feign的⽇志级别（Feign请求过程信息）</span><span class="hljs-comment">// NONE：默认的，不显示任何⽇志----性能最好</span><span class="hljs-comment">// BASIC：仅记录请求⽅法、URL、响应状态码以及执⾏时间----⽣产问题追踪</span><span class="hljs-comment">// HEADERS：在BASIC级别的基础上，记录请求和响应的header</span><span class="hljs-comment">// FULL：记录请求和响应的header、body和元数据----适⽤于开发及测试环境定位问题</span><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLevel</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre></div></li><li><p>配置log⽇志级别为debug</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><span class="hljs-attr">  level:</span>   <span class="hljs-comment"># Feign⽇志只会对⽇志级别为debug的做出响应</span>   <span class="hljs-string">com.lagou.edu.controller.service.ResumeServiceFeignClient:</span> <span class="hljs-string">debug</span></code></pre></div></li></ul><h2 id="七、Feign核⼼源码剖析"><a href="#七、Feign核⼼源码剖析" class="headerlink" title="七、Feign核⼼源码剖析"></a>七、Feign核⼼源码剖析</h2><p>思考⼀个问题：只定义了接⼝，添加上@FeignClient，真的没有实现的话，能完成远程请求么？不能，考虑是做了代理了。</p><ul><li>断点标注 @FeginClient 接口</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173910a513317f6e?w=1460&h=672&f=png&s=327447" srcset="/img/loading.gif" alt></p><ul><li>从@EnableFeignClients 正向切⼊</li><li>import FeignClientsRegistrar </li><li>进入 org.springframework.cloud.openfeign.FeignClientsRegistrar#registerBeanDefinitions，重写BeanDefinitions，完成Bean 注入</li><li>接下来，我们主要追踪下另外⼀⾏主要的代码registerFeignClients(metadata, registry);定义了扫描器，主要扫描@FeginClient</li><li>注册客户端，给每⼀个客户端⽣成代理对象</li><li>所以，下⼀步，关注FeignClientFactoryBean这个⼯⼚Bean的getObject⽅法，根据经验，这个⽅法会返回我们的代理对象</li><li><strong>getObject 里面完成了 核心方法，包括了负载均衡的封装，最后发起请求</strong></li><li>最终请求的发起使⽤的是HttpURLConnection</li></ul><p>简单总结下：</p><p>为标注@FeginClient的接口生成代理，封装成Bean，利用FactoryBean#getObject,去包装了Ribbon，最终发起http请求。</p><hr><h2 id="Spring-Cloud-GateWay"><a href="#Spring-Cloud-GateWay" class="headerlink" title="Spring Cloud GateWay"></a>Spring Cloud GateWay</h2><h2 id="一、GateWay简介"><a href="#一、GateWay简介" class="headerlink" title="一、GateWay简介"></a>一、GateWay简介</h2><p>Spring Cloud GateWay（它只是众多⽹关解决⽅案中的⼀种）。</p><p>Spring Cloud GateWay是Spring Cloud的⼀个全新项⽬，⽬标是取代Netflix Zuul，它基于<strong>Spring5.0+SpringBoot2.0+WebFlux</strong>（基于⾼性能的Reactor模式响应式通信框架Netty，异步⾮阻塞模型）等技术开发，性能⾼于Zuul，官⽅测试，GateWay是Zuul的1.6倍，旨在为微服务架构提供⼀种简单有效的统⼀的API路由管理⽅式。</p><p>Spring Cloud GateWay不仅提供统⼀的路由⽅式（反向代理）并且基于Filter(定义过滤器对请求过滤，完成⼀些功能)链的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控等。</p><p><strong>⽹关在架构中的位置：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17392ff05c46b98d?w=1222&h=864&f=png&s=392469" srcset="/img/loading.gif" alt></p><h2 id="二、-GateWay核⼼概念"><a href="#二、-GateWay核⼼概念" class="headerlink" title="二、 GateWay核⼼概念"></a>二、 GateWay核⼼概念</h2><p>Zuul1.x 阻塞式IO 2.x 基于Netty<br>Spring Cloud GateWay天⽣就是异步⾮阻塞的，基于Reactor模型</p><p>⼀个请求—&gt;⽹关根据⼀定的条件匹配—匹配成功之后可以将请求转发到指定的服务地址；⽽在这个过<br>程中，我们可以进⾏⼀些⽐较具体的控制（限流、⽇志、⿊⽩名单）</p><ul><li>路由（route）： ⽹关最基础的部分，也是⽹关⽐较基础的⼯作单元。路由由⼀个ID、⼀个⽬标URL（最终路由到的地址）、⼀系列的断⾔（匹配条件判断）和Filter过滤器（精细化控制）组成。如果断⾔为true，则匹配该路由。</li><li>断⾔（predicates）：参考了Java8中的断⾔java.util.function.Predicate，开发⼈员可以匹配Http请求中的所有内容（包括请求头、请求参数等）（类似于nginx中的location匹配⼀样），如果断⾔与请求相匹配则路由。</li><li>过滤器（filter）：⼀个标准的Spring webFilter，使⽤过滤器，可以在请求之前或者之后执⾏业务逻辑。</li><li></li></ul><p>来⾃官⽹的⼀张图</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173930d9ca3428a5?w=1114&h=560&f=png&s=162279" srcset="/img/loading.gif" alt></p><p>其中，Predicates断⾔就是我们的匹配条件，⽽Filter就可以理解为⼀个⽆所不能的拦截器，有了这两个元素，结合⽬标URL，就可以实现⼀个具体的路由转发。</p><h2 id="三、GateWay⼯作过程（How-It-Works）"><a href="#三、GateWay⼯作过程（How-It-Works）" class="headerlink" title="三、GateWay⼯作过程（How It Works）"></a>三、GateWay⼯作过程（How It Works）</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173930eec889505e?w=984&h=1312&f=png&s=160120" srcset="/img/loading.gif" alt></p><p>Filter在“pre”类型过滤器中可以做参数校验、权限校验、流量监控、⽇志输出、协议转换等，在“post”类<br>型的过滤器中可以做响应内容、响应头的修改、⽇志的输出、流量监控等。</p><p><strong>GateWay核⼼逻辑：路由转发+执⾏过滤器链</strong></p><h2 id="四、GateWay应⽤"><a href="#四、GateWay应⽤" class="headerlink" title="四、GateWay应⽤"></a>四、GateWay应⽤</h2><ul><li>导⼊依赖，GateWay不需要使⽤web模块，它引⼊的是WebFlux（类似于SpringMVC），<strong>注意：不要引⼊starter-web模块，需要引⼊web-flux</strong></li><li>application.yml 配置⽂件部分内容</li></ul><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">9002</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">  client:</span><span class="hljs-attr">    serviceUrl:</span> <span class="hljs-comment"># eureka server的路径</span><span class="hljs-attr">      defaultZone:</span> <span class="hljs-attr">http://127.0.0.1:8761/eureka/,http://127.0.0.1:8762/eureka/</span> <span class="hljs-comment">#把 eureka 集群中的所有 url 都填写了进来，也可以只写一台，因为各个 eureka server 可以同步注册表</span><span class="hljs-attr">  instance:</span>    <span class="hljs-comment">#使用ip注册，否则会使用主机名注册了（此处考虑到对老版本的兼容，新版本经过实验都是ip）</span><span class="hljs-attr">    prefer-ip-address:</span> <span class="hljs-literal">true</span><span class="hljs-attr">spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">gateway-9002</span><span class="hljs-attr">  cloud:</span>    <span class="hljs-comment"># config客户端配置,和ConfigServer通信，并告知ConfigServer希望获取的配置信息在哪个文件中</span><span class="hljs-attr">    config:</span><span class="hljs-attr">      discovery:</span><span class="hljs-attr">        enabled:</span> <span class="hljs-literal">true</span><span class="hljs-attr">        service-id:</span> <span class="hljs-string">config-bus-9006</span><span class="hljs-attr">    gateway:</span><span class="hljs-attr">      routes:</span> <span class="hljs-comment"># 路由可以有多个</span><span class="hljs-attr">        - id:</span> <span class="hljs-string">lagou-service-user</span> <span class="hljs-comment"># 我们自定义的路由 ID，保持唯一</span><span class="hljs-attr">          uri:</span> <span class="hljs-attr">lb://lagou-service-user</span><span class="hljs-attr">          predicates:</span><span class="hljs-bullet">            -</span> <span class="hljs-string">Path=/api/user/**</span><span class="hljs-attr">        - id:</span> <span class="hljs-string">lagou-service-code</span> <span class="hljs-comment"># 我们自定义的路由 ID，保持唯一</span><span class="hljs-attr">          uri:</span> <span class="hljs-attr">lb://lagou-service-code</span><span class="hljs-attr">          predicates:</span><span class="hljs-bullet">            -</span> <span class="hljs-string">Path=/api/code/**</span></code></pre></div><h2 id="五、GateWay路由规则详解"><a href="#五、GateWay路由规则详解" class="headerlink" title="五、GateWay路由规则详解"></a>五、GateWay路由规则详解</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393116df11c6a6?w=1256&h=624&f=png&s=132668" srcset="/img/loading.gif" alt></p><p><strong>实现动态路由</strong></p><p>GateWay⽀持⾃动从注册中⼼中获取服务列表并访问，即所谓的动态路由</p><ul><li>pom.xml中添加注册中⼼客户端依赖（因为要获取注册中⼼服务列表，eureka客户端已经引⼊）</li><li>动态路由配置<br><img src="https://user-gold-cdn.xitu.io/2020/7/28/1739313b257a1d14?w=1280&h=576&f=png&s=167500" srcset="/img/loading.gif" alt></li></ul><p>注意：动态路由设置时，uri以 lb: //开头（lb代表从注册中⼼获取服务），后⾯是需要转发到的服务名<br>称</p><h2 id="六、GateWay过滤器"><a href="#六、GateWay过滤器" class="headerlink" title="六、GateWay过滤器"></a>六、GateWay过滤器</h2><ul><li>从过滤器⽣命周期（影响时机点）的⻆度来说，主要有两个pre和post：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393148fc9d3733?w=1282&h=390&f=png&s=110208" srcset="/img/loading.gif" alt></p><ul><li>从过滤器类型的⻆度，Spring Cloud GateWay的过滤器分为GateWayFilter和GlobalFilter两种</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393159e4278f4c?w=1288&h=230&f=png&s=39951" srcset="/img/loading.gif" alt></p><ul><li>使用如下：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393156bf1120df?w=1032&h=350&f=png&s=51602" srcset="/img/loading.gif" alt></p><h2 id="七、GateWay⾼可⽤"><a href="#七、GateWay⾼可⽤" class="headerlink" title="七、GateWay⾼可⽤"></a>七、GateWay⾼可⽤</h2><p>GateWay的⾼可⽤很简单：可以启动多个GateWay实例来实现⾼可⽤，在GateWay的上游使⽤Nginx等负载均衡设备进⾏负载转发以达到⾼可⽤的⽬的。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393169c5358181?w=694&h=358&f=png&s=33609" srcset="/img/loading.gif" alt></p><hr><h2 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h2><h2 id="一、-分布式配置中⼼应⽤场景"><a href="#一、-分布式配置中⼼应⽤场景" class="headerlink" title="一、 分布式配置中⼼应⽤场景"></a>一、 分布式配置中⼼应⽤场景</h2><ol><li>集中配置管理，⼀个微服务架构中可能有成百上千个微服务，所以集中配置管理是很重要的（⼀次修改、到处⽣效）</li><li>不同环境不同配置，⽐如数据源配置在不同环境（开发dev,测试test,⽣产prod）中是不同的</li><li>运⾏期间可动态调整。例如，可根据各个微服务的负载情况，动态调整数据源连接池⼤⼩等配置修改后可⾃动更新</li><li>如配置内容发⽣变化，微服务可以⾃动更新配置</li></ol><p>那么，我们就需要对配置⽂件进⾏集中式管理，这也是分布式配置中⼼的作⽤。</p><h2 id="二、Spring-Cloud-Config"><a href="#二、Spring-Cloud-Config" class="headerlink" title="二、Spring Cloud Config"></a>二、Spring Cloud Config</h2><h3 id="1-Config-简介"><a href="#1-Config-简介" class="headerlink" title="1. Config 简介"></a>1. Config 简介</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/1739321e265ba8c2?w=1336&h=508&f=png&s=234705" srcset="/img/loading.gif" alt></p><ul><li>Server 端：提供配置⽂件的存储、以接⼝的形式将配置⽂件的内容提供出去，通过使⽤@EnableConfigServer注解在 Spring boot 应⽤中⾮常简单的嵌⼊</li><li>Client 端：通过接⼝获取配置数据并初始化⾃⼰的应⽤</li></ul><h3 id="2-Config分布式配置应⽤"><a href="#2-Config分布式配置应⽤" class="headerlink" title="2. Config分布式配置应⽤"></a>2. Config分布式配置应⽤</h3><ul><li><p>Config Server是集中式的配置服务，⽤于集中管理应⽤程序各个环境下的配置。 默认使⽤Git存储配置⽂件内容，也可以SVN。</p></li><li><p>构建Config Server统⼀配置中⼼,引⼊依赖坐标（需要注册⾃⼰到Eureka）</p></li><li><p>注解@EnableConfigServer开启配置中⼼服务器功能</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393276184c181f?w=1298&h=588&f=png&s=82610" srcset="/img/loading.gif" alt></p><ul><li>构建Client客户端</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/1739327cc15b0a8d?w=1290&h=202&f=png&s=30118" srcset="/img/loading.gif" alt></p><ul><li>application.yml修改为bootstrap.yml配置⽂件,bootstrap.yml是系统级别的，优先级⽐application.yml⾼，应⽤启动时会检查这个配置⽂件，在这个<br>配置⽂件中指定配置中⼼的服务地址，会⾃动拉取所有应⽤配置并且启⽤。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/17393292885329ea?w=1270&h=320&f=png&s=72815" srcset="/img/loading.gif" alt></p><h2 id="三、Config配置⼿动刷新"><a href="#三、Config配置⼿动刷新" class="headerlink" title="三、Config配置⼿动刷新"></a>三、Config配置⼿动刷新</h2><p>不⽤重启微服务，只需要⼿动的做⼀些其他的操作（访问⼀个地址/refresh）刷新，之后再访问即可<br>此时，客户端取到了配置中⼼的值，但当我们修改GitHub上⾯的值时，服务端（Config Server）能实时获取最新的值，但客户端（Config Client）读的是缓存，⽆法实时获取最新值。Spring Cloud已 经为<br>我们解决了这个问题，那就是客户端使⽤post去触发refresh，获取最新数据。</p><ul><li>Client客户端添加依赖springboot-starter-actuator</li><li>Client客户端bootstrap.yml中添加配置（暴露通信端点）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173932e6a1cdee71?w=592&h=532&f=png&s=37943" srcset="/img/loading.gif" alt></p><ul><li>Client客户端使⽤到配置信息的类上添加@RefreshScope</li><li>⼿动向Client客户端发起POST请求，<a href="http://localhost:8080/actuator/refresh，刷新配置信息" target="_blank" rel="noopener">http://localhost:8080/actuator/refresh，刷新配置信息</a></li></ul><p><strong>注意：⼿动刷新⽅式避免了服务重启（流程：Git改配置—&gt;for循环脚本⼿动刷新每个微服务）</strong></p><h2 id="四、Config配置⾃动更新"><a href="#四、Config配置⾃动更新" class="headerlink" title="四、Config配置⾃动更新"></a>四、Config配置⾃动更新</h2><p>实现⼀次通知处处⽣效，与zk原理相同，在微服务架构中，我们可以结合消息总线（Bus）实现分布式配置的⾃动更新（Spring Cloud<br>Config+Spring Cloud Bus）</p><h3 id="1-消息总线Bus"><a href="#1-消息总线Bus" class="headerlink" title="1. 消息总线Bus"></a>1. 消息总线Bus</h3><p>Spring Cloud Bus（基于MQ的，⽀持RabbitMq/Kafka） 是Spring Cloud中的消息总线⽅案，Spring<br>Cloud Config + Spring Cloud Bus 结合可以实现配置信息的⾃动更新。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/1739333ba47652ce?w=1240&h=714&f=png&s=203649" srcset="/img/loading.gif" alt></p><h3 id="2-Spring-Cloud-Config-Spring-Cloud-Bus-实现⾃动刷新"><a href="#2-Spring-Cloud-Config-Spring-Cloud-Bus-实现⾃动刷新" class="headerlink" title="2. Spring Cloud Config+Spring Cloud Bus 实现⾃动刷新"></a>2. Spring Cloud Config+Spring Cloud Bus 实现⾃动刷新</h3><ul><li><p>Config Server服务端添加消息总线⽀持</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>ConfigServer添加配置</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><span class="hljs-attr"> rabbitmq:</span><span class="hljs-attr">    host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-attr">    port:</span> <span class="hljs-number">5672</span><span class="hljs-attr">    username:</span> <span class="hljs-string">guest</span><span class="hljs-attr">    password:</span> <span class="hljs-string">guest</span></code></pre></div></li><li><p>微服务暴露端⼝<br>重启各个服务，更改配置之后，向配置中⼼服务端发送post请求<br><a href="http://localhost:9003/actuator/bus-refresh，" target="_blank" rel="noopener">http://localhost:9003/actuator/bus-refresh，</a> 各个客户端配置即可⾃动刷新,<br>在⼴播模式下实现了⼀次请求，处处更新，如果我只想定向更新呢？<br>在发起刷新请求的时候<a href="http://localhost:9006/actuator/bus-refresh/lagou-service-resume:8081" target="_blank" rel="noopener">http://localhost:9006/actuator/bus-refresh/lagou-service-resume:8081</a><br>即为最后⾯跟上要定向刷新的实例的 服务名:端⼝号即可</p></li></ul><hr><h2 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h2><h2 id="一、Stream解决的痛点问题"><a href="#一、Stream解决的痛点问题" class="headerlink" title="一、Stream解决的痛点问题"></a>一、Stream解决的痛点问题</h2><p>Spring Cloud Stream进⾏了很好的上层抽象，可以让我们与具体消息中间件解耦合，屏蔽掉了底层具<br>体MQ消息中间件的细节差异，就像Hibernate屏蔽掉了具体数据库（Mysql/Oracle⼀样）。如此⼀来，我们学习、开发、维护MQ都会变得轻松。⽬前Spring Cloud Stream⽀持RabbitMQ和Kafka。</p><p>本质：屏蔽掉了底层不同MQ消息中间件之间的差异，统⼀了MQ的编程模型，降低了学习、开发、维护MQ的成本</p><h2 id="二、Stream重要概念"><a href="#二、Stream重要概念" class="headerlink" title="二、Stream重要概念"></a>二、Stream重要概念</h2><p>Spring Cloud Stream 是⼀个构建消息驱动微服务的框架。应⽤程序通过inputs（相当于消息消费者consumer）或者outputs（相当于消息⽣产者producer）来与Spring Cloud Stream中的binder对象交互，⽽Binder对象是⽤来屏蔽底层MQ细节的，它负责与具体的消息中间件交互。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173933b355cdf83b?w=1262&h=822&f=png&s=467402" srcset="/img/loading.gif" alt></p><p><strong>Binder绑定器</strong></p><p>Binder绑定器是Spring Cloud Stream 中⾮常核⼼的概念，就是通过它来屏蔽底层不同MQ消息中间件<br>的细节差异，当需要更换为其他消息中间件时，我们需要做的就是更换对应的Binder绑定器⽽不需要修改任何应⽤逻辑（Binder绑定器的实现是框架内置的，Spring Cloud Stream⽬前⽀持Rabbit、Kafka两种消息队列）</p><h2 id="三、传统MQ模型与Stream消息驱动模型"><a href="#三、传统MQ模型与Stream消息驱动模型" class="headerlink" title="三、传统MQ模型与Stream消息驱动模型"></a>三、传统MQ模型与Stream消息驱动模型</h2><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173933caf4a9a623?w=1270&h=824&f=png&s=159775" srcset="/img/loading.gif" alt></p><h2 id="四、Stream消息通信⽅式及编程模型"><a href="#四、Stream消息通信⽅式及编程模型" class="headerlink" title="四、Stream消息通信⽅式及编程模型"></a>四、Stream消息通信⽅式及编程模型</h2><p>Stream中的消息通信⽅式遵循了发布—订阅模式。</p><p>在Spring Cloud Stream中的消息通信⽅式遵循了发布-订阅模式，当⼀条消息被投递到消息中间件之后，它会通过共享的Topic主题进⾏⼴播，消息消费者在订阅的主题中收到它并触发⾃身的业务逻辑处理。这⾥所提到的 Topic 主题是Spring Cloud Stream中的⼀个抽象概念，⽤来代表发布共享消息给消费者的地⽅。在不同的消息中间件中， Topic 可能对应着不同的概念，⽐如：在RabbitMQ中的它对应了Exchange、在Kakfa中则对应了Kafka中的Topic。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173933e52dd10620?w=1296&h=550&f=png&s=130225" srcset="/img/loading.gif" alt></p><p><strong>Stream消息驱动之开发⽣产者端</strong></p><ul><li><p>pom.xml中添加依赖</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--eureka client 客户端依赖引⼊--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!--spring cloud stream 依赖（rabbit）--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>application.yml添加配置,binders: # 绑定MQ服务信息（此处我们是RabbitMQ）,bindings: # 关联整合通道和binder对象</p></li><li><p>实现类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.lagou.edu.service.impl;<span class="hljs-keyword">import</span> com.lagou.edu.service.IMessageProducer;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.EnableBinding;<span class="hljs-keyword">import</span> org.springframework.cloud.stream.messaging.Source;<span class="hljs-keyword">import</span> org.springframework.messaging.support.MessageBuilder;<span class="hljs-comment">// Source.class⾥⾯就是对输出通道的定义（这是Spring Cloud Stream内置的通道封装）</span><span class="hljs-meta">@EnableBinding</span>(Source.class)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducerImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IMessageProducer</span> </span>&#123;    <span class="hljs-comment">// 将MessageChannel的封装对象Source注⼊到这⾥使⽤</span>    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> Source source;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMessage</span><span class="hljs-params">(String content)</span> </span>&#123;        <span class="hljs-comment">// 向mq中发送消息（并不是直接操作mq，应该操作的是spring cloud stream）</span>        <span class="hljs-comment">// 使⽤通道向外发出消息(指的是Source⾥⾯的output通道)</span>        source.output().send(MessageBuilder.withPayload(content).build());    &#125;&#125;</code></pre></div></li><li><p>test</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageProducerTest</span> </span>&#123;<span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> IMessageProducer iMessageProducer;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSendMessage</span><span class="hljs-params">()</span> </span>&#123;    iMessageProducer.sendMessage(<span class="hljs-string">"hello world-lagou101"</span>);    &#125;&#125;</code></pre></div></li></ul><p><strong>Stream消息驱动之开发消费者端</strong></p><ul><li>application.yml</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173934625946ed0d?w=1226&h=870&f=png&s=379509" srcset="/img/loading.gif" alt></p><ul><li>消息消费者监听<div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@EnableBinding</span>(Sink.class)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageConsumerService</span> </span>&#123;    <span class="hljs-meta">@StreamListener</span>(Sink.INPUT)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recevieMessages</span><span class="hljs-params">(Message&lt;String&gt; message)</span> </span>&#123;        System.out.println(<span class="hljs-string">"=========接收到的消息："</span> + message);    &#125;&#125;</code></pre></div></li></ul><h2 id="五、Stream⾼级之⾃定义消息通道"><a href="#五、Stream⾼级之⾃定义消息通道" class="headerlink" title="五、Stream⾼级之⾃定义消息通道"></a>五、Stream⾼级之⾃定义消息通道</h2><p>Stream 内置了两种接⼝Source和Sink分别定义了 binding 为 “input” 的输⼊流和 “output” 的输出流，<br>我们也可以⾃定义各种输⼊输出流（通道），但实际我们可以在我们的服务中使⽤多个binder、多个输<br>⼊通道和输出通道，然⽽默认就带了⼀个input的输⼊通道和⼀个output的输出通道，怎么办？<br>我们是可以⾃定义消息通道的，学着Source和Sink的样⼦，给你的通道定义个⾃⼰的名字，多个输⼊通<br>道和输出通道是可以写在⼀个类中的。</p><ul><li><p>定义接⼝</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomChannel</span> </span>&#123;    String INPUT_LOG = <span class="hljs-string">"inputLog"</span>;    String OUTPUT_LOG = <span class="hljs-string">"outputLog"</span>;    <span class="hljs-meta">@Input</span>(INPUT_LOG)    <span class="hljs-function">SubscribableChannel <span class="hljs-title">inputLog</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Output</span>(OUTPUT_LOG)    <span class="hljs-function">MessageChannel <span class="hljs-title">outputLog</span><span class="hljs-params">()</span></span>;&#125;</code></pre></div></li><li><p>如何使⽤</p><ul><li>在 @EnableBinding 注解中，绑定⾃定义的接⼝</li><li>使⽤ @StreamListener 做监听的时候，需要指定 CustomChannel.INPUT_LOG</li></ul></li></ul><h2 id="六、Stream⾼级之消息分组"><a href="#六、Stream⾼级之消息分组" class="headerlink" title="六、Stream⾼级之消息分组"></a>六、Stream⾼级之消息分组</h2><p>应用场景：消费者端有两个（消费同⼀个MQ的同⼀个主题），但是呢我们的业务场景中希望这个主题的⼀个Message只能被⼀个消费者端消费处理，此时我们就可以使⽤消息分组。</p><p>解决的问题：能解决消息重复消费问题</p><p>我们仅仅需要在服务消费者端设置 spring.cloud.stream.bindings.input.group 属性，多个消费者实例<br>配置为同⼀个group名称（在同⼀个group中的多个消费者只有⼀个可以获取到消息并消费）。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/28/173934b37516bc8f?w=1272&h=290&f=png&s=169770" srcset="/img/loading.gif" alt></p><blockquote><p><em>lagouedu 笔记总结</em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo从实战-&gt;源码分析</title>
    <link href="/2020/07/17/Dubbo%E4%BB%8E%E5%AE%9E%E6%88%98-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/07/17/Dubbo%E4%BB%8E%E5%AE%9E%E6%88%98-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-项目架构演变过程"><a href="#一、-项目架构演变过程" class="headerlink" title="一、 项目架构演变过程"></a>一、 项目架构演变过程</h2><p>单体架构-&gt;垂直架构(业务拆分)-&gt;分布式架构（SOA 松耦合)-&gt;微服务架构</p><h2 id="二、-Dubbo架构与实战"><a href="#二、-Dubbo架构与实战" class="headerlink" title="二、 Dubbo架构与实战"></a>二、 Dubbo架构与实战</h2><h3 id="1-Dubbo-架构概述"><a href="#1-Dubbo-架构概述" class="headerlink" title="1. Dubbo 架构概述"></a>1. Dubbo 架构概述</h3><h4 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h4><p>Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开<br>源Java RPC框架，可以和Spring框架无缝集成。</p><h4 id="1-2-特性"><a href="#1-2-特性" class="headerlink" title="1.2 特性"></a>1.2 特性</h4><p>面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。</p><h4 id="1-3-服务治理"><a href="#1-3-服务治理" class="headerlink" title="1.3 服务治理"></a>1.3 服务治理</h4><p>包括最佳实践、架构原则、治理规程、规律以及其他决定性的因素。服务治理指的是用来管理SOA的采用和实现的过程。</p><h3 id="2-处理流程"><a href="#2-处理流程" class="headerlink" title="2. 处理流程"></a>2. 处理流程</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/17340a5c9f971167?w=1318&h=1180&f=png&s=476735" srcset="/img/loading.gif" alt></p><h3 id="3-服务注册中心Zookeeper"><a href="#3-服务注册中心Zookeeper" class="headerlink" title="3. 服务注册中心Zookeeper"></a>3. 服务注册中心Zookeeper</h3><p>Dubbo官方推荐使用Zookeeper作为服务注册中心。Zookeeper 是 Apache Hadoop 的子项目，作为 Dubbo 服<br>务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。</p><h3 id="4-Dubbo开发实战"><a href="#4-Dubbo开发实战" class="headerlink" title="4. Dubbo开发实战"></a>4. Dubbo开发实战</h3><p>使用方面直接官方文档吧，个人写的再好，也没有原创的好…  官方地址-&gt; <a href="http://dubbo.apache.org/zh-cn/index.html。" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/index.html。</a></p><p>总结下来小demo就是配置三个模块：客户端、服务端、公用api接口，剩下的配置好zk，可以完美和Spring结合，使用及其方便。</p><h3 id="5-Dubbo管理控制台-dubbo-admin"><a href="#5-Dubbo管理控制台-dubbo-admin" class="headerlink" title="5. Dubbo管理控制台 dubbo-admin"></a>5. Dubbo管理控制台 dubbo-admin</h3><h4 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h4><p>主要包含：服务管理 、 路由规则、动态配置、服务降级、访问控制、权重调整、负载均衡等管理功能，2.6以后可以是jar包可以直接通过java命令运行。不需要配置tomcat。</p><h4 id="2-控制台安装步骤"><a href="#2-控制台安装步骤" class="headerlink" title="2. 控制台安装步骤"></a>2. 控制台安装步骤</h4><p>官方配置走起-&gt; <a href="https://dubbo.apache.org/zh-cn/docs/admin/introduction.html" target="_blank" rel="noopener">https://dubbo.apache.org/zh-cn/docs/admin/introduction.html</a></p><h3 id="6-Dubbo配置项说明"><a href="#6-Dubbo配置项说明" class="headerlink" title="6. Dubbo配置项说明"></a>6. Dubbo配置项说明</h3><h4 id="6-1-dubbo-application"><a href="#6-1-dubbo-application" class="headerlink" title="6.1. dubbo:application"></a>6.1. dubbo:application</h4><p>对应 org.apache.dubbo.config.ApplicationConfig, 代表当前应用的信息</p><ol><li>name: 当前应用程序的名称，在dubbo-admin中我们也可以看到。请求时也会根据name来进行请求。</li><li>owner: 当前应用程序的负责人，可以通过这个负责人找到其相关的应用列表，用于快速定位到责<br>任人。</li><li>qosEnable : 是否启动QoS 默认true</li><li>qosPort : 启动QoS绑定的端口 默认22222</li><li>qosAcceptForeignIp: 是否允许远程访问 默认是false</li></ol><h4 id="6-2-dubbo-registry"><a href="#6-2-dubbo-registry" class="headerlink" title="6.2. dubbo:registry"></a>6.2. dubbo:registry</h4><p>org.apache.dubbo.config.RegistryConfig, 代表该模块所使用的注册中心。可注册一个也可注册多个。</p><ol><li>id : 当服务中provider或者consumer中存在多个注册中心时，则使用需要增加该配置。在一<br>些公司，<strong>会通过业务线的不同选择不同的注册中心</strong>。</li><li>address : 当前注册中心的访问地址。</li><li>protocol : 当前注册中心所使用的协议是什么。也可以直接在address 中写入，比如使用<br>zookeeper，就可以写成zookeeper://xx.xx.xx.xx:2181</li><li>timeout : 当与注册中心不再同一个机房时，大多会把该参数延长。</li></ol><h4 id="6-3-dubbo-protocol"><a href="#6-3-dubbo-protocol" class="headerlink" title="6.3. dubbo:protocol"></a>6.3. dubbo:protocol</h4><p>org.apache.dubbo.config.ProtocolConfig, 指定服务在进行数据传输所使用的协议。</p><ol><li>id : 在大公司，可能因为各个部门技术栈不同，所以可能会选择使用不同的协议进行交互。这里<br>在多个协议使用时，需要指定。</li><li>name : 指定协议名称。默认使用dubbo 。</li></ol><h4 id="6-4-dubbo-service"><a href="#6-4-dubbo-service" class="headerlink" title="6.4. dubbo:service"></a>6.4. dubbo:service</h4><p>org.apache.dubbo.config.ServiceConfig, 用于指定当前需要对外暴露的服务信息</p><ol><li>interface : 指定当前需要进行对外暴露的接口是什么。</li><li>ref : 具体实现对象的引用，一般我们在生产级别都是使用Spring去进行Bean托管的，所以这里面<br>一般也指的是Spring中的BeanId。</li><li>version : 对外暴露的版本号。不同的版本号，消费者在消费的时候只会根据固定的版本号进行消<br>费。</li></ol><h4 id="6-5-dubbo-reference"><a href="#6-5-dubbo-reference" class="headerlink" title="6.5. dubbo:reference"></a>6.5. dubbo:reference</h4><p>org.apache.dubbo.config.ReferenceConfig, 消费者的配置</p><ol><li>id : 指定该Bean在注册到Spring中的id。</li><li>interface: 服务接口名</li><li>version : 指定当前服务版本，与服务提供者的版本一致。</li><li>registry : 指定所具体使用的注册中心地址。这里面也就是使用上面在dubbo:registry 中所声<br>明的id。</li></ol><h4 id="6-6-dubbo-method"><a href="#6-6-dubbo-method" class="headerlink" title="6.6. dubbo:method"></a>6.6. dubbo:method</h4><p>org.apache.dubbo.config.MethodConfig, 用于在制定的dubbo:service 或者dubbo:reference 中的<br>更具体一个层级，指定具体方法级别在进行RPC操作时候的配置，可以理解为对这上面层级中的配置针<br>对于具体方法的特殊处理。</p><ol><li>name : 指定方法名称，用于对这个方法名称的RPC调用进行特殊配置。</li><li>async: 是否异步 默认false</li></ol><h4 id="6-7-dubbo-service和dubbo-reference详解"><a href="#6-7-dubbo-service和dubbo-reference详解" class="headerlink" title="6.7. dubbo:service和dubbo:reference详解"></a>6.7. dubbo:service和dubbo:reference详解</h4><ol><li>mock: 用于在方法调用出现错误时，当做服务降级来统一对外返回结果。</li><li>timeout: 用于指定当前方法或者接口中所有方法的超时时间。比如我们在进行第三方服务依赖时可能会对接口的时长做放宽，防止第三方服务不稳定。</li><li>check: 用于在启动时，检查生产者是否有该服务。我们一般都会将这个值设置为false，不让其进<br>行检查。因为如果出现模块之间循环引用的话，那么则<strong>可能会出现相互依赖</strong>，都进行check的话，那么这两个服务永远也启动不起来。</li><li>retries: 用于指定当前服务在执行时出现错误或者超时时的重试机制。<ol><li><strong>提供者必须幂等</strong>，否则可能出现数据一致性问题</li><li><strong>提供者是否有类似缓存机制</strong>，如出现大面积错误时，可能因为不停重试导致雪崩</li></ol></li><li>executes: 用于在提供者做配置，来确保最大的并行度。<ol><li>可能导致集群功能无法充分利用或者堵塞</li><li>但是也可以启动部分对应用的保护功能</li><li>可以不做配置，结合后面的熔断限流使用</li></ol></li></ol><p><strong>所有配置最终都将转换为 URL（protocol://username:password@host:port/path?key=value&amp;key=value）表示，并由服务提供方生成，经注册中心传递给消费方。</strong></p><h2 id="三、Dubbo高级实战"><a href="#三、Dubbo高级实战" class="headerlink" title="三、Dubbo高级实战"></a>三、Dubbo高级实战</h2><h3 id="1-SPI（面试常客）"><a href="#1-SPI（面试常客）" class="headerlink" title="1. SPI（面试常客）"></a>1. SPI（面试常客）</h3><h4 id="1-1-SPI简介"><a href="#1-1-SPI简介" class="headerlink" title="1.1 SPI简介"></a>1.1 SPI简介</h4><p>SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。 目前有不少框架用它<br>来做服务的扩展发现（springboot），简单来说，它就是一种动态替换发现的机制。使用SPI机制的优势是实现解耦，<br>使得第三方服务模块的装配控制逻辑与调用者的业务代码分离。</p><h4 id="1-2-JDK中的SPI"><a href="#1-2-JDK中的SPI" class="headerlink" title="1.2 JDK中的SPI"></a>1.2 JDK中的SPI</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/12/1734313239bdd3ae?w=1210&h=450&f=png&s=160736" srcset="/img/loading.gif" alt></p><p>SPI遵循如下约定：</p><ul><li>当服务提供者提供了接口的一种具体实现后，在META-INF/services目录下创建一个以“接口全<br>限定名”为命名的文件，内容为实现类的全限定名；</li><li>接口实现类所在的jar包放在主程序的classpath中；</li><li>主程序通过java.util.ServiceLoader动态装载实现模块，它通过扫描META-INF/services目录下<br>的配置文件找到实现类的全限定名，把类加载到JVM；</li><li>SPI的实现类必须携带一个无参构造方法；</li></ul><h4 id="1-3-Dubbo中的SPI"><a href="#1-3-Dubbo中的SPI" class="headerlink" title="1.3 Dubbo中的SPI"></a>1.3 Dubbo中的SPI</h4><p>dubbo中大量的使用了SPI来作为扩展点，通过实现同一接口的前提下，可以进行定制自己的实现类。<br>比如比较常见的协议，负载均衡，都可以通过SPI的方式进行定制化，自己扩展。Dubbo中已经存在的<br>所有已经实现好的扩展点。详见dubbo-2.7.3.jar!/META-INF/dubbo/internal</p><h4 id="1-4-Dubbo中扩展点使用方式"><a href="#1-4-Dubbo中扩展点使用方式" class="headerlink" title="1.4 Dubbo中扩展点使用方式"></a>1.4 Dubbo中扩展点使用方式</h4><p>我们使用三个项目来演示Dubbo中扩展点的使用方式，一个主项目main，一个服务接口项目api，一个服务实现项目impl。</p><ul><li>创建接口</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span>(<span class="hljs-string">"human"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function">String  <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;    <span class="hljs-meta">@Adaptive</span>    <span class="hljs-function">String  <span class="hljs-title">sayHello</span><span class="hljs-params">(URL url)</span></span>;&#125;</code></pre></div><ul><li>创建实现类 </li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DogHelloService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"wang wang"</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(URL url)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"wang url"</span>;    &#125;&#125;</code></pre></div><ul><li>创建META-INF(key=value(实现类))</li></ul><div class="hljs"><pre><code class="hljs undefined">human=com<span class="hljs-selector-class">.zjn</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.HumanHelloService</span>dog=com<span class="hljs-selector-class">.zjn</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.impl</span><span class="hljs-selector-class">.DogHelloService</span></code></pre></div><ul><li>Main方法走起来</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboSpiMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">// 获取扩展加载器</span>        ExtensionLoader&lt;HelloService&gt;  extensionLoader  = ExtensionLoader.getExtensionLoader(HelloService.class);        <span class="hljs-comment">// 遍历所有的支持的扩展点 META-INF.META-INF</span>        Set&lt;String&gt; extensions = extensionLoader.getSupportedExtensions();        <span class="hljs-keyword">for</span> (String extension : extensions)&#123;            String result = extensionLoader.getExtension(extension).sayHello();            System.out.println(result);        &#125;    &#125;&#125;</code></pre></div><ul><li><p>dubbo自己做SPI的目的</p><div class="hljs"><pre><code>1. JDK 标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源2. 如果有扩展点加载失败，则所有扩展点无法使用3. 提供了对扩展点包装的功能(Adaptive)，并且还支持通过set的方式对其他的扩展点进行注入</code></pre></div></li></ul><h4 id="1-5-Dubbo-SPI中的Adaptive功能"><a href="#1-5-Dubbo-SPI中的Adaptive功能" class="headerlink" title="1.5 Dubbo SPI中的Adaptive功能"></a>1.5 Dubbo SPI中的Adaptive功能</h4><p>Dubbo中的Adaptive功能，主要解决的问题是如何动态的选择具体的扩展点。通过URL的方式对扩展点来进行动态选择。(dubbo中所有的注册信息都是通过URL的形式进行处理的。)</p><ul><li>接口在需要扩展的方法上加@Adaptive，案例见上面创建接口</li><li>创建Main方法</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboAdaptiveMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        URL url = URL.valueOf(<span class="hljs-string">"test://localhost/hello?hello.service=dog"</span>);        <span class="hljs-keyword">final</span> HelloService adaptiveExtension=ExtensionLoader.getExtensionLoader(HelloService.class).getAdaptiveExtension();        adaptiveExtension.sayHello(url);    &#125;&#125;</code></pre></div><ul><li>通过getAdaptiveExtension来提供一个统一的类来对所有的扩展点提供支持(底层对所有的扩展点进行封装)。</li><li>调用时通过参数中增加URL 对象来实现动态的扩展点使用。</li><li>如果URL没有提供该参数，则该方法会使用默认在SPI 注解中声明的实现。</li></ul><h4 id="1-6-Dubbo调用时拦截操作"><a href="#1-6-Dubbo调用时拦截操作" class="headerlink" title="1.6 Dubbo调用时拦截操作"></a>1.6 Dubbo调用时拦截操作</h4><p>提供了非常方便的扩展性，比如为dubbo接口实现ip白名单功能、监控功能、日志记录等。demo代码如下：</p><ul><li><p>实现org.apache.dubbo.rpc.Filter 接口</p></li><li><p>使用org.apache.dubbo.common.extension.Activate 接口进行对类进行注册 通过group 可以指定生产端 消费端</p><div class="hljs"><pre><code class="hljs undefined">@<span class="hljs-keyword">Activate</span>(<span class="hljs-keyword">group</span> = &#123;<span class="hljs-selector-tag">CommonConstants</span><span class="hljs-selector-class">.CONSUMER</span>)</code></pre></div></li><li><p>在META-INF.dubbo 中新建org.apache.dubbo.rpc.Filter 文件，并将当前类的全名写入</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">timerFilter</span>=包名.过滤器的名字</code></pre></div><h3 id="2-负载均衡策略"><a href="#2-负载均衡策略" class="headerlink" title="2 负载均衡策略"></a>2 负载均衡策略</h3><p>直接官方吧，很详细: <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html</a></p><h4 id="2-1-负载均衡基本配置"><a href="#2-1-负载均衡基本配置" class="headerlink" title="2.1 负载均衡基本配置"></a>2.1 负载均衡基本配置</h4><p>配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在服务消费者一方配置负载均衡策略</span><span class="hljs-meta">@Reference</span>(check = <span class="hljs-keyword">false</span>,loadbalance = <span class="hljs-string">"random"</span>)</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">//在服务提供者一方配置负载均衡</span><span class="hljs-meta">@Service</span>(loadbalance = <span class="hljs-string">"random"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"hello "</span> + name;    &#125;&#125;</code></pre></div><h4 id="2-2-自定义负载均衡器"><a href="#2-2-自定义负载均衡器" class="headerlink" title="2.2 自定义负载均衡器"></a>2.2 自定义负载均衡器</h4><p>负载均衡器在Dubbo中的SPI接口是org.apache.dubbo.rpc.cluster.LoadBalance , 可以通过实现这个接口来实现自定义的负载均衡规则。</p><ul><li>创建负载均衡器OnlyFirstLoadbalancer</li><li>配置负载均衡器：在dubbo-spi-loadbalance工程的META-INF/dubbo 目录下新建<br>org.apache.dubbo.rpc.cluster.LoadBalance 文件，并将当前类的全名写入<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">onlyFirst</span>=包名.负载均衡器</code></pre></div></li></ul><p><strong>保证注册相同的注册中心。其他配置与过滤器配置相同</strong></p><h3 id="3-异步调用"><a href="#3-异步调用" class="headerlink" title="3 异步调用"></a>3 异步调用</h3><p>主要<strong>应用于提供者接口响应耗时明显</strong>，消费者端可以利用调用接口的时间去做一些其他的接口调用,利用Future模式来异步等待和获取结果即可。这种方式可以大大的提升消费者端的利用率。 目前这种方式可以通过XML的方式进行引入。</p><h4 id="3-1-异步调用实现"><a href="#3-1-异步调用实现" class="headerlink" title="3.1 异步调用实现"></a>3.1 异步调用实现</h4><ul><li>修改接口</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> timeToWait)</span></span>;</code></pre></div><ul><li>服务端接口实现sleep 为了模拟调用耗时 可以让线程等待一段时间</li><li>在消费者端，配置异步调用,配置如果提供端耗时大于1000毫秒超时</li></ul><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"helloService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.zjn.service.HelloService"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sayHello"</span> <span class="hljs-attr">async</span>=<span class="hljs-string">"true"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre></div><ul><li>消费者端通过RpcContext.getContext().getFuture()来进行获取Future对象来进行后续的结果等待操作。</li></ul><h4 id="3-2-异步调用特殊说明"><a href="#3-2-异步调用特殊说明" class="headerlink" title="3.2 异步调用特殊说明"></a>3.2 异步调用特殊说明</h4><div class="hljs"><pre><code class="hljs !">注意：该方式的使用，请确保dubbo的版本在2.5.4及以后的版本使用。 原因在于在2.5.3及之前的版本使用的时候，会出现异步状态传递问题。比如我们的服务调用关系是A-&gt;B-&gt;C,这时候如果A向B发起了异步请求，在错误的版本时，B向C发起的请求也会连带的产生异步请求。这是因为在底层实现层面，他是通过RPCContext 中的attachment实现的。在A向B发起异步请求时，会在attachment中增加一个异步标示字段来表明异步等待结果。B在接受到A中的请求时，会通过该字段来判断是否是异步处理。但是由于值传递问题，B向C发起时同样会将该值进行传递，导致C误以为需要异步结果，导致返回空。这个问题在2.5.4及以后的版本进行了修正。</code></pre></div><h3 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4 线程池"></a>4 线程池</h3><h4 id="4-1-Dubbo已有线程池"><a href="#4-1-Dubbo已有线程池" class="headerlink" title="4.1 Dubbo已有线程池"></a>4.1 Dubbo已有线程池</h4><p>dubbo在使用时，都是通过创建真实的业务线程池进行操作的。</p><ul><li>fix: 表示创建固定大小的线程池。也是Dubbo默认的使用方式，默认创建的执行线程数为200，并且是没有任何等待队列的。所以再极端的情况下可能会存在问题，比如某个操作大量执行时，可能存在堵塞的情况。</li><li>cache: 创建非固定大小的线程池，当线程不足时，会自动创建新的线程。但是使用这种的时候需要注意，如果突然有高TPS的请求过来，方法没有及时完成，则会造成大量的线程创建，对系统的CPU和负载都是压力，执行越多反而会拖慢整个系统。</li></ul><h4 id="4-2-自定义线程池"><a href="#4-2-自定义线程池" class="headerlink" title="4.2 自定义线程池"></a>4.2 自定义线程池</h4><p>特殊业务使用fix模式，可能会因为线程不足产生错误。这是无感知的，所以要做一个线程监控，这样就可以进行及时的扩缩容机器或者告警。如下可以自定义线程池：</p><ol><li>线程池实现, 这里主要是基于对FixedThreadPool 中的实现做扩展出线程监控的部分,注意<strong>要写构造方法</strong>,上代码</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zjn.threadpool;<span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;<span class="hljs-keyword">import</span> org.apache.dubbo.common.threadpool.support.fixed.FixedThreadPool;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.*;<span class="hljs-comment">/** * <span class="hljs-doctag">@author</span>: 190coder &lt;190coder.cn&gt; * <span class="hljs-doctag">@description</span>: * <span class="hljs-doctag">@create</span>: 2020-07-13 16:31 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WachingThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FixedThreadPool</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(WachingThreadPool.class);    <span class="hljs-comment">// 定义线程池使用的阀值</span>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-keyword">final</span>  <span class="hljs-keyword">double</span>  ALARM_PERCENT = <span class="hljs-number">0.90</span>;    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">final</span> Map&lt;URL, ThreadPoolExecutor&gt; THREAD_POOLS = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">WachingThreadPool</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">// 每隔3秒打印线程使用情况</span>        Executors.newSingleThreadScheduledExecutor().scheduleWithFixedDelay(<span class="hljs-keyword">this</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>, TimeUnit.SECONDS);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Executor <span class="hljs-title">getExecutor</span><span class="hljs-params">(URL url)</span> </span>&#123;        <span class="hljs-keyword">final</span>  Executor executor = <span class="hljs-keyword">super</span>.getExecutor(url);        <span class="hljs-keyword">if</span>(executor <span class="hljs-keyword">instanceof</span> ThreadPoolExecutor)&#123;            THREAD_POOLS.put(url,(ThreadPoolExecutor)executor);        &#125;        <span class="hljs-keyword">return</span>  executor;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 遍历线程池</span>        <span class="hljs-keyword">for</span> (Map.Entry&lt;URL,ThreadPoolExecutor&gt; entry: THREAD_POOLS.entrySet())&#123;            <span class="hljs-keyword">final</span>   URL  url = entry.getKey();            <span class="hljs-keyword">final</span>   ThreadPoolExecutor  executor = entry.getValue();            <span class="hljs-comment">// 计算相关指标</span>            <span class="hljs-keyword">final</span>  <span class="hljs-keyword">int</span>  activeCount  = executor.getActiveCount();            <span class="hljs-keyword">final</span>  <span class="hljs-keyword">int</span>  poolSize = executor.getCorePoolSize();            <span class="hljs-keyword">double</span>  usedPercent = activeCount / (poolSize*<span class="hljs-number">1.0</span>);            LOGGER.info(<span class="hljs-string">"线程池执行状态:[&#123;&#125;/&#123;&#125;:&#123;&#125;%]"</span>,activeCount,poolSize,usedPercent*<span class="hljs-number">100</span>);            <span class="hljs-keyword">if</span> (usedPercent &gt; ALARM_PERCENT)&#123;                LOGGER.error(<span class="hljs-string">"超出警戒线! host:&#123;&#125; 当前使用率是:&#123;&#125;,URL:&#123;&#125;"</span>,url.getIp(),usedPercent*<span class="hljs-number">100</span>,url);            &#125;        &#125;    &#125;&#125;</code></pre></div><ol start="2"><li>SPI声明，创建文件META-INF/dubbo/org.apache.dubbo.common.threadpool.ThreadPool</li></ol><div class="hljs"><pre><code class="hljs undefined">watching=com<span class="hljs-selector-class">.zjn</span><span class="hljs-selector-class">.threadpool</span><span class="hljs-selector-class">.WachingThreadPool</span> <span class="hljs-comment">// 包名.线程池名</span></code></pre></div><ol start="3"><li>服务提供方项目引入该依赖,设置使用该线程池生成器</li></ol><div class="hljs"><pre><code class="hljs undefined">dubbo<span class="hljs-selector-class">.provider</span><span class="hljs-selector-class">.threadpool</span>=watching</code></pre></div><h3 id="5-路由规则"><a href="#5-路由规则" class="headerlink" title="5. 路由规则"></a>5. 路由规则</h3><p>路由是决定一次请求中需要发往目标机器的重要判断，通过对其控制可以决定请求的目标机器。我们可以通过创建这样的规则来决定一个请求会交给哪些服务器去处理。</p><h4 id="5-1-快速入门"><a href="#5-1-快速入门" class="headerlink" title="5.1 快速入门"></a>5.1 快速入门</h4><p>（1）提供两个提供者(一台本机作为提供者，一台为其他的服务器)，每个提供者会在调用时可以返回不同的信息 以区分提供者。</p><p>（2）针对于消费者，我们这里通过一个死循环，每次等待用户输入，再进行调用，来模拟真实的请求情况。通过调用的返回值 确认具体的提供者。</p><p>（3）我们通过ipconfig来查询到我们的IP地址，并且单独启动一个客户端，来进行如下配置(这里假设我们希望隔离掉本机的请求，都发送到另外一台机器上)。</p><p><strong>如果无集群，可只启一个客户端和服务端作为测试，执行一次，可根据规则禁止同一zk内的服务。设置规则如下：</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;<span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">import</span> org.apache.dubbo.registry.Registry;<span class="hljs-keyword">import</span> org.apache.dubbo.registry.RegistryFactory;<span class="hljs-comment">/** * <span class="hljs-doctag">@author</span>: 190coder &lt;190coder.cn&gt; * <span class="hljs-doctag">@description</span>: * <span class="hljs-doctag">@create</span>: 2020-07-13 18:00 */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DubboRouterMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        RegistryFactory registryFactory =                ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();                        Registry registry =                registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">"zookeeper://127.0.0.1:2181"</span>));        registry.register(URL.valueOf(<span class="hljs-string">"condition://0.0.0.0/com.zjn.service.HelloService?category=routers&amp;force=true&amp;dynamic=true&amp;rule="</span> + URL.encode(<span class="hljs-string">"=&gt; host != 你的机器ip不能是127.0.0.1"</span>)));    &#125;&#125;</code></pre></div><h4 id="5-2-路由规则详解"><a href="#5-2-路由规则详解" class="headerlink" title="5.2 路由规则详解"></a>5.2 路由规则详解</h4><p>通过上面的程序，我们实际本质上就是通过在zookeeper中保存一个节点数据，来记录路由规则。消费<br>者会通过监听这个服务的路径，来感知整个服务的路由规则配置，然后进行适配。<br>参数详解官方文档走起 -&gt; <a href="http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule-deprecated.html" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule-deprecated.html</a></p><h4 id="5-3-路由与上线系统结合"><a href="#5-3-路由与上线系统结合" class="headerlink" title="5.3 路由与上线系统结合"></a>5.3 路由与上线系统结合</h4><p>实战场景：一个dubbo的提供者要准备进行上线，一般都提供多台提供者来同时在线上提供服务。这时候一个请求刚到达一个提供者，提供者却进行了关闭操作。那么此次请求就应该认定为失败了。所以基于这样的场景，我们可以通过路由的规则，把预发布(灰度)的机器进行从机器列表中移除。并且等待一定的时间，让其把现有的请求处理完成之后再进行关闭服务。同时，在启动时，同样需要等待一定的时间，以免因为尚未重启结束，就已经注册上去。等启动到达一定时间之<br>后，再进行开启流量操作。</p><p><strong>实现主体思路 ：</strong></p><div class="hljs"><pre><code>1.利用zookeeper的路径感知能力，在服务准备进行重启之前将当前机器的IP地址和应用名写入zookeeper。2.服务消费者监听该目录，读取其中需要进行关闭的应用名和机器IP列表并且保存到内存中。3.当前请求过来时，判断是否是请求该应用，如果是请求重启应用，则将该提供者从服务列表中移除。</code></pre></div><p>具体操作流程：</p><ol><li>引入Curator 框架，操作Zookeeper</li><li>编写需要进行预发布的路径管理器，用于缓存和监听所有的待灰度机器信息列表。</li><li>编写路由类(实现org.apache.dubbo.rpc.cluster.Router )，主要目的在于对<br> ReadyRestartInstances中的数据进行处理，并且移除路由调用列表中正在重启中的服务。</li><li>由于Router 机制比较特殊，所以需要利用一个专门的RouterFactory来生成，原因在于并不是所有的都需要添加路由，所以需要利用@Activate 来锁定具体哪些服务才需要生成使用。</li></ol><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@Activate</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestartingInstanceRouterFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RouterFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Router <span class="hljs-title">getRouter</span><span class="hljs-params">(URL url)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestartingInstanceRouter(url); <span class="hljs-comment">// 自定义router实现类</span>    &#125;&#125;</code></pre></div><ol start="5"><li>对RouterFactory 进行注册，同样放入到 META-INF/dubbo/org.apache.dubbo.rpc.cluster.RouterFactory</li></ol><div class="hljs"><pre><code class="hljs undefined">restartInstances=com<span class="hljs-selector-class">.lagou</span><span class="hljs-selector-class">.router</span><span class="hljs-selector-class">.RestartingInstanceRouterFactory</span></code></pre></div><ol start="6"><li>完成对zk节点的操作，使得节点列表变更</li></ol><h3 id="6-服务动态降级"><a href="#6-服务动态降级" class="headerlink" title="6. 服务动态降级"></a>6. 服务动态降级</h3><h4 id="6-1-什么是服务降级"><a href="#6-1-什么是服务降级" class="headerlink" title="6.1 什么是服务降级"></a>6.1 什么是服务降级</h4><p>当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务有策略的降低服务级别，以释放服务器资源，保证核心任务的正常运行。</p><h4 id="6-2-为什么要服务降级"><a href="#6-2-为什么要服务降级" class="headerlink" title="6.2 为什么要服务降级"></a>6.2 为什么要服务降级</h4><p>防止分布式服务发生雪崩效应，什么是雪崩？就是蝴蝶效应，当一个请求发生超时，一直等待着服务响应，那么在高并发情况下，很多请求都是因为这样一直等着响应，直到<br>服务资源耗尽产生宕机，而宕机之后会导致分布式其他服务调用该宕机的服务也会出现资源耗尽宕机，这样下去将导致整个分布式服务都瘫痪，这就是雪崩。</p><h4 id="6-3-dubbo-服务降级实现"><a href="#6-3-dubbo-服务降级实现" class="headerlink" title="6.3 dubbo 服务降级实现"></a>6.3 dubbo 服务降级实现</h4><ul><li>在 dubbo 管理控制台配置服务降级<ul><li>mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。</li><li>mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。</li></ul></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/13/1734891d35c3a919?w=1246&h=464&f=png&s=276805" srcset="/img/loading.gif" alt></p><ul><li><p>配置xml 指定返回简单值或者null</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxService"</span> <span class="hljs-attr">check</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xx.XxService"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"3000"</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">"return null"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"xxService2"</span> <span class="hljs-attr">check</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.xx.XxService2"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"3000"</span> <span class="hljs-attr">mock</span>=<span class="hljs-string">"return 1234"</span> /&gt;</span></code></pre></div></li><li><p>注解 ：@Reference(mock=”return null”) @Reference(mock=”return 简单值”)<br>也支持 @Reference(mock=”force:return null”)</p></li><li><p>嵌入代码：</p>  <div class="hljs"><pre><code class="hljs java">RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();Registry registry=registryFactory.getRegistry(URL.valueOf("zookeeper://IP:端口"));registry.register(URL.valueOf("override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null"));</code></pre></div></li></ul><h2 id="四、-源码剖析"><a href="#四、-源码剖析" class="headerlink" title="四、 源码剖析"></a>四、 源码剖析</h2><h3 id="1-源码下载-amp-编译"><a href="#1-源码下载-amp-编译" class="headerlink" title="1. 源码下载&amp;编译"></a>1. 源码下载&amp;编译</h3><p>下载地址-&gt; <a href="https://github.com/apache/dubbo" target="_blank" rel="noopener">https://github.com/apache/dubbo</a> ，防止master不问题，可以切换 分支到 release 版本，下载本地执行 mvn install -DskipTests</p><h3 id="2-架构整体设计"><a href="#2-架构整体设计" class="headerlink" title="2. 架构整体设计"></a>2. 架构整体设计</h3><h4 id="2-1-调用关系说明"><a href="#2-1-调用关系说明" class="headerlink" title="2.1 调用关系说明"></a>2.1 调用关系说明</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17351be6584a2799?w=1378&h=884&f=png&s=512853" srcset="/img/loading.gif" alt></p><ul><li>provider : 服务提供方<ul><li>Protocol ： 协议交互</li><li>Service ：真实的服务接口实现</li><li>Container ： Dubbo的运行环境</li></ul></li><li>Consumer: 服务消费方<ul><li>Protocol ： 协议交互</li><li>Cluster ：感知提供者端的列表信息</li><li>Proxy ：理解成提供者的服务调用代理类由它接管Consumer中的接口调用逻辑</li></ul></li><li>Registry: 注册中心，用的zk</li><li>Monitor: 提供者和消费者中的数据统计，比如调用频次，成功失败次数等信息。</li></ul><p><strong>启动和执行流程说明</strong> :</p><ul><li>provider启动，容器负责把Service信息加载，通过Protocol注册到 Registry</li><li>Consumer启动，通过监听提供者列表来感知提供者信息 并在提供者发生改变时 通过注册中心及时通知消费端</li><li>消费方发起 请求 通过Proxy模块</li><li>利用Cluster模块 来选择真实的要发送给的提供者信息</li><li>交由Consumer中的Protocol 把信息发送给提供者</li><li>提供者同样需要通过 Protocol 模块来处理消费者的信息</li><li>最后由真正的服务提供者 Service 来进行处理</li></ul><h4 id="2-2-整体的调用链路"><a href="#2-2-整体的调用链路" class="headerlink" title="2.2 整体的调用链路"></a>2.2 整体的调用链路</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17351d50782401e9?w=1612&h=1474&f=png&s=1613107" srcset="/img/loading.gif" alt></p><ul><li><p>淡绿色 代表了服务生产者的范围</p></li><li><p>淡蓝色 代表了服务消费者的范围 </p></li><li><p>红色箭头 代表了调用的方向</p></li></ul><p>总结下简单流程：</p><ol><li>Consumer通过Interface进行方法调用交给消费端Proxy，使用jdk/javassist代理技术</li><li>交给filter 使用SPI机制统一过滤请求</li><li>invoker调用，去配置中心读取信息，获取所有Invoker<ol><li>通过Cluster，根据选择路由规则选取Invoker列表</li><li>通过LoadBalance 负载均衡选择一个Invoker处理请求</li><li>如果出错，开始重试机制</li></ol></li><li>继续通过filter功能选择具体执行协议</li><li>客户端进行编码和序列化，发送数据</li><li>数据到达Service，进行反编码和反序列化接收数据</li><li>使用Exporter选择执行器（dubbo，rmi…）</li><li>交给filter 进行一个提供者过滤，到达Invoker执行器</li><li>通过Invoker 调用接口的具体实现 然后返回</li></ol><h4 id="2-3-源码整体设计"><a href="#2-3-源码整体设计" class="headerlink" title="2.3 源码整体设计"></a>2.3 源码整体设计</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/1735295ddc568609?w=1568&h=1210&f=png&s=2750668" srcset="/img/loading.gif" alt></p><p>码整体设计与调用链路十分相似。只不过这里可以看到接口的一些具体实现以及左侧也有更为详细的<strong>层次划分</strong>， 如下：。</p><ul><li>service 业务层 包括我们的业务代码 比如 接口 实现类 直接面向开发者<br>RPC层 远程过程调用层</li><li>config 配置层 对外提供配置 以ServiceConfig ReferenceConfig 为核心 可以直接初始化配置类 也可以解析配置文件生成</li><li>proxy 服务代理层 无论是生产者 还是消费者 框架都会产生一个代理类 整个过程对上层透明 就是业务层对远程调用无感</li><li>registry 注册中心层 封装服务地址的注册与发现 以服务的URL为中心</li><li>cluster 路由层 (集群容错层)提供了多个提供者的路由和负载均衡并且它桥接注册中心 以Invoker为核心</li><li>monitor 监控层 RPC调用相关的信息 如 调用次数 成功失败的情况 调用时间等 在这一层完成</li><li>protocol 远程调用层 封装RPC调用 无论是服务的暴露 还是 服务的引用 都是在Protocol中作为主功能入口负责Invoker的整个生命周期Dubbo中所有的模型都向Invoker靠拢</li><li>Remoting层 远程数据传输层</li><li>exchange 信息交换层 封装请求和响应的模式 如把请求由同步 转换成异步</li><li>transport 网络传输层 统一网络传输的接口 比如 netty 和 mina统一为一个网络传输接口</li><li>serialize 数据序列化层 负责管理整个框架中的数据传输的序列化 和反序列化</li></ul><h3 id="3-服务注册与消费源码剖析"><a href="#3-服务注册与消费源码剖析" class="headerlink" title="3. 服务注册与消费源码剖析"></a>3. 服务注册与消费源码剖析</h3><h4 id="3-1-注册中心Zookeeper剖析"><a href="#3-1-注册中心Zookeeper剖析" class="headerlink" title="3.1 注册中心Zookeeper剖析"></a>3.1 注册中心Zookeeper剖析</h4><p>我们可以选择Redis、Nacos、Zookeeper作为Dubbo的注册中心，<strong>Dubbo推荐用户使用Zookeeper作为注册中心。</strong></p><p><strong>注册中心Zookeeper目录结构</strong></p><p>假设有个最基本的demo为我们提供服务</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;&#125;</code></pre></div><p>则zk的目录结果如下：</p><div class="hljs"><pre><code class="hljs undefined">+- dubbo| +- com.lagou.service.HelloService| | +- consumers| | | +- consumer:<span class="hljs-comment">//192.168.1.102/com.lagou.service.HelloService?</span>application=dubbo-demo-annotationconsumer&amp;category=consumers<span class="hljs-variable">&amp;check</span>=false<span class="hljs-variable">&amp;dubbo</span>=<span class="hljs-number">2.0</span><span class="hljs-number">.2</span><span class="hljs-variable">&amp;init</span>=false<span class="hljs-variable">&amp;interface</span>=com.lagou.service.HelloService<span class="hljs-variable">&amp;methods</span>=sayHello,sayHelloWithPrint,sayHelloWithTransmission,sayHelloWithException<span class="hljs-variable">&amp;pid</span>=<span class="hljs-number">25923</span><span class="hljs-variable">&amp;release</span>=<span class="hljs-number">2.7</span><span class="hljs-number">.5</span><span class="hljs-variable">&amp;side</span>=consumer<span class="hljs-variable">&amp;sticky</span>=false<span class="hljs-variable">&amp;tim</span>estamp=<span class="hljs-number">1583896043650</span>| | +- providers| | | +- dubbo:<span class="hljs-comment">//192.168.1.102:20880/com.lagou.service.HelloService?</span>anyhost=true<span class="hljs-variable">&amp;application</span>=dubbo-demo-annotationprovider&amp;deprecated=false<span class="hljs-variable">&amp;dubbo</span>=<span class="hljs-number">2.0</span><span class="hljs-number">.2</span><span class="hljs-variable">&amp;dynamic</span>=true<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.lagou.service.HelloService<span class="hljs-variable">&amp;methods</span>=sayHello,sayHelloWithPrint,sayHelloWithTransmission,sayHelloWithException<span class="hljs-variable">&amp;pid</span>=<span class="hljs-number">25917</span><span class="hljs-variable">&amp;release</span>=<span class="hljs-number">2.7</span><span class="hljs-number">.5</span><span class="hljs-variable">&amp;side</span>=provider<span class="hljs-variable">&amp;telnet</span>=clear,exit,help,status,log,ls,ps,cd,pwd,invoke,trace,count,select,shutdown<span class="hljs-variable">&amp;timestamp</span>=<span class="hljs-number">15</span><span class="hljs-number">83896023597</span>| | +- configuration| | +- routers</code></pre></div><p>结构很明显，都在dubbo节点下，全限定接口名作为服务，底下有4个配置</p><ul><li>consumers:的消费者列表(URL)</li><li>providers:提供者列表(URL)</li><li>configuration:配置信息，provider或者consumer会通过读取这里的配<br>置信息来获取配置</li><li>routers:当消费者在进行获取提供者的时，会通过这里配置好的路由来进行适配匹配规则。</li></ul><p><strong>dubbo基本上很多时候都是通过URL的形式来进行交互获取数据的，在URL中也会保存<br>很多的信息。</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352c8c0c0cfe9e?w=1548&h=878&f=png&s=484882" srcset="/img/loading.gif" alt></p><p>如图所示：</p><ul><li>提供者会在providers 目录下进行自身的进行注册。</li><li>消费者会在consumers 目录下进行自身注册，并且监听provider 目录，以此通过监听提供者增加或者减少，实现服务发现。</li><li>Monitor模块会对整个服务级别做监听，用来得知整体的服务情况。以此就能更多的对整体情况做<br>监控。</li></ul><h4 id="3-2-服务的注册过程分析"><a href="#3-2-服务的注册过程分析" class="headerlink" title="3.2 服务的注册过程分析"></a>3.2 服务的注册过程分析</h4><p>服务注册(暴露)过程</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/15/17352cb7860b7678?w=1508&h=914&f=png&s=739178" srcset="/img/loading.gif" alt></p><p>debug调试分析下具体流程：</p><ol><li>启动源码的provider-demo</li><li>进入到org/apache/dubbo/config/ServiceConfig.java，服务配置</li><li>通过ProxyFactory 调用接口实现类中的 getInvoker 方法使用 ref 生成一个 AbstractProxyInvoker 实例，到这一步就完成具体服务到 Invoker 的转化。接下来就是 Invoker 转换到 Exporter 的过程。</li><li>最终调用 org.apache.dubbo.config.ServiceConfig#doExportUrlsFor1Protocol 把Invoker 转换成 Exporter</li><li>服务配置组装完成后，通过org.apache.dubbo.registry.integration.RegistryProtocol#export 将我们需要执行的信息注册并且导出。</li><li>调用AbstractRegistry的继承类org.apache.dubbo.registry.support.FailbackRegistry#register，像zk 完成create注册</li></ol><p><strong>详细说下Registry中的类目录结构 :</strong></p><div class="hljs"><pre><code class="hljs undefined">+- RegistryService|<span class="hljs-string"> +- Registry</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- AbstractRegistry</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- FailbackRegistry</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- ZookeeperRegistry</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- NacosRegistry</span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> </span>|<span class="hljs-string"> +- ...</span></code></pre></div><p>注册就是使用的FailbackRegistry#register，从名字中可以看出来，失败自动恢复，后台记录失败请求，调用<strong>addFailedRegistered内部通过 Timer定时器去定时重发功能</strong>。</p><h4 id="3-3-URL规则详解-和-服务本地缓存"><a href="#3-3-URL规则详解-和-服务本地缓存" class="headerlink" title="3.3 URL规则详解 和 服务本地缓存"></a>3.3 URL规则详解 和 服务本地缓存</h4><h5 id="3-3-1-URL规则详解"><a href="#3-3-1-URL规则详解" class="headerlink" title="3.3.1 URL规则详解"></a>3.3.1 URL规则详解</h5><p>URL demo :</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">protocol:</span><span class="hljs-comment">//host:port/path?key=value&amp;key=value // 模版</span><span class="hljs-symbol">provider:</span><span class="hljs-comment">//192.168.20.1:20883/com.zjn.service.HelloService?</span>anyhost=true<span class="hljs-variable">&amp;application</span>=serviceprovider2&amp;bind.ip=<span class="hljs-number">192.168</span><span class="hljs-number">.20</span><span class="hljs-number">.1</span><span class="hljs-variable">&amp;bind</span>.port=<span class="hljs-number">20883</span><span class="hljs-variable">&amp;category</span>=configurators<span class="hljs-variable">&amp;check</span>=false<span class="hljs-variable">&amp;deprecated</span>=false<span class="hljs-variable">&amp;dubbo</span>=<span class="hljs-number">2.0</span><span class="hljs-number">.2</span><span class="hljs-variable">&amp;dynamic</span>=true<span class="hljs-variable">&amp;generic</span>=false<span class="hljs-variable">&amp;interface</span>=com.zjn.service</code></pre></div><p>详解URL组成：</p><ul><li>protocol: 协议，一般像我们的provider 或者consumer 在这里都是人为具体的协议</li><li>host: 当前provider 或者其他协议所具体针对的地址，比较特殊的像override 协议所指定的</li><li>host就是0.0.0.0 代表所有的机器都生效</li><li>port: 和上面相同，代表所处理的端口号</li><li>path: 服务路径，在provider 或者consumer 等其他中代表着我们真实的业务接口</li><li>key=value: 这些则代表具体的参数，这里我们可以理解为对这个地址的配置。比如我们provider中需要具体机器的服务应用名，就可以是一个配置的方式设置上去。</li></ul><p><strong>注意：Dubbo中的URL与java中的URL是有一些区别的，如下：</strong></p><ul><li>这里提供了针对于参数的parameter 的增加和减少(支持动态更改)</li><li>提供缓存功能，对一些基础的数据做缓存.</li></ul><h5 id="3-3-2-服务本地缓存"><a href="#3-3-2-服务本地缓存" class="headerlink" title="3.3.2 服务本地缓存"></a>3.3.2 服务本地缓存</h5><p>上面说了会对基础数据进行缓存，dubbo调用者需要通过注册中心（例如：ZK）注册信息，获取提供者，但是如果频繁往从ZK获取信息，<strong>肯定会存在单点故障问题，所以dubbo提供了将提供者信息缓存在本地的方法。</strong> </p><ul><li>Dubbo在订阅注册中心的回调处理逻辑当中会保存服务提供者信息到本地缓存文件当中（同步/异步两种方式），以URL纬度进行全量保存。</li><li>Dubbo在服务引用过程中会创建registry对象并加载本地缓存文件，会优先订阅注册中心，订阅注册中<br>心失败后会访问本地缓存文件内容获取服务提供信息。</li></ul><p>保存缓存流程如下：</p><ul><li>通过 org.apache.dubbo.registry.support.AbstractRegistry#AbstractRegistry#loadProperties加载已存在配置文件</li><li>在通过 notify 方法 调用saveProperties</li><li>doSaveProperties 进行保存文件，加锁 将配置的文件信息保存到文件中。执行出现错误时，则交给专门的线程去进行重试</li></ul><h4 id="3-4-Dubbo-消费过程分析"><a href="#3-4-Dubbo-消费过程分析" class="headerlink" title="3.4 Dubbo 消费过程分析"></a>3.4 Dubbo 消费过程分析</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/17355929f6b2debf?w=1740&h=986&f=png&s=975668" srcset="/img/loading.gif" alt></p><p>首先 ReferenceConfig 类的 init 方法调用 createProxy() ,期间 使用Protocol 调用 refer 方法生成 Invoker实例(如上图中的红色部分)，这是服务消费的关键。接下来使用ProxyFactory把 Invoker转换为客户端需要的接口(如：HelloService)。</p><h3 id="4-Dubbo扩展SPI源码剖析"><a href="#4-Dubbo扩展SPI源码剖析" class="headerlink" title="4. Dubbo扩展SPI源码剖析"></a>4. Dubbo扩展SPI源码剖析</h3><p>SPI在之前都有使用过，其中最重要的类就是ExtensionLoader，它是所有Dubbo中SPI的入口。</p><p>getExtensionLoader 获取扩展点加载器 并加载所对应的所有的扩展点实现</p><p>getExtension 根据name 获取扩展的指定实现</p><h4 id="4-1-getExtensionLoader-加载过程"><a href="#4-1-getExtensionLoader-加载过程" class="headerlink" title="4.1 getExtensionLoader 加载过程"></a>4.1 getExtensionLoader 加载过程</h4><ul><li><p>org/apache/dubbo/common/extension/ExtensionLoader.java这里的构造函数 获取ExtensionFactory 对象：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ExtensionLoader</span><span class="hljs-params">(Class&lt;?&gt; type)</span> </span>&#123;    <span class="hljs-keyword">this</span>.type = type;    <span class="hljs-comment">// 这里需要对对象的工厂做额外的创建，可以看到扩展的工厂也是一个扩展点</span>    objectFactory = (type == ExtensionFactory.class ? <span class="hljs-keyword">null</span> :    ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());&#125;</code></pre></div></li><li><p>ExtensionFactory 通过传入扩展点类型和真正的名称来获取扩展的。这里就和我们SPI中的具体名称实现相挂钩。</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-meta">@SPI</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExtensionFactory</span> </span>&#123;    <span class="hljs-comment">/**    * Get extension.    *    * <span class="hljs-doctag">@param</span> type object type.    * <span class="hljs-doctag">@param</span> name object name.    * <span class="hljs-doctag">@return</span> object instance.    */</span>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getExtension</span><span class="hljs-params">(Class&lt;T&gt; type, String name)</span></span>;&#125;</code></pre></div></li><li><p>dubbo-common/src/main/resources/METAINF/<br>dubbo/internal/org.apache.dubbo.common.extension.ExtensionFactory 中看到，他默认有三个实现的提供</p></li></ul><div class="hljs"><pre><code class="hljs undefined">spring=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.SpringExtensionFactory</span>adaptive=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.AdaptiveExtensionFactory</span>spi=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.common</span><span class="hljs-selector-class">.extension</span><span class="hljs-selector-class">.factory</span><span class="hljs-selector-class">.SpiExtensionFactory</span></code></pre></div><ul><li><p>AdaptiveExtensionFactory实现类上有@Adaptive，优先最高的默认实现类。作用是代理其他的ExtensionFactory。其中比较重要的方法在于<br>getSupportedExtensions 方法，获取所有支持的扩展信息实现。</p></li><li><p>org.apache.dubbo.common.extension.ExtensionLoader#getSupportedExtensions 获取所有的扩展类信息，返回所有的扩展点名称</p></li><li><p>getExtensionClasses() 双重检查为空从进行加载信息 加载扩展类</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;    <span class="hljs-comment">// 从缓存中获取已加载的扩展类</span>    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();        <span class="hljs-comment">// 双重检查</span>        <span class="hljs-keyword">if</span> (classes == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 为空的话，则锁住，标识只会被执行一次</span>            <span class="hljs-keyword">synchronized</span> (cachedClasses) &#123;            classes = cachedClasses.get();            <span class="hljs-keyword">if</span> (classes == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 进行加载信息 加载扩展类</span>            classes = loadExtensionClasses();            cachedClasses.set(classes);            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> classes;&#125;</code></pre></div></li><li><p>进入到loadExtensionClasses,主要做了两件事情。1: 加载当前SPI的默认实现。2:<br>加载这个类的所有扩展点实现，并且按照name和Class对象的形式存储</p></li><li><p>之后就是各种load…从指定META-INF下几个子目录找并加载，最终到达loadClass类的实现，可以看到这里是最终进行完成类映射的地方。</p></li></ul><p>当执行完这几个方法之后，会对一下几个字段进行更新:</p><ul><li>cachedAdaptiveClass: 当前Extension类型对应的AdaptiveExtension类型(只能一个)</li><li>cachedWrapperClasses: 当前Extension类型对应的所有Wrapper实现类型(无顺序)</li><li>cachedActivates: 当前Extension实现自动激活实现缓存(map,无序)</li><li>cachedNames: 扩展点实现类对应的名称(如配置多个名称则值为第一个)</li></ul><h4 id="4-2-根据name获取扩展点的方法-getExtension"><a href="#4-2-根据name获取扩展点的方法-getExtension" class="headerlink" title="4.2 根据name获取扩展点的方法 getExtension"></a>4.2 根据name获取扩展点的方法 getExtension</h4><ul><li><p>getExtension 方法实现。这里面同样主要作用是根据name对扩展点进行处理和进行加锁来创建真实的引用，其中都是有使用缓存来处理。<strong>可见真正的实例对象在getExtension</strong></p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getExtension</span><span class="hljs-params">(String name, <span class="hljs-keyword">boolean</span> wrap)</span> </span>&#123;        <span class="hljs-keyword">if</span> (StringUtils.isEmpty(name)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Extension name == null"</span>);        &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-string">"true"</span>.equals(name)) &#123;            <span class="hljs-keyword">return</span> getDefaultExtension();        &#125;        <span class="hljs-comment">// 获取当前类的holder，实现原理和cachedClasses的方式相同，都是建立同一个引用后再进行加锁</span>        <span class="hljs-keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);        Object instance = holder.get();        <span class="hljs-comment">// 双重检查</span>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">synchronized</span> (holder) &#123;                instance = holder.get();                <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;                    instance = createExtension(name, wrap);                    holder.set(instance);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> (T) instance;    &#125;</code></pre></div></li><li><p>getOrCreateHolder 保证缓存</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Holder&lt;Object&gt; <span class="hljs-title">getOrCreateHolder</span><span class="hljs-params">(String name)</span> </span>&#123;    <span class="hljs-comment">// 获取当前名称的和对象Holder的映射关系</span>    Holder&lt;Object&gt; holder = cachedInstances.get(name);    <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 如果不存在的话，则使用putIfAbsent的原子操作来设置值，这个值可以保证多线程的额情</span>    况下有值的时候不处理，没有值进行保存    cachedInstances.putIfAbsent(name, <span class="hljs-keyword">new</span> Holder&lt;&gt;());    <span class="hljs-comment">// 获取真实的holder处理器</span>    holder = cachedInstances.get(name);    &#125;    <span class="hljs-keyword">return</span> holder;&#125;</code></pre></div></li><li><p>进入到createExtension根据扩展的class名称来进行创建实例的类。这里也是创建扩展点类的主要实现。</p><div class="hljs"><pre><code class="hljs java">private T createExtension(String name) &#123;    // 从配置文件中加载所有的扩展类 可以得到配置项名称 到配置类的映射关系    Class&lt;?&gt; clazz = getExtensionClasses().get(name);    if (clazz == null) &#123;         throw findException(name);    &#125;    try &#123;        // 获取是否已经有实例了        T instance = (T) EXTENSION_INSTANCES.get(clazz);        if (instance == null) &#123;        // 没有的话，同样适用putIfAbsent的方式来保证只会创建一个对象并且保存        EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());        instance = (T) EXTENSION_INSTANCES.get(clazz);        &#125;        // 注入其他扩展点的实体，用于扩展点和其他的扩展点相互打通        injectExtension(instance);        // 进行遍历所有的包装类信息，分别对包装的类进行包装实例化，并且返回自身引用        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;        if (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;            for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;            // 同样进行注册其他扩展点的功能            （4） injectExtension 方法观察            instance = injectExtension((T)            wrapperClass.getConstructor(type).newInstance(instance));            &#125;        &#125;        // 对扩展点进行初始化操作        initExtension(instance);        return instance;    &#125; catch (Throwable t) &#123;        throw new IllegalStateException("Extension instance (name: " + name + ",        class: " +        type + ") couldn't be instantiated: " + t.getMessage(), t);    &#125;&#125;</code></pre></div></li><li><p>injectExtension 方法观察,检查类中的方法扩展点…</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">injectExtension</span><span class="hljs-params">(T instance)</span> </span>&#123;    <span class="hljs-keyword">if</span> (objectFactory <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 遍历其中的所有方法</span>        <span class="hljs-keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;            <span class="hljs-comment">// 是否是set方法</span>            <span class="hljs-comment">// 1. 以"set"开头</span>            <span class="hljs-comment">// 2. 参数长度为1</span>            <span class="hljs-comment">// 3. 是公开的方法</span>            <span class="hljs-keyword">if</span> (!isSetter(method)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">/**            * Check &#123;<span class="hljs-doctag">@link</span> DisableInject&#125; to see if we need auto injection for            this property            */</span>            <span class="hljs-comment">// 如果设置了取消注册，则不进行处理</span>            <span class="hljs-keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-comment">// 获取参数类型，并且非基础类型(String, Integer等类型)</span>            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="hljs-number">0</span>];            <span class="hljs-keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;                <span class="hljs-keyword">continue</span>;            &#125;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 获取需要set的扩展点名称</span>                String property = getSetterProperty(method);                <span class="hljs-comment">// 从ExtensionLoader中加载指定的扩展点</span>                <span class="hljs-comment">// 比如有一个方法为setRandom(LoadBalance loadBalance)，那么则以为着需</span>                要加载负载均衡中名为random的扩展点                Object object = objectFactory.getExtension(pt, property);                <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span>) &#123;                    <span class="hljs-number">4.3</span> Adaptive功能实现原理                    Adaptive的主要功能是对所有的扩展点进行封装为一个类，通过URL传入参数的时动态选择需要使用的                    扩展点。其底层的实现原理就是动态代理，这里我们会通过源码的形式告诉大家，他是如何通过动态代                    理进行加载的。                    （<span class="hljs-number">1</span>）这里我们getAdaptiveExtension 方法讲起，这个里面就是真正获取该类。这里可以看到，                    ExtentionLoader 中大量的使用了Holder和加锁的方式去进行唯一创建。                    method.invoke(instance, object);                &#125;            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                logger.error(<span class="hljs-string">"Failed to inject via method "</span> + method.getName()                + <span class="hljs-string">" of interface "</span> + type.getName() + <span class="hljs-string">": "</span> +                e.getMessage(), e);            &#125;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;        logger.error(e.getMessage(), e);    &#125;    <span class="hljs-keyword">return</span> instance;&#125;</code></pre></div><ul><li>最后完成实例化类</li></ul><h4 id="4-3-Adaptive功能实现原理"><a href="#4-3-Adaptive功能实现原理" class="headerlink" title="4.3 Adaptive功能实现原理"></a>4.3 Adaptive功能实现原理</h4><p>Adaptive的主要功能是对所有的扩展点进行封装为一个类，通过URL传入参数的时动态选择需要使用的扩展点。其底层的实现原理就是动态代理，这里我们会通过源码的形式告诉大家，他是如何通过动态代理进行加载的。</p><p>开始追源码：</p><ul><li>org.apache.dubbo.common.extension.ExtensionLoader#getAdaptiveExtension这个里面就是真正获取该类。这里可以看到，ExtentionLoader中大量的使用了Holder和加锁的方式去进行唯一创建。</li></ul><div class="hljs"><pre><code class="hljs undefined">public T getAdaptiveExtension() &#123;    // 和原先是用相同的方式，进行Holder和加锁的方式来保证只会被创建一次    Object<span class="hljs-built_in"> instance </span>= cachedAdaptiveInstance.get();   <span class="hljs-built_in"> if </span>(instance == null) &#123;        // 如果直接已经有创建并且错误的情况，则直接返回错误信息，防止重复没必要的创建       <span class="hljs-built_in"> if </span>(createAdaptiveInstanceError != null) &#123;           <span class="hljs-built_in"> throw </span>new IllegalStateException(<span class="hljs-string">"Failed to create adaptive instance:            "</span> +            createAdaptiveInstanceError.toString(),            createAdaptiveInstanceError);        &#125;        synchronized (cachedAdaptiveInstance) &#123;           <span class="hljs-built_in"> instance </span>= cachedAdaptiveInstance.get();               <span class="hljs-built_in"> if </span>(instance == null) &#123;                try &#123;                    // 这里真实的进行创建操作                   <span class="hljs-built_in"> instance </span>= createAdaptiveExtension();                    cachedAdaptiveInstance.set(instance);                &#125; catch (Throwable t) &#123;                    createAdaptiveInstanceError = t;                   <span class="hljs-built_in"> throw </span>new IllegalStateException(<span class="hljs-string">"Failed to create adaptive                    instance: "</span> + t.toString(), t);                &#125;            &#125;        &#125;    &#125;   <span class="hljs-built_in"> return </span>(T) instance;&#125;</code></pre></div><ul><li>进入createAdaptiveExtension,主要是进行了一些方法封装。</li><li>进入createAdaptiveExtensionClass，主要是进行生成Adaptive的代码，并且<br>进行编译生成class。</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;    <span class="hljs-comment">// 实例化一个新的Adaptive的代码生成器，并且进行代码生成</span>    String code = <span class="hljs-keyword">new</span> AdaptiveClassCodeGenerator(type,cachedDefaultName).generate();    <span class="hljs-comment">// 获取类加载器</span>    ClassLoader classLoader = findClassLoader();    <span class="hljs-comment">// 通过扩展点，寻找编译器, 目前有Java自带的编译器和Javassist的编译器，这里不做细展开</span>    org.apache.dubbo.<span class="hljs-keyword">common</span>.compiler.Compiler compiler =    ExtensionLoader.getExtensionLoader(org.apache.dubbo.<span class="hljs-keyword">common</span>.compiler.Compiler.cla    ss).getAdaptiveExtension();    <span class="hljs-comment">// 编译并且生成class</span>    <span class="hljs-keyword">return</span> compiler.compile(code, classLoader);&#125;</code></pre></div><ul><li><p>体通过AdaptiveClassLoaderCodeGenerator.generate方法来进行实现真正的代码生成。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> generate() &#123;    <span class="hljs-comment">// 如果没有任何方法标记为Adaptive，则不做处理</span>    <span class="hljs-keyword">if</span> (!hasAdaptiveMethod()) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"No adaptive method exist on extension "</span>        + type.getName() + <span class="hljs-string">", refuse to create the adaptive class!"</span>);    &#125;    <span class="hljs-comment">// 进行编写代码</span>    StringBuilder code = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-comment">// 生成包信息</span>    code.<span class="hljs-built_in">append</span>(generatePackageInfo());    <span class="hljs-comment">// 生成引用信息</span>    code.<span class="hljs-built_in">append</span>(generateImports());    <span class="hljs-comment">// 生成类声明</span>    （<span class="hljs-number">5</span>）这里主要对其中的每一个方法来做处理。具体主要观看generateMethod 方法。这里的很多方法    主要是依赖反射机制去进行方法封装，最终拼接为一个最终字符串。其中最关键的方法在于    generateMethodContent 方法来生成代理功能。    （<span class="hljs-number">6</span>） generateMethodContent 方法解读。这块儿更推荐通过debug的形式走进来, 看代码也更直接了    当(就可以直接按照常用功能中的SPI章节来debug)。这部分也是整个Adaptive中最为核心的代码，包括    获取扩展点名称并且执行。    code.<span class="hljs-built_in">append</span>(generateClassDeclaration());    <span class="hljs-comment">// 生成每一个方法</span>    Method[] methods = type.getMethods();    <span class="hljs-keyword">for</span> (Method method : methods) &#123;        code.<span class="hljs-built_in">append</span>(generateMethod(method));    &#125;    <span class="hljs-comment">// 输出最后的一个"&#125;"来结束当前类</span>    code.<span class="hljs-built_in">append</span>(<span class="hljs-string">"&#125;"</span>);    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;        logger.debug(code.toString());    &#125;    <span class="hljs-keyword">return</span> code.toString();&#125;</code></pre></div></li><li><p>具体主要观看generateMethod 方法。这里的很多方法<br>主要是依赖反射机制去进行方法封装，最终拼接为一个最终字符串。其中最关键的方法在于generateMethodContent 方法来生成代理功能。</p></li><li><p>generateMethodContent 整个Adaptive中最为核心的代码,拼接需要的部分类字符串，如下</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (arg0 == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);org.apache.dubbo.common.URL <span class="hljs-built_in">url</span> = arg0;<span class="hljs-built_in">String</span> extName = <span class="hljs-built_in">url</span>.getParameter(<span class="hljs-string">"hello.service"</span>, <span class="hljs-string">"human"</span>);<span class="hljs-keyword">if</span>(extName == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Failed to get extension (com.lagou.service.HelloService) name from url ("</span> + <span class="hljs-built_in">url</span>.toString() + <span class="hljs-string">") use keys([hello.service])"</span>);com.lagou.service.HelloService extension = (com.lagou.service.HelloService)ExtensionLoader.getExtensionLoader(com.lagou.service.HelloService.class).getExtension(extName);<span class="hljs-keyword">return</span> extension.sayHello(arg0);</code></pre></div><p><strong>总结：Adaptive功能实现原理就是把带有@Adaptive请求的接口转化字符串重新生产dubbo所需要的类字符串，使用ExtensionLoader#compile去编译生成最终目的是去extension执行 url所需要的实现类。</strong></p><h3 id="5-集群容错源码剖析"><a href="#5-集群容错源码剖析" class="headerlink" title="5. 集群容错源码剖析"></a>5. 集群容错源码剖析</h3><p>集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735787a133e2995?w=1454&h=724&f=png&s=690153" srcset="/img/loading.gif" alt></p><p>集群工作过程可分为两个阶段：</p><ul><li>第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。</li><li>第二个阶段是在服务消费者进行远程调用<br>时。以 FailoverClusterInvoker 为例，<ul><li>该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举<br>Invoker 列表可感知注册中心配置的变化。每次变化后，RegistryDirectory 会动态增删Invoker。</li><li>调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker</li><li>FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列<br>表中选择一个 Invoker。</li><li>最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker<br>实例的 invoke 方法，进行真正的远程调用。</li></ul></li></ul><p>Dubbo 主要提供了这样几种容错方式：</p><ul><li>Failover Cluster - 失败自动切换 失败时会重试其它服务器</li><li>Failfast Cluster - 快速失败 请求失败后快速返回异常结果 不重试</li><li>Failsafe Cluster - 失败安全 出现异常 直接忽略 会对请求做负载均衡</li><li>Failback Cluster - 失败自动恢复 请求失败后 会自动记录请求到失败队列中</li><li>Forking Cluster - 并行调用多个服务提供者 其中有一个返回 则立即返回结果</li></ul><h4 id="5-1-信息缓存接口Directory"><a href="#5-1-信息缓存接口Directory" class="headerlink" title="5.1 信息缓存接口Directory"></a>5.1 信息缓存接口Directory</h4><p>Directory是Dubbo中的一个接口，主要用于缓存当前可以被调用的提供者列表信息。我们在消费者进<br>行调用时都会通过这个接口来获取所有的提供者列表，再进行后续处理。</p><p>源码追踪：</p><ul><li>Directory 接口，通过Directory 来找到指定服务中的提<br>供者信息列表。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Directory</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Node</span> </span>&#123;    <span class="hljs-comment">// 获取服务的类型,也就是我们demo中所使用的HelloService</span>    <span class="hljs-function">Class&lt;T&gt; <span class="hljs-title">getInterface</span><span class="hljs-params">()</span></span>;    <span class="hljs-comment">// 根据本次调用的信息来获取所有可以被执行的提供者信息</span>    List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="hljs-keyword">throws</span> RpcException;    <span class="hljs-comment">// 获取所有的提供者信息</span>    List&lt;Invoker&lt;T&gt;&gt; getAllInvokers();&#125;</code></pre></div><ul><li>Directory实现类 -&gt; AbstractDirectory中的list#doList,依靠routerChain去决定真实返回的提供者列表。</li><li>到org/apache/dubbo/rpc/cluster/RouterChain.java#route，追到这里，发现invokers，我们先要去知道invoker 列表是从哪里生成获取的</li><li>根据开始调用链路图，发现 RegistryProtocol#refer#doRefer是Invoker 生成的部分关键代码。</li><li>url 绑定directory，cluster.join(directory) 加入到集群，生产Invoker，如下：</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doRefer</span><span class="hljs-params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> </span>&#123;        <span class="hljs-comment">// 实例化Directory</span>        RegistryDirectory&lt;T&gt; directory = <span class="hljs-keyword">new</span> RegistryDirectory&lt;T&gt;(type, url);        <span class="hljs-comment">// 设置注册中心和所使用的协议</span>        directory.setRegistry(registry);        directory.setProtocol(protocol);        <span class="hljs-comment">// all attributes of REFER_KEY</span>        <span class="hljs-comment">//生成监听路径URL</span>        Map&lt;String, String&gt; parameters = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;(directory.getConsumerUrl().getParameters());        URL subscribeUrl = <span class="hljs-keyword">new</span> URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="hljs-number">0</span>, type.getName(), parameters);        <span class="hljs-keyword">if</span> (directory.isShouldRegister()) &#123;            <span class="hljs-comment">// 在Directory中设置监听的consumerurl地址</span>            directory.setRegisteredConsumerUrl(subscribeUrl);            <span class="hljs-comment">// 在注册中心中注册消费者URL</span>            <span class="hljs-comment">// 也就是我们之前的Zookeeper的node中看到的consumer://</span>            registry.register(directory.getRegisteredConsumerUrl());        &#125;        <span class="hljs-comment">// 构建路由链</span>        directory.buildRouterChain(subscribeUrl);        <span class="hljs-comment">// 进行监听所有的的provider</span>        directory.subscribe(toSubscribeUrl(subscribeUrl));        <span class="hljs-comment">// 加入到集群中</span>        Invoker&lt;T&gt; invoker = cluster.join(directory);        List&lt;RegistryProtocolListener&gt; listeners = findRegistryProtocolListeners(url);        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(listeners)) &#123;            <span class="hljs-keyword">return</span> invoker;        &#125;        RegistryInvokerWrapper&lt;T&gt; registryInvokerWrapper = <span class="hljs-keyword">new</span> RegistryInvokerWrapper&lt;&gt;(directory, cluster, invoker, subscribeUrl);        <span class="hljs-keyword">for</span> (RegistryProtocolListener listener : listeners) &#123;            listener.onRefer(<span class="hljs-keyword">this</span>, registryInvokerWrapper);        &#125;        <span class="hljs-keyword">return</span> registryInvokerWrapper;    &#125;</code></pre></div><ul><li>回到RouterChain#route方法。这里所做的就是依次遍历所有的路由，然后分别执行并返回。这也就是整体的路由规则的实现。</li></ul><h4 id="5-2-路由规则实现原理"><a href="#5-2-路由规则实现原理" class="headerlink" title="5.2 路由规则实现原理"></a>5.2 路由规则实现原理</h4><ul><li>通过 org.apache.dubbo.rpc.cluster.router.condition.ConditionRouter#route 去map中判断是url是否在其中，如果不存在任何invoker则直接返回，有则加入到list</li><li>生成整个路由规则，ConditionRouter#init，解析根据”=&gt;”来判断when或者then条件，符合条件的加入到values列表中</li></ul><h4 id="5-3-Cluster组件"><a href="#5-3-Cluster组件" class="headerlink" title="5.3 Cluster组件"></a>5.3 Cluster组件</h4><p>主要用于代理真正的Invoker执行时做处理，提供了多种容错方案。源码追：</p><ul><li><p>接口</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 默认使用failover作为实现</span><span class="hljs-meta">@SPI</span>(FailoverCluster.NAME)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Cluster</span> </span>&#123;    <span class="hljs-comment">// 生成一个新的invoker</span>    <span class="hljs-meta">@Adaptive</span>    &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">join</span><span class="hljs-params">(Directory&lt;T&gt; directory)</span> <span class="hljs-keyword">throws</span> RpcException</span>;&#125;</code></pre></div></li><li><p>failover 只是进行new了一个新的Invoker。</p></li><li><p>AbstractClusterInvoker.invoke</p></li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;    <span class="hljs-comment">// 检查是否已经关闭了</span>    checkWhetherDestroyed();    <span class="hljs-comment">// 拷贝当前RPCContext中的附加信息到当前的invocation中</span>    Map&lt;String, String&gt; contextAttachments =    RpcContext.getContext().getAttachments();    <span class="hljs-keyword">if</span> (contextAttachments != <span class="hljs-keyword">null</span> &amp;&amp; contextAttachments.size() != <span class="hljs-number">0</span>) &#123;        ((RpcInvocation) invocation).addAttachments(contextAttachments);    &#125;    <span class="hljs-comment">// 找寻出所有支持的invoker，已经路由过的</span>    List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation);    <span class="hljs-comment">// 初始化负载均衡器</span>    LoadBalance loadbalance = initLoadBalance(invokers, invocation);    <span class="hljs-comment">// 用于适配异步请求使用</span>    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);    <span class="hljs-comment">// 交给子类进行真正处理请求</span>    <span class="hljs-keyword">return</span> doInvoke(invocation, invokers, loadbalance);&#125;</code></pre></div><ul><li>FailoverClusterInvoker#doInvoke,获取这个方法最大的重试次数,通过for循环的形式表示可以重试的次数,选择具体的invoker(交给负载均衡),最终实现 invoke代理执行。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, <span class="hljs-keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;        <span class="hljs-comment">// 如果没有任何的invoker则抛出异常</span>        List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers;        checkInvokers(copyInvokers, invocation);        <span class="hljs-comment">// 获取这个方法最大的重试次数</span>        String methodName = RpcUtils.getMethodName(invocation);        <span class="hljs-keyword">int</span> len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + <span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>) &#123;            len = <span class="hljs-number">1</span>;        &#125;        <span class="hljs-comment">// 通过for循环的形式表示可以重试的次数</span>        RpcException le = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// last exception.</span>        List&lt;Invoker&lt;T&gt;&gt; invoked = <span class="hljs-keyword">new</span> ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); <span class="hljs-comment">// invoked invokers.</span>        Set&lt;String&gt; providers = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(len);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 每次都执行一次是否关闭当前consumer的判断</span>                checkWhetherDestroyed();                <span class="hljs-comment">// 重新获取一遍invoker列表</span>                copyInvokers = list(invocation);                <span class="hljs-comment">// 再次进行一次存在invoker的检查</span>                checkInvokers(copyInvokers, invocation);            &#125;            <span class="hljs-comment">// 选择具体的invoker(交给负载均衡)</span>            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked);            <span class="hljs-comment">// 增加到已经执行过得invoker列表中</span>            invoked.add(invoker);            RpcContext.getContext().setInvokers((List) invoked);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// 让其真正的去进行执行操作</span>                Result result = invoker.invoke(invocation);                <span class="hljs-keyword">if</span> (le != <span class="hljs-keyword">null</span> &amp;&amp; logger.isWarnEnabled()) &#123;                    logger.warn(<span class="hljs-string">"Although retry the method "</span> + methodName                            + <span class="hljs-string">" in the service "</span> + getInterface().getName()                            + <span class="hljs-string">" was successful by the provider "</span> + invoker.getUrl().getAddress()                            + <span class="hljs-string">", but there have been failed providers "</span> + providers                            + <span class="hljs-string">" ("</span> + providers.size() + <span class="hljs-string">"/"</span> + copyInvokers.size()                            + <span class="hljs-string">") from the registry "</span> + directory.getUrl().getAddress()                            + <span class="hljs-string">" on the consumer "</span> + NetUtils.getLocalHost()                            + <span class="hljs-string">" using the dubbo version "</span> + Version.getVersion() + <span class="hljs-string">". Last error is: "</span>                            + le.getMessage(), le);                &#125;                <span class="hljs-keyword">return</span> result;            &#125; <span class="hljs-keyword">catch</span> (RpcException e) &#123;                <span class="hljs-comment">// 如果是业务异常则直接抛出</span>                <span class="hljs-keyword">if</span> (e.isBiz()) &#123;                    <span class="hljs-keyword">throw</span> e;                &#125;                le = e;            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;                le = <span class="hljs-keyword">new</span> RpcException(e.getMessage(), e);            &#125; <span class="hljs-keyword">finally</span> &#123;                providers.add(invoker.getUrl().getAddress());            &#125;        &#125;        <span class="hljs-comment">// 如果重试了指定次数后依旧失败，则直接认定为失败</span>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(le.getCode(), <span class="hljs-string">"Failed to invoke the method "</span>                + methodName + <span class="hljs-string">" in the service "</span> + getInterface().getName()                + <span class="hljs-string">". Tried "</span> + len + <span class="hljs-string">" times of the providers "</span> + providers                + <span class="hljs-string">" ("</span> + providers.size() + <span class="hljs-string">"/"</span> + copyInvokers.size()                + <span class="hljs-string">") from the registry "</span> + directory.getUrl().getAddress()                + <span class="hljs-string">" on the consumer "</span> + NetUtils.getLocalHost() + <span class="hljs-string">" using the dubbo version "</span>                + Version.getVersion() + <span class="hljs-string">". Last error is: "</span>                + le.getMessage(), le.getCause() != <span class="hljs-keyword">null</span> ? le.getCause() : le);    &#125;</code></pre></div><h4 id="5-4-负载均衡实现原理"><a href="#5-4-负载均衡实现原理" class="headerlink" title="5.4 负载均衡实现原理"></a>5.4 负载均衡实现原理</h4><p>过程比较简单就是选择具体负载均衡策略实现类，可以关注下策略算法：</p><ul><li>LoadBalance接口定义。这里默认选择了随机算法。</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// 默认使用随机算法</span><span class="hljs-meta">@SPI</span>(RandomLoadBalance.NAME)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalance</span> </span>&#123;    <span class="hljs-comment">// 进行选择真正的invoker</span>    <span class="hljs-meta">@Adaptive</span>(<span class="hljs-string">"loadbalance"</span>)    &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">select</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation    invocation)</span> <span class="hljs-keyword">throws</span> RpcException</span>;&#125;</code></pre></div><ul><li>LoadBalance 依旧选择了AbstractLoadBalance 作为基础的实现类。select 最终交给子类默认实现doSelect方法去执行。</li><li>默认算法走起：</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">doSelect</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> </span>&#123;        <span class="hljs-comment">// 总计的invoker列表数量</span>        <span class="hljs-keyword">int</span> length = invokers.size();        <span class="hljs-comment">// 默认每个invoker的权重都是相同的</span>        <span class="hljs-keyword">boolean</span> sameWeight = <span class="hljs-keyword">true</span>;        <span class="hljs-comment">// 所有的权重列表</span>        <span class="hljs-keyword">int</span>[] weights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];        <span class="hljs-comment">// 首个invoker的权重信息</span>        <span class="hljs-keyword">int</span> firstWeight = getWeight(invokers.get(<span class="hljs-number">0</span>), invocation);        weights[<span class="hljs-number">0</span>] = firstWeight;        <span class="hljs-comment">// 计算总共的权重，并且吧每一个invoker的权重进行设置到列表中</span>        <span class="hljs-keyword">int</span> totalWeight = firstWeight;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;            <span class="hljs-keyword">int</span> weight = getWeight(invokers.get(i), invocation);            <span class="hljs-comment">// save for later use</span>            weights[i] = weight;            <span class="hljs-comment">// Sum</span>            totalWeight += weight;            <span class="hljs-keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;                sameWeight = <span class="hljs-keyword">false</span>;            &#125;        &#125;        <span class="hljs-comment">// 如果权重不相同    10   30   50   100</span>        <span class="hljs-keyword">if</span> (totalWeight &gt; <span class="hljs-number">0</span> &amp;&amp; !sameWeight) &#123;            <span class="hljs-comment">// 通过总共的权重来随机分配</span>            <span class="hljs-keyword">int</span> offset = ThreadLocalRandom.current().nextInt(totalWeight);            <span class="hljs-comment">// 看看最终落到哪一个机器上去</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;                offset -= weights[i];                <span class="hljs-keyword">if</span> (offset &lt; <span class="hljs-number">0</span>) &#123;                    <span class="hljs-keyword">return</span> invokers.get(i);                &#125;            &#125;        &#125;        <span class="hljs-comment">// 如果权重都是相同的话，则随机选取一个即可</span>        <span class="hljs-keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));    &#125;</code></pre></div><h4 id="5-5-Invoker执行逻辑"><a href="#5-5-Invoker执行逻辑" class="headerlink" title="5.5 Invoker执行逻辑"></a>5.5 Invoker执行逻辑</h4><p>Invoker就是我们真实执行请求的组件。这里也会衍生出我们真正的Dubbo 或者Grpc 等其他协议的请求。</p><ul><li>找到Invoker接口</li><li>查看实现类org.apache.dubbo.rpc.protocol.AbstractInvoker#invoke主要做的<br>是基础信息封装，并且将请求真正的子类。</li><li>来到 org.apache.dubbo.rpc.protocol.dubbo.DubboInvoker#doInvoke </li><li>来到 org.apache.dubbo.remoting.exchange.support.header.HeaderExchangeChannel#send</li><li>最终选择Netty 的channel 实现</li></ul><h3 id="6-网络通信原理剖析"><a href="#6-网络通信原理剖析" class="headerlink" title="6. 网络通信原理剖析"></a>6. 网络通信原理剖析</h3><p>dubbo协议采用固定长度的消息头（16字节）和不定长度的消息体来进行数据传输，消息头定义了底层框架（netty）在IO线程处理时需要的信息，协议的报文格式如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/16/1735848d5bc97ab4?w=1896&h=1300&f=png&s=1040013" srcset="/img/loading.gif" alt></p><h4 id="6-1-数据包结构"><a href="#6-1-数据包结构" class="headerlink" title="6.1 数据包结构"></a>6.1 数据包结构</h4><p>协议详情:</p><ul><li>Magic - Magic High &amp; Magic Low (16 bits)<br>标识协议版本号，Dubbo 协议：0xdabb</li><li>Serialization ID (5 bit)<br>标识序列化类型：比如 fastjson 的值为6。</li><li>Event (1 bit)<br>标识是否是事件消息，例如，心跳事件。如果这是一个事件，则设置为1。</li><li>Two Way (1 bit)<br>仅在 Req/Res 为1（请求）时才有用，标记是否期望从服务器返回值。如果需要来自服务器的返回值，则设置为1。</li><li>Req/Res (1 bit)<br>标识是请求或响应。请求： 1; 响应： 0。</li><li>Status (8 bits)<br>仅在 Req/Res 为0（响应）时有用，用于标识响应的状态。<ul><li>20 - OK</li><li>30 - CLIENT_TIMEOUT</li><li>31 - SERVER_TIMEOUT</li><li>40 - BAD_REQUEST</li><li>50 - BAD_RESPONSE</li><li>60 - SERVICE_NOT_FOUND</li><li>70 - SERVICE_ERROR</li><li>80 - SERVER_ERROR</li><li>90 - CLIENT_ERROR</li><li>100 - SERVER_THREADPOOL_EXHAUSTED_ERROR</li></ul></li><li>Request ID (64 bits) 标识唯一请求。类型为long。</li><li>Data Length (32 bits) 序列化后的内容长度（可变部分），按字节计数。int类型。</li><li>Variable Part 被特定的序列化类型（由序列化ID标识）序列化后，每个部分都是一个 byte [] 或者 byte <ul><li>如果是请求包 ( Req/Res = 1)，则每个部分依次为：<ul><li>Dubbo version</li><li>Service name</li><li>Service version</li><li>Method name</li><li>Method parameter types</li><li>Method arguments</li><li>Attachments</li></ul></li><li>如果是响应包（Req/Res = 0）则每个部分依次为：<ul><li>返回值类型(byte)，标识从服务器端返回的值类型：</li><li>返回空值：RESPONSE_NULL_VALUE 2</li><li>正常响应值： RESPONSE_VALUE 1</li><li>异常：RESPONSE_WITH_EXCEPTION 0</li><li>返回值：从服务端返回的响应bytes</li></ul></li></ul></li></ul><div class="hljs"><pre><code class="hljs !">注意：对于(Variable Part)变长部分，当前版本的Dubbo 框架使用json序列化时，在每部分内容间额外增加了换行符作为分隔，请在Variable Part的每个part后额外增加换行符， 如： Dubbo version bytes (换行符) Service name bytes (换行符)</code></pre></div><p><strong>优点：</strong></p><ul><li>协议设计上很紧凑，能用 1 个 bit 表示的，不会用一个 byte 来表示，比如 boolean 类型的标识。</li><li>请求、响应的 header一致，通过序列化器对content组装特定的内容，代码实现起来简单。</li></ul><p><strong>可以改进的点 :</strong></p><ul><li><p>类似于 http 请求，通过 header 就可以确定要访问的资源，而 Dubbo 需要涉及到用特定序列化协议才可以将服务名、方法、方法签名解析出来，并且这些资源定位符是 string 类型或者 string数组，很容易转成 bytes，因此可以组装到 header 中。类似于 http2的header压缩，对于rpc调用的资源也可以协商出来一个int来标识，从而提升性能，如果在header 上组装资源定位符的话，该功能则更易实现。</p></li><li><p>通过 req/res 是否是请求后，可以精细定制协议，去掉一些不需要的标识和添加一些特定的标识。<br>比如status , twoWay 标识可以严格定制，去掉冗余标识。还有超时时间是作为 Dubbo 的attachment 进行传输的，理论上应该放到请求协议的header中，因为超时是网络请求中必不可少的。提到 attachment ，通过实现可以看到 attachment 中有一些是跟协议 content 中已有的字段是重复的，比如 path 和version等字段，这些会增大协议尺寸。</p></li><li><p>Dubbo 会将服务名<br>com.alibaba.middleware.hsf.guide.api.param.ModifyOrderPriceParam ，转换为Lcom/alibaba/middleware/hsf/guide/api/param/ModifyOrderPriceParam; ，理论上是不必要的，最后追加一个; 即可。</p></li><li><p>Dubbo 协议没有预留扩展字段，没法新增标识，扩展性不太好，比如新增响应上下文的功能，只有改协议版本号的方式，但是这样要求客户端和服务端的版本都进行升级，对于分布式场景很不友好。</p></li></ul><h4 id="6-2-数据协议ExchangeCodec详解"><a href="#6-2-数据协议ExchangeCodec详解" class="headerlink" title="6.2 数据协议ExchangeCodec详解"></a>6.2 数据协议ExchangeCodec详解</h4><p>ExchangeCodec 类，这个也是Dubbo在进行数据传输中的数据协议类。</p><ul><li>常量定义</li></ul><div class="hljs"><pre><code class="hljs java"><span class="hljs-comment">// header length.</span><span class="hljs-comment">// 请求头的长度</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HEADER_LENGTH = <span class="hljs-number">16</span>;<span class="hljs-comment">// magic header.</span><span class="hljs-comment">// 标示为0-15位  魔数</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">short</span> MAGIC = (<span class="hljs-keyword">short</span>) <span class="hljs-number">0xdabb</span>;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_HIGH = Bytes.short2bytes(MAGIC)[<span class="hljs-number">0</span>];<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> MAGIC_LOW = Bytes.short2bytes(MAGIC)[<span class="hljs-number">1</span>];<span class="hljs-comment">// message flag.</span><span class="hljs-comment">// 消息中的标示</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_REQUEST = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x80</span>;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_TWOWAY = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x40</span>;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span> FLAG_EVENT = (<span class="hljs-keyword">byte</span>) <span class="hljs-number">0x20</span>;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SERIALIZATION_MASK = <span class="hljs-number">0x1f</span>;</code></pre></div><ul><li>这个类中encode 和decode 分别用于将数据发送到ByteBuffer 中，还有就是将其反向的转换为对象。encode中的Request就是我们之前所讲的Request对象。</li></ul><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Object msg)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 处理请求对象</span>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Request) &#123;        encodeRequest(channel, buffer, (Request) msg);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> Response) &#123;        <span class="hljs-comment">// 处理响应</span>        encodeResponse(channel, buffer, (Response) msg);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 其他的交给上级处理，用于telnet模式</span>        <span class="hljs-keyword">super</span>.encode(channel, buffer, msg);    &#125;&#125;<span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 可读字节数</span>    <span class="hljs-keyword">int</span> readable = buffer.readableBytes();    <span class="hljs-comment">// 选取可读字节数 和  HEADER_LENGTH 中小的</span>    <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[Math.min(readable, HEADER_LENGTH)];    buffer.readBytes(header);    <span class="hljs-keyword">return</span> decode(channel, buffer, readable, header);&#125;</code></pre></div><ul><li>encodeRequest 方法。这里也验证了我们之前所讲的header内容</li></ul><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequest</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 请求的序列化类型</span>    Serialization serialization = getSerialization(channel);    <span class="hljs-comment">// header.   // 写入header信息</span>    <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];    <span class="hljs-comment">// set magic number. 设置魔数</span>    Bytes.short2bytes(MAGIC, header);    <span class="hljs-comment">// set request and serialization flag.   // 标记为请求</span>    header[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());    <span class="hljs-comment">// 是否是单向还是双向的(异步)</span>    <span class="hljs-keyword">if</span> (req.isTwoWay()) &#123;        header[<span class="hljs-number">2</span>] |= FLAG_TWOWAY;    &#125;    <span class="hljs-comment">// 是否为事件(心跳)</span>    <span class="hljs-keyword">if</span> (req.isEvent()) &#123;        header[<span class="hljs-number">2</span>] |= FLAG_EVENT;    &#125;    <span class="hljs-comment">// set request id.</span>    <span class="hljs-comment">// 写入当前的请求ID</span>    Bytes.long2bytes(req.getId(), header, <span class="hljs-number">4</span>);    <span class="hljs-comment">// encode request data.</span>    <span class="hljs-comment">// 保存当前写入的位置，将其写入的位置往后面偏移,保留出写入内容大小的位置，先进行写入body内容</span>    <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);    ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);    ObjectOutput out = serialization.serialize(channel.getUrl(), bos);    <span class="hljs-comment">// 按照数据内容的不同，来写入不同的内容</span>    <span class="hljs-keyword">if</span> (req.isEvent()) &#123;        encodeEventData(channel, out, req.getData());    &#125; <span class="hljs-keyword">else</span> &#123;        encodeRequestData(channel, out, req.getData(), req.getVersion());    &#125;    out.flushBuffer();    <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) &#123;        ((Cleanable) out).cleanup();    &#125;    bos.flush();    bos.close();    <span class="hljs-comment">// 记录body中写入的长度</span>    <span class="hljs-keyword">int</span> len = bos.writtenBytes();    checkPayload(channel, len);    <span class="hljs-comment">// 将其写入到header中的位置中</span>    Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);    <span class="hljs-comment">// write   // 发送到buffer中</span>    buffer.writerIndex(savedWriteIndex);    buffer.writeBytes(header); <span class="hljs-comment">// write header.</span>    buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);&#125;</code></pre></div><ul><li>org.apache.dubbo.remoting.exchange.codec.ExchangeCodec#encodeRequestData,在子类DubboCodec 中</li></ul><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequestData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data, String version)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    RpcInvocation inv = (RpcInvocation) data;    <span class="hljs-comment">// 写入版本</span>    out.writeUTF(version);    <span class="hljs-comment">// 接口全名称</span>    out.writeUTF(inv.getAttachment(PATH_KEY));    <span class="hljs-comment">// 接口版本号</span>    out.writeUTF(inv.getAttachment(VERSION_KEY));    <span class="hljs-comment">// 写入方法名称</span>    out.writeUTF(inv.getMethodName());    <span class="hljs-comment">// 调用参数描述信息</span>    out.writeUTF(inv.getParameterTypesDesc());    <span class="hljs-comment">// 所有的请求参数写入</span>    Object[] args = inv.getArguments();    <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;            out.writeObject(encodeInvocationArgument(channel, inv, i));        &#125;    &#125;    <span class="hljs-comment">// 写入所有的附加信息</span>    out.writeAttachments(inv.getObjectAttachments());&#125;</code></pre></div><ul><li>再看encodeResponse 方法实现。一样的，这里可以看到和写入request相似。</li></ul><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeResponse</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Response res)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();    <span class="hljs-keyword">try</span> &#123;        Serialization serialization = getSerialization(channel);        <span class="hljs-comment">// 和之前的参数一致</span>        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];        Bytes.short2bytes(MAGIC, header);        header[<span class="hljs-number">2</span>] = serialization.getContentTypeId();        <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;            header[<span class="hljs-number">2</span>] |= FLAG_EVENT;        &#125;        <span class="hljs-comment">// 写入状态码</span>        <span class="hljs-keyword">byte</span> status = res.getStatus();        header[<span class="hljs-number">3</span>] = status;        <span class="hljs-comment">// 写入内容</span>        Bytes.long2bytes(res.getId(), header, <span class="hljs-number">4</span>);        <span class="hljs-comment">// 和Request一样的内容写入方式，先写入内容，再写入长度</span>        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);        ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);        <span class="hljs-comment">// encode response data or error message.</span>        <span class="hljs-keyword">if</span> (status  == Response.OK) &#123;            <span class="hljs-keyword">if</span> (res.isHeartbeat()) &#123;                encodeEventData(channel, out, res.getResult());            &#125; <span class="hljs-keyword">else</span> &#123;                encodeResponseData(channel, out, res.getResult(), res.getVersion());            &#125;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 这里不太一样的地方在于，如果错误的时候，则直接将错误信息写入，不需要再交由序列化</span>            out.writeUTF(res.getErrorMessage());        &#125;        out.flushBuffer();        <span class="hljs-keyword">if</span> (out <span class="hljs-keyword">instanceof</span> Cleanable) &#123;            ((Cleanable) out).cleanup();        &#125;        bos.flush();        bos.close();        <span class="hljs-comment">// 一样的写入模式</span>        <span class="hljs-keyword">int</span> len = bos.writtenBytes();        checkPayload(channel, len);        Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);        buffer.writerIndex(savedWriteIndex);        buffer.writeBytes(header); <span class="hljs-comment">// write header.</span>        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        <span class="hljs-comment">// 写入出现异常</span>        buffer.writerIndex(savedWriteIndex);        <span class="hljs-comment">// send error message to Consumer, otherwise, Consumer will wait till timeout.</span>        <span class="hljs-keyword">if</span> (!res.isEvent() &amp;&amp; res.getStatus() != Response.BAD_RESPONSE) &#123;            Response r = <span class="hljs-keyword">new</span> Response(res.getId(), res.getVersion());            r.setStatus(Response.BAD_RESPONSE);            <span class="hljs-comment">// 如果是超过内容长度则重新设置内容大小并写入</span>            <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> ExceedPayloadLimitException) &#123;                logger.warn(t.getMessage(), t);                <span class="hljs-keyword">try</span> &#123;                    r.setErrorMessage(t.getMessage());                    channel.send(r);                    <span class="hljs-keyword">return</span>;                &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;                    logger.warn(<span class="hljs-string">"Failed to send bad_response info back: "</span> + t.getMessage() + <span class="hljs-string">", cause: "</span> + e.getMessage(), e);                &#125;            &#125;        &#125;        <span class="hljs-comment">// Rethrow exception</span>        <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> IOException) &#123;            <span class="hljs-keyword">throw</span> (IOException) t;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;            <span class="hljs-keyword">throw</span> (RuntimeException) t;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (t <span class="hljs-keyword">instanceof</span> Error) &#123;            <span class="hljs-keyword">throw</span> (Error) t;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(t.getMessage(), t);        &#125;    &#125;&#125;</code></pre></div><ul><li>解码在同样的类中，不做详细介绍了…</li></ul><h4 id="6-3-处理粘包和拆包问题"><a href="#6-3-处理粘包和拆包问题" class="headerlink" title="6.3 处理粘包和拆包问题"></a>6.3 处理粘包和拆包问题</h4><p><strong>拆包：</strong></p><div class="hljs"><pre><code>当发生TCP拆包问题时候 这里假设之前还没有发生过任何数据交互，系统刚刚初始化好，那么这个时候在InternalDecoder里面的buffer属性会是EMPTY_BUFFER。当发生第一次inbound数据的时候，第一次在InternalDecoder里面接收的肯定是dubbo消息头的部分（这个由TCP协议保证），由于发生了拆包情况，那么此时接收的inbound消息可能存在一下几种情况1、当前inbound消息只包含dubbo协议头的一部分2、当前inbound消息只包含dubbo的协议头3、当前inbound消息只包含dubbo消息头和部分payload消息通过上面的讨论，我们知道发生上面三种情况，都会触发ExchangeCodec返回NEED_MORE_INPUT，由于在DubboCountCodec对于返回NEED_MORE_INPUT会回滚读索引，所以此时的buffer里面的数据可以当作并没有发生过读取操作，并且DubboCountCodec的decode也会返回NEED_MORE_INPUT，在InternalDecoder对于当判断返回NEED_MORE_INPUT，也会进行读索引回滚，并且退出循环，最后会执行finally内容，这里会判断inbound消息是否还有可读的，由于在DubboCountCodec里面进行了读索引回滚，所以此时的buffer里面不是完整的inbound消息，等待第二次的inbound消息的到来，当第二次inbound消息过来的时候，再次经过上面的判断。</code></pre></div><div class="hljs"><pre><code class="hljs java"> <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">decode</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, <span class="hljs-keyword">int</span> readable, <span class="hljs-keyword">byte</span>[] header)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;    <span class="hljs-comment">// 检查魔数</span>    <span class="hljs-keyword">if</span> (readable &gt; <span class="hljs-number">0</span> &amp;&amp; header[<span class="hljs-number">0</span>] != MAGIC_HIGH            || readable &gt; <span class="hljs-number">1</span> &amp;&amp; header[<span class="hljs-number">1</span>] != MAGIC_LOW) &#123;        <span class="hljs-keyword">int</span> length = header.length;        <span class="hljs-keyword">if</span> (header.length &lt; readable) &#123;            header = Bytes.copyOf(header, readable);            buffer.readBytes(header, length, readable - length);        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; header.length - <span class="hljs-number">1</span>; i++) &#123;            <span class="hljs-keyword">if</span> (header[i] == MAGIC_HIGH &amp;&amp; header[i + <span class="hljs-number">1</span>] == MAGIC_LOW) &#123;                buffer.readerIndex(buffer.readerIndex() - header.length + i);                header = Bytes.copyOf(header, i);                <span class="hljs-keyword">break</span>;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.decode(channel, buffer, readable, header);    &#125;    <span class="hljs-comment">// check length. 不完整的包</span>    <span class="hljs-keyword">if</span> (readable &lt; HEADER_LENGTH) &#123;        <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;    &#125;    <span class="hljs-comment">// 获取数据长度</span>    <span class="hljs-keyword">int</span> len = Bytes.bytes2int(header, <span class="hljs-number">12</span>);    checkPayload(channel, len);    <span class="hljs-keyword">int</span> tt = len + HEADER_LENGTH;    <span class="hljs-comment">// 需要继续读取</span>    <span class="hljs-keyword">if</span> (readable &lt; tt) &#123;        <span class="hljs-keyword">return</span> DecodeResult.NEED_MORE_INPUT;    &#125;    <span class="hljs-comment">// limit input stream.</span>    ChannelBufferInputStream is = <span class="hljs-keyword">new</span> ChannelBufferInputStream(buffer, len);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 解码数据</span>        <span class="hljs-keyword">return</span> decodeBody(channel, is, header);    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (is.available() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;                    logger.warn(<span class="hljs-string">"Skip input stream "</span> + is.available());                &#125;                StreamUtils.skipUnusedStream(is);            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                logger.warn(e.getMessage(), e);            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs !">说明：如果解码返回DecodeResult.NEED_MORE_INPUT，说明信息不完整，需要读索引回滚，并且退出循环，最后会执 行finally内容，这里会判断inbound消息是否还有可读的，由于在DubboCountCodec里面进行了读索引 回滚，所以此时的buffer里面不是完整的inbound消息，等待第二次的inbound消息的到来，当第二次inbound消息过来的时候，再次经过上面的判断，如下代码：</code></pre></div><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// decode object.</span>    <span class="hljs-keyword">do</span> &#123;        saveReaderIndex = message.readerIndex();        <span class="hljs-keyword">try</span> &#123;            msg = codec.decode(channel, message);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            buffer = org.apache.dubbo.remoting.buffer.ChannelBuffers.EMPTY_BUFFER;            <span class="hljs-keyword">throw</span> e;        &#125;        <span class="hljs-keyword">if</span> (msg == Codec2.DecodeResult.NEED_MORE_INPUT) &#123;            <span class="hljs-comment">// 回滚重读</span>            message.readerIndex(saveReaderIndex);            <span class="hljs-keyword">break</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (saveReaderIndex == message.readerIndex()) &#123;                buffer = org.apache.dubbo.remoting.buffer.ChannelBuffers.EMPTY_BUFFER;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IOException(<span class="hljs-string">"Decode without read data."</span>);            &#125;            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span>) &#123;                Channels.fireMessageReceived(ctx, msg, event.getRemoteAddress());            &#125;        &#125;    &#125; <span class="hljs-keyword">while</span> (message.readable());&#125; <span class="hljs-keyword">finally</span> &#123;    <span class="hljs-comment">// 判断消息是否可读</span>    <span class="hljs-keyword">if</span> (message.readable()) &#123;        message.discardReadBytes();        buffer = message;    &#125; <span class="hljs-keyword">else</span> &#123;        buffer = org.apache.dubbo.remoting.buffer.ChannelBuffers.EMPTY_BUFFER;    &#125;    NettyChannel.removeChannelIfDisconnected(ctx.getChannel());&#125;</code></pre></div><p>messageReceived的核心就是message.readerIndex(saveReaderIndex) ，回滚重读。最后判断消息是否可读。</p><p><strong>粘包：</strong></p><div class="hljs"><pre><code>当发生TCP粘包的时候 是tcp将一个dubbo协议栈放在一个tcp包中，那么有可能发生下面几种情况1、当前inbound消息只包含一个dubbo协议栈2、当前inbound消息包含一个dubbo协议栈，同时包含部分另一个或者多个dubbo协议栈内容如果发生只包含一个协议栈，那么当前buffer通过ExchangeCodec解析协议之后，当前的buffer的readeIndex位置应该是buffer尾部，那么在返回到InternalDecoder中message的方法readable返回的是false,那么就会对buffer重新赋予EMPTY_BUFFER实体，而针对包含一个以上的dubbo协议栈，当然也会解析出其中一个dubbo协议栈，但是经过ExchangeCodec解析之后，message的readIndex不在message尾部，所以message的readable方法返回的是true。那么则会继续遍历message，读取下面的信息。最终要么message刚好整数倍包含完整的dubbo协议栈，要不ExchangeCodec返回NEED_MORE_INPUT,最后将未读完的数据缓存到buffer中,等待下次inbound事件，将buffer中的消息合并到下次的inbound消息中，种类又回到了拆包的问题上。dubbo在处理tcp的粘包和拆包时是借助InternalDecoder的buffer缓存对象来缓存不完整的dubbo协议栈数据，等待下次inbound事件，合并进去。</code></pre></div><p>总结 ： </p><p>在dubbo中解决TCP拆包和粘包的时候是通过buffer 变量来解决的。</p><ul><li>发生拆包肯定是接收消息不完整的，通过检查信息完整度返回NEED_MORE_INPUT消息，知道整合完整。</li><li>发生粘包也是消息包含一个完整或又同时包含多个dubbo协议内容，循环读取。如果还有不完整的最后解决不完整协议内容会又回到拆包问题上，等待下次inbound事件进行合并。</li></ul><div class="hljs"><pre><code class="hljs !">TCP拆包粘包问题：</code></pre></div><ul><li>接收到的是一个报文，它是由发送的两个报文组成的，这样对于应用程序来说就很难处理了（粘包）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/17/1735a8e319dfac39?w=1314&h=256&f=png&s=28108" srcset="/img/loading.gif" alt></p><ul><li>还有可能出现上面这样的虽然收到了两个包，但是里面的内容却是互相包含，对于应用来说依然无法解析（拆包）。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/17/1735a8e80c9385b8?w=1304&h=450&f=png&s=74029" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>精细Zookeeper </title>
    <link href="/2020/07/09/%E7%B2%BE%E7%BB%86Zookeeper/"/>
    <url>/2020/07/09/%E7%B2%BE%E7%BB%86Zookeeper/</url>
    
    <content type="html"><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>ZooKeeper主要的使用场景就是分布式协同服务，保证分布式信息的一致性。</p><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p>Zookeeper是一个典型的分布式数据一致性解决方案，分布式应用可以基于它实现数据订阅/发布、负载均衡、命名服务、集群服务、分布式锁和分布式队列等功能。</p><ul><li>集群角色：在zk中，没有沿用Master/Slave(主备)概念，而是引入了Leader、Follwer、Observer三种角色。通过Leader选举来选定一台Leader机器,Leader机器为客户端提供读写服务，其他角色提供读服务，<strong>唯一区别就是Observer不参与Leader选举过程、写操作过半成功策略</strong>，因此Oberver可以在不影响写性能情况下提高集群性能。</li><li>会话（session）：指一个客户端连接，代表客户端和服务器一个TCP长连接。通过连接，客户端通过心跳检测与服务器保持有效的会话，还能够接受服务器Watch事件。</li><li>数据节点（Znode）：机器节点，每个Znode保存自己的数据内容、属性信息。</li><li>版本：每个ZNode 都会维护一个Stat数据结构，Stat记录三个数据版本，分别是version（当前版本）、cversion（子节点版本）、aversion（ACL版本）。</li><li>Watch（事件监听）：节点注册Watch，会收到服务器事件通知，是Zookeeper重要特性。</li><li>ACL：权限控制策略，有5种：create（创建子节点权限）、read（获取节点数据和子节点权限）、write（更新节点数据权限）、delete（删除子节点权限）、admin（设置ACL权限），<strong>⚠️create、delete 都是针对子节点</strong></li></ul><h2 id="二、-环境搭建"><a href="#二、-环境搭建" class="headerlink" title="二、 环境搭建"></a>二、 环境搭建</h2><p>三种搭建方式：</p><ul><li>单机：适合测试</li><li>集群：适合生产</li><li>伪集群：一台服务器运行多个zk，适合生产前测试</li></ul><h3 id="1-单机部署"><a href="#1-单机部署" class="headerlink" title="1. 单机部署"></a>1. 单机部署</h3><ol><li><p>下载地址：<a href="https://zookeeper.apache.org/releases.html" target="_blank" rel="noopener">https://zookeeper.apache.org/releases.html</a></p></li><li><p>解压</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">tar</span> <span class="hljs-selector-tag">-zxvf</span> <span class="hljs-selector-tag">zookeeper-3</span><span class="hljs-selector-class">.4</span><span class="hljs-selector-class">.14</span><span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span></code></pre></div></li><li><p>创建data文件夹</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">cd</span> <span class="hljs-selector-tag">zookeeper-3</span><span class="hljs-selector-class">.4</span><span class="hljs-selector-class">.14</span><span class="hljs-selector-tag">mkdir</span> <span class="hljs-selector-tag">data</span></code></pre></div></li><li><p>修改配置</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">cd</span> <span class="hljs-selector-tag">conf</span><span class="hljs-selector-tag">mv</span> <span class="hljs-selector-tag">zoo_sample</span><span class="hljs-selector-class">.cfg</span> <span class="hljs-selector-tag">zoo</span><span class="hljs-selector-class">.cfg</span></code></pre></div></li><li><p>修改zoo.cfg 中data属性</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-title">dataDir</span>=/root/zookeeper<span class="hljs-number">-3.4</span><span class="hljs-number">.14</span>/<span class="hljs-class"><span class="hljs-keyword">data</span></span></code></pre></div></li><li><p>服务启动、看状态、停止</p><div class="hljs"><pre><code class="hljs undefined">./zkServer<span class="hljs-selector-class">.sh</span> start./zkServer<span class="hljs-selector-class">.sh</span> status./zkServer<span class="hljs-selector-class">.sh</span> stop</code></pre></div></li></ol><h3 id="2-伪集群部署"><a href="#2-伪集群部署" class="headerlink" title="2. 伪集群部署"></a>2. 伪集群部署</h3><p>保证端口号不冲突、dataDir也不同、在dataDir所在目录创建myid文件指定对应ZK实例</p><ul><li>clientPort：不同实例配置不同端口</li><li>dataDir、dataLogDir：将数据文件和日志文凯存放</li><li>server.X、myid 两个相互对应 1，2，3</li></ul><p>前几步与单机一样，主要是复制多个zk和配置变动：</p><ul><li><p>server 1:</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span> <span class="hljs-attr">dataDir</span>=/zkcluster/zookeeper01/data <span class="hljs-attr">dataLogDir</span>=/zkcluster/zookeeper01/data/logs</code></pre></div></li><li><p>server 2:</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">clientPort</span>=<span class="hljs-number">21812</span><span class="hljs-attr">dataDir</span>=/zkcluster/zookeeper02/data <span class="hljs-attr">dataLogDir</span>=/zkcluster/zookeeper02/data/logs</code></pre></div></li><li><p>更多服务配置…</p></li><li><p>配置集群：在每个zk的data下创建myid，分别是1，2，3，记录服务ID</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">touch myid</span></code></pre></div><ul><li>在每个zk的zoo.cfg 配置端口访问和集群服务IP列表</li></ul><div class="hljs"><pre><code class="hljs undefined">server<span class="hljs-meta">.1</span>=<span class="hljs-number">10.211</span><span class="hljs-meta">.55</span><span class="hljs-meta">.4</span>:<span class="hljs-number">2881</span>:<span class="hljs-number">3881</span>server<span class="hljs-meta">.2</span>=<span class="hljs-number">10.211</span><span class="hljs-meta">.55</span><span class="hljs-meta">.4</span>:<span class="hljs-number">2882</span>:<span class="hljs-number">3882</span>server<span class="hljs-meta">.3</span>=<span class="hljs-number">10.211</span><span class="hljs-meta">.55</span><span class="hljs-meta">.4</span>:<span class="hljs-number">2883</span>:<span class="hljs-number">3883</span>#server.服务器ID=服务器<span class="hljs-built_in">IP</span>地址:服务器之间通信端口:服务器之间投票选举端口</code></pre></div><ul><li>启动实例，完成集群</li></ul><h2 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h2><h3 id="1-系统模型"><a href="#1-系统模型" class="headerlink" title="1. 系统模型"></a>1. 系统模型</h3><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a27cd31b8034?w=1124&h=656&f=png&s=188105" srcset="/img/loading.gif" alt><br>根据斜杠分割表示路径。</p><h4 id="1-1-ZNode节点可分为三大类："><a href="#1-1-ZNode节点可分为三大类：" class="headerlink" title="1.1 ZNode节点可分为三大类："></a>1.1 ZNode节点可分为三大类：</h4><ul><li>持久性节点：一直存在，直到删除主动清除</li><li>持久顺序性节点：+ 顺序</li><li>临时性节点：生命周期和客户端会话绑定一起，会话结束便删除</li><li>顺序性节点：+ 顺序</li></ul><p>不同类型有不同类型的生命周期</p><h4 id="1-2-事务ID"><a href="#1-2-事务ID" class="headerlink" title="1.2 事务ID"></a>1.2 事务ID</h4><p>用ZXID表示，通常是一个64位数字，每一次ZXID对应一次新操作，间接直到zk处理更新操作的全局顺序</p><h4 id="1-3-ZNode-状态信息"><a href="#1-3-ZNode-状态信息" class="headerlink" title="1.3 ZNode 状态信息"></a>1.3 ZNode 状态信息</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a36e04586466?w=1326&h=676&f=png&s=482701" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined"> cZxid 就是 <span class="hljs-keyword">Create</span> ZXID，表示节点被创建时的事务<span class="hljs-keyword">ID</span>。ctime 就是 <span class="hljs-keyword">Create</span> <span class="hljs-built_in">Time</span>，表示节点创建时间。mZxid 就是 Modified ZXID，表示节点最后一次被修改时的事务<span class="hljs-keyword">ID</span>。mtime 就是 Modified <span class="hljs-built_in">Time</span>，表示节点最后一次被修改的时间。pZxid 表示该节点的子节点列表最后一次被修改时的事务 <span class="hljs-keyword">ID</span>。只有子节点列表变更才会更新 pZxid，子节点内容变更不会更新。cversion 表示子节点的版本号。dataVersion 表示内容版本号。aclVersion 标识acl版本ephemeralOwner 表示创建该临时节点时的会话 sessionID，如果是持久性节点那么值为 <span class="hljs-number">0</span> <span class="hljs-keyword">dataLength</span> 表示数据⻓度。numChildren 表示直系子节点数。</code></pre></div><h4 id="1-4-Watcher-gt-数据变更通知"><a href="#1-4-Watcher-gt-数据变更通知" class="headerlink" title="1.4 Watcher-&gt; 数据变更通知"></a>1.4 Watcher-&gt; 数据变更通知</h4><p>zk使用Watcher实现发布/订阅，流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a38b6156c9ee?w=866&h=492&f=png&s=100924" srcset="/img/loading.gif" alt></p><h4 id="1-5-ACL-gt-保证数据安全"><a href="#1-5-ACL-gt-保证数据安全" class="headerlink" title="1.5 ACL -&gt;保证数据安全"></a>1.5 ACL -&gt;保证数据安全</h4><p>从三方面理解ACL机制，权限模式 Scheme 、授权对象ID、权限Permission,通常使用<strong>scheme: id : permission 标识有效的ACL信息</strong> :</p><ul><li><p>权限模式 Scheme </p><ul><li>IP:通过IP地址粒度进行权限控制</li><li>Digest：最常用的，username:password 进行控制</li><li>World：对所有用户开放，world: anyone</li><li>Super：特殊的Digest，对任何节点操作</li></ul></li><li><p>授权对象：ID …</p></li></ul><h3 id="2-命令行操作"><a href="#2-命令行操作" class="headerlink" title="2. 命令行操作"></a>2. 命令行操作</h3><ul><li>进入客户端：<div class="hljs"><pre><code class="hljs undefined">./zkCli<span class="hljs-selector-class">.sh</span> 连接本地的zookeeper服务器./zkCli<span class="hljs-selector-class">.sh</span> -server ip:port 连接指定的服务器</code></pre></div></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/4/1731a4bcf9da16e3?w=1218&h=1142&f=png&s=714898" srcset="/img/loading.gif" alt></p><ul><li>创建节点：</li></ul><div class="hljs"><pre><code class="hljs undefined">create [<span class="hljs-string">-s</span>][<span class="hljs-symbol">-e</span>] path data acl//其中，-s或-e分别指定节点特性，顺序或临时节点，若不指定，则创建持久节点;acl用来进行权限控制。</code></pre></div><ul><li><p>创建永久节点</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">create</span> /zk-<span class="hljs-literal">permanent</span> <span class="hljs-number">123</span></code></pre></div></li><li><p>读取节点</p></li></ul><p>path表示的是指定数据节点的节点路径，例：get /zk-permanent</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">ls</span> path <span class="hljs-string">//</span> <span class="hljs-keyword">ls</span> 列出所有子节点、只能查看下一级子节点get path <span class="hljs-string">//</span> 可获取指定节点数据内容和属性信息<span class="hljs-keyword">ls</span>/  <span class="hljs-string">//</span> 获取根节点所有子节点</code></pre></div><ul><li>更新节点/删除节点 例：set /zk-test0000000000 4567 ，返回更新后信息，其中dataVersion 自增</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">set</span> <span class="hljs-keyword">path</span> <span class="hljs-keyword">data</span> [<span class="hljs-keyword">version</span>]<span class="hljs-keyword">delete</span> <span class="hljs-keyword">path</span> [<span class="hljs-keyword">version</span>]</code></pre></div><h3 id="3-api-使用"><a href="#3-api-使用" class="headerlink" title="3. api 使用"></a>3. api 使用</h3><p>引入</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>剩下的crud，直接交给搜索引擎…</p><h3 id="4-zk-开源客户端"><a href="#4-zk-开源客户端" class="headerlink" title="4. zk 开源客户端"></a>4. zk 开源客户端</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.101tec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>api使用更加方便简洁，剩下的，直接交给搜索引擎…</p><h3 id="5-Curator-客户端"><a href="#5-Curator-客户端" class="headerlink" title="5. Curator 客户端"></a>5. Curator 客户端</h3><p>提供了Fluent 编程风格支持，封装zk底层的细节开发工作，包括重连、反复注册Watcher。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><p>剩下的，直接交给搜索引擎…</p><h2 id="四、应用场景"><a href="#四、应用场景" class="headerlink" title="四、应用场景"></a>四、应用场景</h2><h3 id="1-数据发布-订阅"><a href="#1-数据发布-订阅" class="headerlink" title="1. 数据发布/订阅"></a>1. 数据发布/订阅</h3><p>发布/订阅有2种设计模式，推Push &amp; 拉Pull。在推模中，服务端将所有数据更新发给订阅的客户端，而拉是由客户端主动发起请求获取最新数据。通常采用轮寻。</p><p>zk采用推拉结合，客户端向服务端注册自己需要关注的节点，一旦该节点数据发生变更，服务器像客户端发送Watcher事件通知，收到消息主动向服务端获取最新数据。<strong>这种模式主要用于配置信息获取同步。</strong></p><h3 id="2-命名服务"><a href="#2-命名服务" class="headerlink" title="2. 命名服务"></a>2. 命名服务</h3><p>通常客户端能够根据指定名字获取资源实体、服务地址和提供者信息。来实现提供全局唯一ID的分配机制。其中比较常见的RPC就是使用这种机制。</p><p><strong>由于zk可以创建顺序节点，保证了同一节点下子节点是唯一的</strong>，所以直接按照存放文件的方法，设置节点，比如一个路径下不可能存在两个相同的文件名，这种定义创建节点，就是全局唯一ID，如下</p><div class="hljs"><pre><code class="hljs java">ZkClient zkClient = <span class="hljs-keyword">new</span> ZkClient(<span class="hljs-string">"127.0.0.1:2181"</span>, <span class="hljs-number">5000</span>);zkClient.createPersistentSequential(<span class="hljs-string">"/home/zjn/wyid"</span>,<span class="hljs-keyword">null</span>);</code></pre></div><p>获取节点直接拼接所定义的路径，方可得到全局唯一ID</p><h3 id="3-集群管理"><a href="#3-集群管理" class="headerlink" title="3. 集群管理"></a>3. 集群管理</h3><p>根据zk的<strong>watcher机制和会话结束临时节点自动删除</strong>两大特性可实现实时监控机器活动，实现集群管理。</p><h3 id="4-Master-选举"><a href="#4-Master-选举" class="headerlink" title="4. Master 选举"></a>4. Master 选举</h3><p>在分布式环境中，相同的业务应用分布在不同的机器上，有些业务逻辑（例如一些耗时的计算，网络I/O处理），往往只需要让整个集群中的某一台机器进行执行，其余机器可以共享这个结果，这样可以大大减少重复劳动，提高性能。</p><p>利用ZooKeeper的强一致性，能够保证在分布式高并发情况下节点创建的全局唯一性，即：同时有多个客户端请求创建 /currentMaster 节点，最终一定只有一个客户端请求能够创建成功。利用这个特性，就能很轻易的在分布式环境中进行集群选取了。（其实只要实现数据唯一性就可以做到选举，关系型数据库也可以，但是性能不好，设计也复杂）</p><h3 id="5-分布式锁"><a href="#5-分布式锁" class="headerlink" title="5. 分布式锁"></a>5. 分布式锁</h3><h4 id="5-1-实现排他锁"><a href="#5-1-实现排他锁" class="headerlink" title="5.1 实现排他锁"></a>5.1 实现排他锁</h4><p>在java中，可以利用zk提供的api实现分布式锁，具体流程为：</p><ul><li>定义锁：在zk中，通过数据节点表示一个锁，例如 “/exclusive_lock/lock” 可以被定义成一个锁，在使用中可定义个临时节点。</li><li>获取锁：创建节点成功就是抢锁成功，同时所有没获取到锁的客户需要到”/exclusive_lock” 注册一个子节点变更的Watcher监听，以便实时监听lock节点变更。</li><li>释放锁：由于定义临时节点，那在以下两种情况有可能释放锁： <ol><li>客户端宕机 </li><li>执行完业务逻辑后，主动删除</li></ol></li></ul><p>释放后，重新获取锁，整个流程如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731ceccd77199ad?w=666&h=654&f=png&s=136671" srcset="/img/loading.gif" alt></p><h4 id="5-2-实现共享锁（读锁）"><a href="#5-2-实现共享锁（读锁）" class="headerlink" title="5.2 实现共享锁（读锁）"></a>5.2 实现共享锁（读锁）</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731cfe54d39a3f1?w=686&h=460&f=png&s=53614" srcset="/img/loading.gif" alt><br>其实就是与写锁区分开，单独创建一个读的节点 例如 ：”/shared_lock/host1-R-0000000001”。</p><p><strong>这里说明下，在同一节点下创建任何带顺序子节点，都会使序号递增。</strong></p><p>下面摘抄下网络上的共享锁demo，方便配合解释理解：</p><div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.itcast.bigdata.zklock;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> org.apache.zookeeper.CreateMode;<span class="hljs-keyword">import</span> org.apache.zookeeper.WatchedEvent;<span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher;<span class="hljs-keyword">import</span> org.apache.zookeeper.Watcher.Event.EventType;<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;<span class="hljs-keyword">import</span> org.apache.zookeeper.ZooKeeper;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperShareLock</span> </span>&#123;    <span class="hljs-comment">// 会话超时</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SESSION_TIMEOUT = <span class="hljs-number">2000</span>;    <span class="hljs-comment">// zookeeper集群地址</span>    <span class="hljs-keyword">private</span> String hosts = <span class="hljs-string">"mini1:2181,mini2:2181,mini3:2181"</span>;    <span class="hljs-keyword">private</span> String groupNode = <span class="hljs-string">"locks"</span>;    <span class="hljs-keyword">private</span> String subNode = <span class="hljs-string">"sub"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> haveLock = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">private</span> ZooKeeper zk;    <span class="hljs-comment">// 记录自己创建的子节点路径</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String thisPath;    <span class="hljs-comment">/**     * 连接zookeeper     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connectZookeeper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        zk = <span class="hljs-keyword">new</span> ZooKeeper(hosts, SESSION_TIMEOUT, <span class="hljs-keyword">new</span> Watcher() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-comment">// 判断事件类型，此处只处理子节点变化事件</span>                    <span class="hljs-keyword">if</span> (event.getType() == EventType.NodeChildrenChanged &amp;&amp; event.getPath().equals(<span class="hljs-string">"/"</span> + groupNode)) &#123;                        <span class="hljs-comment">//获取子节点，并对父节点进行监听</span>                        List&lt;String&gt; childrenNodes = zk.getChildren(<span class="hljs-string">"/"</span> + groupNode, <span class="hljs-keyword">true</span>);                        String thisNode = thisPath.substring((<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span>).length());                        <span class="hljs-comment">// 去比较是否自己是最小id</span>                        Collections.sort(childrenNodes);                        <span class="hljs-keyword">if</span> (childrenNodes.indexOf(thisNode) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-comment">//访问共享资源处理业务，并且在处理完成之后删除锁</span>                            doSomething();                            <span class="hljs-comment">//重新注册一把新的锁</span>                            thisPath = zk.create(<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span> + subNode, <span class="hljs-keyword">null</span>, Ids.OPEN_ACL_UNSAFE,                                    CreateMode.EPHEMERAL_SEQUENTIAL);                        &#125;                    &#125;                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;);        <span class="hljs-comment">// 1、程序一进来就先注册一把锁到zk上</span>        thisPath = zk.create(<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span> + subNode, <span class="hljs-keyword">null</span>, Ids.OPEN_ACL_UNSAFE,                CreateMode.EPHEMERAL_SEQUENTIAL);        <span class="hljs-comment">// wait一小会，便于观察</span>        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">1000</span>));        <span class="hljs-comment">// 从zk的锁父目录下，获取所有子节点，并且注册对父节点的监听</span>        List&lt;String&gt; childrenNodes = zk.getChildren(<span class="hljs-string">"/"</span> + groupNode, <span class="hljs-keyword">true</span>);        <span class="hljs-comment">//如果争抢资源的程序就只有自己，则可以直接去访问共享资源</span>        <span class="hljs-keyword">if</span> (childrenNodes.size() == <span class="hljs-number">1</span>) &#123;            doSomething();            thisPath = zk.create(<span class="hljs-string">"/"</span> + groupNode + <span class="hljs-string">"/"</span> + subNode, <span class="hljs-keyword">null</span>, Ids.OPEN_ACL_UNSAFE,                    CreateMode.EPHEMERAL_SEQUENTIAL);        &#125;    &#125;    <span class="hljs-comment">/**     * 处理业务逻辑，并且在最后释放锁     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">try</span> &#123;            System.out.println(<span class="hljs-string">"gain lock: "</span> + thisPath);            Thread.sleep(<span class="hljs-number">2000</span>);            <span class="hljs-comment">// do something</span>        &#125; <span class="hljs-keyword">finally</span> &#123;            System.out.println(<span class="hljs-string">"finished: "</span> + thisPath);            <span class="hljs-comment">// 将thisPath删除, 监听thisPath的client将获得通知</span>            <span class="hljs-comment">// 相当于释放锁</span>            zk.delete(<span class="hljs-keyword">this</span>.thisPath, -<span class="hljs-number">1</span>);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        ZookeeperShareLock dl = <span class="hljs-keyword">new</span> ZookeeperShareLock();        dl.connectZookeeper();        Thread.sleep(Long.MAX_VALUE);    &#125;&#125;</code></pre></div><p>以上就是实现最简单的共享锁的逻辑。<br>如果升级为读写锁都有，其实实现读写锁核心就是判断读写顺序就可以 ，如下：</p><ol><li>创建完节点后，获取/shared_lock节点下所有子节点，并对该节点变更注册监听。    </li><li>确定自己的节点序号在所有子节点中的顺序。</li><li>对于读请求:若没有比自己序号小的子节点或所有比自己序号小的子节点都是读请求，那么表 明自己已经成功获取到共享锁，同时开始执行读取逻辑，若有写请求，则需要等待。对于写请求:若自己不 是序号最小的子节点，那么需要等待。</li><li>接收到Watcher通知后，重复步骤1</li></ol><h4 id="5-3-羊群效应"><a href="#5-3-羊群效应" class="headerlink" title="5.3 羊群效应"></a>5.3 羊群效应</h4><p>以上实现可以满足一般分布式集群竞争锁的需求（一般集群为10台机器以内），并且性能都还可以。但是机器规模扩大后，会出现问题，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d2622e1222b9?w=666&h=694&f=png&s=81526" srcset="/img/loading.gif" alt></p><p>以上会出现的问题，就是如果 host1完成读操作，并将节点删除，会通知所有节点，但是你如果理解上面讲的判断读写顺序，其实可以分析出，host1移除只影响host2，对其他机器并没有产生影响。<strong>如果同一时间有多个节点完成事务给大量节点进行通知，会对网络开销和性能造成巨大影响，这就是所谓的羊群效应。</strong></p><p>问题根源就是没有找准客户端真正关注的点，其实分布式锁的竞争核心是<strong>只需要关注比自己序号小的那个节点的变更情况</strong>就可以，不需要关注所有节点。</p><p>改进：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d3aa818f6c95?w=1058&h=974&f=png&s=445385" srcset="/img/loading.gif" alt></p><p><strong>核心：只对比自己小的节点注册Watcher机制</strong></p><p>至于demo就不放上来了，这么实现还是比较复杂的，合理运用搜索引擎…<br>最后建议在实际生产环境中，尽量去缩小锁的范围。能简化开发则简化。毕竟一般公司达不到大规模集群…</p><h3 id="6-分布式队列"><a href="#6-分布式队列" class="headerlink" title="6. 分布式队列"></a>6. 分布式队列</h3><h4 id="6-1-FIFO-先入先出"><a href="#6-1-FIFO-先入先出" class="headerlink" title="6.1 FIFO 先入先出"></a>6.1 FIFO 先入先出</h4><p>和创建共享锁差不多，判断自己序号是不是最小，是就等，不是就dosomeing…</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d46a923785e7?w=726&h=602&f=png&s=198338" srcset="/img/loading.gif" alt></p><h4 id="6-2-Barrier-分布式屏障"><a href="#6-2-Barrier-分布式屏障" class="headerlink" title="6.2 Barrier: 分布式屏障"></a>6.2 Barrier: 分布式屏障</h4><p><strong>可以理解成分布式闭锁</strong>，特指分布式一个协调条件，规定了一个队列元素必须聚焦后才能统一进行安排，否则一直等待。一般应用在大规模分布式计算应用场景。</p><p>设计思想如下：</p><p>设置一个/queue_barrier 节点，其数据内容赋值为一个数字n来代表Barrier 值，步骤如下：</p><ol><li><p>创建并设置值</p> <div class="hljs"><pre><code class="hljs undefined">create <span class="hljs-string">/queue_barrier</span> 10get <span class="hljs-string">/queue_barrier</span> <span class="hljs-string">//</span> 得到10</code></pre></div></li><li><p>通过 getChildren 获取所有子节点，同时对注册子节点变更的Watcher监听。</p></li><li><p>统计，数不足10个，需要等待。</p></li><li><p>接受Watch通知，重复步骤2</p></li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d4ed5678a5c9?w=880&h=690&f=png&s=188691" srcset="/img/loading.gif" alt></p><h2 id="五、深入进阶"><a href="#五、深入进阶" class="headerlink" title="五、深入进阶"></a>五、深入进阶</h2><h3 id="1-ZAB协议"><a href="#1-ZAB协议" class="headerlink" title="1. ZAB协议"></a>1. ZAB协议</h3><p>Zab协议是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复的原子广播协议，是Zookeeper保证数据一致性的核心算法。Zab借鉴了Paxos算法，但又不像Paxos那样，是一种通用的分布式一致性算法。它是特别为Zookeeper设计的支持<strong>崩溃恢复的原子广播协议</strong>。</p><p>ZAB核心是定义对于改变zk服务数据状态的事务请求的处理方式：</p><p>即:所有事务请求必须由一个全局唯一的服务器来协调处理，这样的服务器被称为Leader服务器，余下的 服务器则称为Follower服务器，Leader服务器负责将一个客户端事务请求转化成一个事务Proposal(提 议)，并将该Proposal分发给集群中所有的Follower服务器，之后Leader服务器需要等待所有 Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向 所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交，类似2pc</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731d6378f954ff4?w=1224&h=494&f=png&s=83797" srcset="/img/loading.gif" alt></p><p><strong>协议内容</strong></p><p>当整个集群启动过程中，或者当 Leader 服务器出现网络中弄断、崩溃退出或重启等异常时，Zab协议就会 进入崩溃恢复模式，选举产生新的Leader。当新的Leader出来了，同时，已有过半机器完成同步之后，ZAB协议将退出恢复模式。<strong>进入消息广播模式</strong>。这时，如果有一台遵守Zab协议的服务器加入集群，因为此时集群中已经存在一个Leader服务器在广播消息，那么该新加入的服务器自动进入恢复模式：找到Leader服务器，并且完成数据同步。同步完成后，作为新的Follower一起参与到消息广播流程中。如果集群中其他机器收到客户端事务请求后，那么会先转发Leader服务器，由Leader统一处理。</p><ul><li><p>崩溃恢复：<br>  一但出现崩溃，会导致数据不一致，ZAB的崩溃恢复开始起作用。有如下两个确保：</p><ol><li><p>ZAB协议需要确保已经在Leader提交的事务最终被所有服务器提交。</p></li><li><p>ZAB协议需要确保丢弃只在Leader服务器上被提出的事务。</p><p>最终决定了Leader选举算法：针对上两个要求，如果Leader选举算法<strong>保证新选举出来的Leader服务器拥有集群中所有机器最高编号（ZXID最大）的事务Proposal，那么就能保证新的Leader 一定具有已提交的所有提案</strong>，更重要是，如果这么做，可以省去Leader服务器检查Proposal的提交和丢弃工作的这一步。</p></li></ol></li></ul><ul><li><p>消息广播模式 ：</p><ol><li><p>在zookeeper集群中，数据副本的传递策略就是采用消息广播模式。zookeeper中农数据副本的同步方式与二段提交相似，但是却又不同。二段提交要求协调者必须等到所有的参与者全部反馈ACK确认消息后，再发送commit消息。要求所有的参与者要么全部成功，要么全部失败。二段提交会产生严重的阻塞问题。</p></li><li><p>Zab协议中 Leader 等待 Follower 的ACK反馈消息是指“只要半数以上的Follower成功反馈即可，不需要收到全部Follower反馈”</p></li><li><p>整个过程中，Leader为每个事务请求生产对应的Proposal，在广播前，为这个事务分配一个全局唯一ID，为ZXID（事务ID），必须按照递增的事务顺序进行处理。</p></li><li><p>具体流程如上图。</p></li></ol></li></ul><p><strong>运行时状态分析</strong></p><ul><li>LOOKING：Leader选举阶段</li><li>FOLLOWING：Follower 和Leader保持同步状态</li><li>LEADING：Leader服务器作为主进程领导状态</li></ul><p>所有进程初始状态都是LOOKING，之后选举Leader，有了Leader，会变成FOLLOWING，Leader变成 LEADING，当Leader崩溃后，所有进程变成LOOKING，重新选举。当 Leader与所有机器断开TCP连接，其他FOLLOWING会放弃这个Leader，同时转到 LOOKING，之后重新选举。</p><p><strong>ZAB与Paxos联系&amp;区别</strong></p><p>两者设计目标不一样，ZAB主要用于构建高可用分布式系统，Paxos 算法用于构建一致性状态机器。所有会有细微差别。但是ZAB就是在Paxos保证一致性基础上设计出高可用的协议。</p><h3 id="2-服务器角色"><a href="#2-服务器角色" class="headerlink" title="2. 服务器角色"></a>2. 服务器角色</h3><h4 id="Leader"><a href="#Leader" class="headerlink" title="Leader"></a>Leader</h4><p>zk的核心，主要工作如下：</p><div class="hljs"><pre><code>1. 事务请求的唯一调度和处理者，保证集群的顺序性。2. 集群各服务调度者。</code></pre></div><p><strong>请求处理链：</strong></p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e548fcfee4e0?w=1446&h=292&f=png&s=110564" srcset="/img/loading.gif" alt></p><ul><li>PrepRequestProcessor：请求预处理器。如创建请求事务头、事务体、会话检查、ACL检查和版本检查</li><li>ProposalRequestProcessor ：事务日志记录处理器。事务处理发起者，非事务请求直接转发CommitProcessor，对于事务请求还需要创建Proposal提议，并发送给所有Follower，进行一次集群内事务投票。同时ProposalRequestProcessor还会将事务请求交给SyncRequestProcessor进行事务日志记录。</li><li>SyncRequestProcessor： 事务日志记录处理器，记录日志，并触发zk进行快照。</li><li>AckRequestProcessor：记录日志后向Proposal的投票收集器发送ACK反馈。告知当前服务器已完成日志记录。</li><li>CommitProcessor ： 事务提交处理器。非事务请求，直接交付下一阶段。</li><li>ToBeCommitProcessor ： 此处理器有toBeApplied队列，用来存储已经被CommitProcessor处理过的可被提交的Proposal，将这些完成的交给FinalRequestProcessor，处理完成后从队列移除。</li><li>FinalRequestProcessor ：用来进行对客户端请求的返回之前的操作，针对事务操作，直接应用到内存数据库。</li></ul><h4 id="Follower"><a href="#Follower" class="headerlink" title="Follower"></a>Follower</h4><p>跟随者，主要工作如下：</p><div class="hljs"><pre><code>1. 处理非事务请求（读请求），转发事务请求给Leader2. 参与事务请求Proposal投票3. 参与Leader选举</code></pre></div><p>Follower也采用了责任链模式处理客户端请求。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e62dce0de73e?w=1268&h=430&f=png&s=99390" srcset="/img/loading.gif" alt></p><ul><li>FollowerRequestProcessor ： 事务请求转发器</li><li>SendAckRequestProcessor ： 事务日志记录反馈，完成日志记录后，向Leader发送ACK消息表面完成工作。</li></ul><h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>zk3.3开始引入的角色，观察最新状态，并变更。与Follower不同只是不参与投票、选举，只提供非事务服务。<br>处理链如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e66e90da3b4c?w=1192&h=148&f=png&s=40865" srcset="/img/loading.gif" alt></p><p>SyncRequestProcessor 只是在初始化 记录日志、快照。运行中Leader不会将请求投票发给Observer</p><h3 id="3-服务启动"><a href="#3-服务启动" class="headerlink" title="3. 服务启动"></a>3. 服务启动</h3><h4 id="五个步骤："><a href="#五个步骤：" class="headerlink" title="五个步骤："></a>五个步骤：</h4><ol><li>配置文件解析</li><li>初始化数据管理器</li><li>初始化网络I/O管理器</li><li>数据恢复</li><li>对外服务</li></ol><ul><li><strong>单机服务器启动流程</strong>：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e6ac3b89545a?w=1358&h=1000&f=png&s=253217" srcset="/img/loading.gif" alt></p><hr><ul><li><strong>集群服务器启动流程</strong>：</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e6c0e7bf0ba9?w=1406&h=1074&f=png&s=307315" srcset="/img/loading.gif" alt></p><h4 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h4><ol><li>初始化Leader选举。集群模式特有，Zookeeper首先会根据自身的服务器ID(SID)、最新的 ZXID(lastLoggedZxid)和当前的服务器epoch(currentEpoch)来生成一个初始化投票，在 初始化过程中，每个服务器都会给自己投票。然后，根据zoo.cfg的配置，创建相应Leader选举算法 实现，Zookeeper提供了三种默认算法(LeaderElection、AuthFastLeaderElection、 FastLeaderElection)，可通过zoo.cfg中的electionAlg属性来指定，但现只支持 FastLeaderElection选举算法。在初始化阶段，Zookeeper会创建Leader选举所需的网络I/O层 QuorumCnxManager，同时启动对Leader选举端口的监听，等待集群中其他服务器创建连接。</li><li>注册JMX服务。</li><li>检测当前服务器状态<br>运行期间，QuorumPeer会不断检测当前服务器状态。在正常情况下，Zookeeper服务器的状态 在LOOKING、LEADING、FOLLOWING/OBSERVING之间进行切换。在启动阶段，QuorumPeer的初始 状态是LOOKING，因此开始进行Leader选举。</li><li>Leader选举<br>ZooKeeper的Leader选举过程，简单地讲，就是一个集群中所有的机器相互之间进行一系列投 票，选举产生最合适的机器成为Leader，同时其余机器成为Follower或是Observer的集群机器⻆ 色初始化过程。关于Leader选举算法，简而言之，就是集群中哪个机器处理的数据越新(通常我们根 据每个服务器处理过的最大ZXID来比较确定其数据是否更新)，其越有可能成为Leader。当然，如 果集群中的所有机器处理的ZXID一致的话，那么SID最大的服务器成为Leader，其余机器称为 Follower和Observer</li></ol><h4 id="Leader-Follower-启动期交互过程"><a href="#Leader-Follower-启动期交互过程" class="headerlink" title="Leader Follower 启动期交互过程"></a>Leader Follower 启动期交互过程</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/5/1731e747a193db8f?w=876&h=720&f=png&s=417301" srcset="/img/loading.gif" alt></p><h3 id="4-Leader选举"><a href="#4-Leader选举" class="headerlink" title="4. Leader选举"></a>4. Leader选举</h3><p>当zk集群一台服务器出现以下2种情况之一时候，需要进入Leader选举。</p><div class="hljs"><pre><code>1. 服务器初始化启动2. 服务器运行无法和Leader保持连接。</code></pre></div><p>分析以上两种情况：</p><ol><li><p>启动时期选举：</p><ul><li>每个Server发出一个投票</li><li>接受来自各个服务器的投票</li><li>处理投票（优先检查ZXID，相同就比较myid）</li><li>统计投票（ 判断是否已经有过半的机器接收到相同的投票信息，所谓“过半”就是指大于集群机器数量的一半，即大于或等于 (n/2+1)。对于这里由3台机器构成的集群，大于等于2台即为达到“过半”要求。）</li><li>改变服务器状态：Leader-&gt;LEADING, Follower-&gt;FOLLOWING</li></ul></li><li><p>服务运行期间的Leader选举：</p><ul><li>变更状态：Leader挂后，剩下的Follower都变成LOOKING，进入Leader选举</li><li>每个Server发出投票，第一轮都投自己，然后将自己投票发给所有机器</li><li>接收投票，与启动选举相同</li><li>处理投票，与启动选举相同</li><li>统计投票，与启动选举相同</li><li>改变服务器状态，与启动选举相同</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式理论&amp;自定义RPC</title>
    <link href="/2020/07/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-%E8%87%AA%E5%AE%9A%E4%B9%89RPC/"/>
    <url>/2020/07/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA-%E8%87%AA%E5%AE%9A%E4%B9%89RPC/</url>
    
    <content type="html"><![CDATA[<h2 id="一、分布式理论"><a href="#一、分布式理论" class="headerlink" title="一、分布式理论"></a>一、分布式理论</h2><h3 id="1-分布式架构"><a href="#1-分布式架构" class="headerlink" title="1. 分布式架构"></a>1. 分布式架构</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><p>就是业务拆分，与集群的区别是：前者是 做不同的事，后者是做相同的事。</p><p>分布式系统的特点：分布性、对等性、并发性、缺乏全局时钟、故障总发生。</p><h4 id="1-2-发展"><a href="#1-2-发展" class="headerlink" title="1.2 发展"></a>1.2 发展</h4><p>阿里巴巴发起的”去 IOE”运动(IOE 指的是 IBM 小型机、Oracle 数据库、EMC 的高端存储)。为什么要去IOE？</p><ol><li>升级单机处理能力的性价比越来越低</li><li>单机处理能力存在瓶颈</li><li>稳定性和可用性这两个指标很难达到</li></ol><h4 id="1-3-演变"><a href="#1-3-演变" class="headerlink" title="1.3 演变"></a>1.3 演变</h4><p>单体-&gt;应用与数据库分离-&gt;集群-&gt;负载均衡-&gt;数据读写分离-&gt;➕ 搜索引擎 -&gt;➕缓存-&gt;数据库水平/垂直拆分-&gt;应用拆分-&gt;服务化</p><h3 id="2-分布式问题"><a href="#2-分布式问题" class="headerlink" title="2. 分布式问题"></a>2. 分布式问题</h3><ul><li><p>通信异常：网络不可用，会导致分布式系统无法顺利进行一次网络通信</p></li><li><p>网络分区：网络不连通，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个孤立的区域，分布式系统就会出现局部小集群造成数据不一致。</p></li><li><p>节点故障：服务器节点出现的宕机或”僵死”现象</p></li><li><p>三态：即成功、失败和超时</p></li></ul><h3 id="3-一致性"><a href="#3-一致性" class="headerlink" title="3. 一致性"></a>3. 一致性</h3><h4 id="3-1-一致性分类"><a href="#3-1-一致性分类" class="headerlink" title="3.1 一致性分类"></a>3.1 一致性分类</h4><ul><li><p>强一致性 ： 分布式很难实现</p></li><li><p>弱一致性 ： 不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，<br>但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态。</p></li><li><p>读写一致性 ：用户读取自己写入结果的一致性，保证用户永远能够第一时间看到自己更新的内容。比如我们发一条朋友圈，朋友圈的内容是不是第一时间被朋友看见不重要，但是一定要显示在自己的列表上。</p><p>  解决方案:</p><ol><li>一种方案是对于一些特定的内容我们每次都去主库读取。 （问题主库压力大）</li><li>我们设置一个更新时间窗口，在刚刚更新的一段时间内，我们默认都从主库读取，过了这个窗口之后，我们会挑选最近有过更新的从库进行读取</li><li>我们直接记录用户更新的时间戳，在请求的时候把这个时间戳带上，凡是最后更新时间小于这个时间戳的从库都<br>不予以响应。</li></ol></li><li><p>单调读一致性 : 本次读到的数据不能比上次读到的旧。多次刷新返回旧数据出现灵异事件。</p><p>  解决方案：通过hash 映射到同一台机器上。</p></li><li><p>因果一致性 ：如果节点 A 在更新完某个数据后通知了节点 B，那么节点 B 之后对该数据的访问和修改都是基于 A 更新后的值。于此同时，和节点 A 无因果关系的节点 C 的数据访问则没有这样的限制。</p></li><li><p>最终一致性 ：是所有分布式一致性模型当中最弱的。不考虑中间的任何状态，只保证经过一段时间之后，最终系统内数据正确。它最大程度上保证了系统的并发能力，也因此，在高并发的场景下，它也是使用最广的一致性模型。可以参考现在的共享单车场景。</p></li></ul><h3 id="4-CAP定理"><a href="#4-CAP定理" class="headerlink" title="4. CAP定理"></a>4. CAP定理</h3><p>CAP 理论含义是，一个分布式系统不可能同时满足一致性（C:Consistency)，可用性（A: Availability）和分区容错<br>性（P：Partition tolerance）这三个基本需求，最多只能同时满足其中的2个。</p><ul><li>C - Consistency ： 一致性是值<strong>写操作后读操作可以读到最新的数据状态</strong>，查询数据宁可返回失败也不返回旧数据。</li><li>A - Availability ：可用性是指任何操作都可以得到响应的结果,且<strong>不会出现响应超时或响应错误</strong>。（即使是旧数据，只要不返回超时就可以。）<strong>实现方案：1. 数据多节点同步 2. 不可以将数据库中资源锁定 3. 即使旧数据也要返回查询信息</strong></li><li>P - Partition tolerance ：分布式不可避免就是出现由于网络问题导致的节点通信失败或者服务挂掉，此时仍可以对外提供服务。<strong>实现方案：1. 用异步通知取代同步操作 2. 添加多个数据库节点</strong></li></ul><p><strong>CAP只能3选2，因为在分布式系统中，容错性P肯定是必须有的，所以这时候无非就两种情况，网络问题导致要么错误返回，要么阻塞等待，前者牺牲了一致性，后者牺牲了可用性。</strong></p><h3 id="5-BASE-理论"><a href="#5-BASE-理论" class="headerlink" title="5. BASE 理论"></a>5. BASE 理论</h3><p>BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个<br>短语的缩写，来自 ebay 的架构师提出。<strong>核心思想是：即使无法做到强一致性，但每个应用都可<br>以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</strong> 即各作出让步，理解为做事别走极端，中和下。<br>下面举几个例子：</p><ul><li>响应时间上的损失：出现故障或者高峰，查询结果可适当延长，以用户体验上限为主。</li><li>功能上的损失：例如淘宝双11，为保护系统稳定性，正常下单，其他边缘服务可暂时不可用。</li></ul><p>基于Base理论还提出了以下2个特性 ：</p><ul><li>Soft state（软状态）：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同<br>节点的数据副本之间进行数据同步的过程中存在延迟。</li><li>Eventually consistent（最终一致性）： 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终<br>一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</li></ul><h3 id="6-分布式事务"><a href="#6-分布式事务" class="headerlink" title="6. 分布式事务"></a>6. 分布式事务</h3><p>事务的基本特性：ACID，分布式事务就是微服务时代也要像单机时代一样，保证ACID。</p><h3 id="7-一致性协议-2PC"><a href="#7-一致性协议-2PC" class="headerlink" title="7. 一致性协议 2PC"></a>7. 一致性协议 2PC</h3><h4 id="1-2PC"><a href="#1-2PC" class="headerlink" title="1.  2PC"></a>1.  2PC</h4><p>2是指两个阶段，P是指准备阶段，C是指提交阶段。<br><img src="https://user-gold-cdn.xitu.io/2020/6/29/173006d858d987b9?w=1734&h=1422&f=png&s=254085" srcset="/img/loading.gif" alt><br><img src="https://user-gold-cdn.xitu.io/2020/6/29/173006e24830b3cb?w=1716&h=548&f=png&s=100496" srcset="/img/loading.gif" alt></p><p>优点： 简单 </p><p>缺点：同步阻塞，单点问题，数据不一致（整个过程都不是原子性，任何一步失败都可能导致不一致），过于保守（出现故障而导致协调者始终无法获取到所有参与者的响应信息的话，这时协调者只能依靠其自身的超时机制来判断是否需要中断事务）</p><h3 id="8-一致性协议-3PC"><a href="#8-一致性协议-3PC" class="headerlink" title="8. 一致性协议 3PC"></a>8. 一致性协议 3PC</h3><p>3PC，全称 “three phase commit”，是 2PC 的改进版，将 2PC 的 “提交事务请求” 过程一分为二，共形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/29/1730074d1bbb5eb6?w=1402&h=926&f=png&s=214892" srcset="/img/loading.gif" alt></p><p>2PC对比3PC </p><ol><li>首先对于<strong>协调者和参与者都设置了超时机制</strong>（在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收到参与者的消息则默认失败）,主要是避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种机制也侧面降低了整个事务的阻塞时间和范围。 </li><li>通过CanCommit、PreCommit、DoCommit三个阶段的设计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的 。</li><li>PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。</li><li><strong>3PC协议并没有完全解决数据不一致问题</strong>。</li></ol><h3 id="9-一致性算法-Paxos"><a href="#9-一致性算法-Paxos" class="headerlink" title="9. 一致性算法 Paxos"></a>9. 一致性算法 Paxos</h3><p>Paxos为了解决2PC和3PC的单个协调者，和后续增加多个协调者集群，该听谁的，而产生的。在Paxos算法中，有如下角色：</p><ul><li>Client 客户端：客户端向分布式系统发出请求，并等待响应。例如，对分布式文件服务器中文件的写请求。</li><li>Proposer 提案发起者 ：提案者提倡客户请求，试图说服Acceptor对此达成一致，并在发生冲突时充当协调者以推动协议向前发展</li><li>Acceptor 决策者 ：可以批准提案，Acceptor可以接受（accept）提案；如果某个提案被选定（chosen），那么该提案里的value就被选定了</li><li>Learners：最终决策的学习者，学习者充当该协议的复制因素</li></ul><p>如何保证Paxos算法的活性？</p><p>活性：最终一定会发生的事情：最终一定要选定value</p><p>解决：通过选取主Proposer，并规定只有主Proposer才能提出议案。</p><h3 id="10-一致性算法-Raft"><a href="#10-一致性算法-Raft" class="headerlink" title="10. 一致性算法 Raft"></a>10. 一致性算法 Raft</h3><p>Raft 是一种为了管理复制日志的一致性算法。Raft将一致性算法分解成了3模块</p><ol><li>领导人选举</li><li>日志复制</li><li>安全性</li></ol><p>Raft算法分为两个阶段，首先是选举过程，然后在选举出来的领导人带领进行正常操作，比如日志复制等。</p><p>这里的两个算法就不过多阐述…</p><h2 id="二、分布式系统设计策略"><a href="#二、分布式系统设计策略" class="headerlink" title="二、分布式系统设计策略"></a>二、分布式系统设计策略</h2><h3 id="1-心跳检测"><a href="#1-心跳检测" class="headerlink" title="1. 心跳检测"></a>1. 心跳检测</h3><p><img src="https://user-gold-cdn.xitu.io/2020/6/29/17300a6f1d49072a?w=1184&h=1072&f=png&s=323220" srcset="/img/loading.gif" alt></p><ul><li>周期检测心跳机制（设定超时时间）</li><li>累计失效检测机制（在周期检测心跳机制的基础上，统计一定周期内节点的返回情况，以此计算节点的“死亡”概率。另外，对于宣告“濒临死亡”的节点可以发起有限次数的重试，以作进一步判断。）**</li></ul><h3 id="2-高可用设计"><a href="#2-高可用设计" class="headerlink" title="2. 高可用设计"></a>2. 高可用设计</h3><p>经过设计来减少系统不能提供服务的时间。系统高可用性的常用设计模式包括三种：主备（Master-SLave）、互备（Active-Active）和集群（Cluster）模式。一般采用主备模式。</p><h3 id="3-容错性"><a href="#3-容错性" class="headerlink" title="3. 容错性"></a>3. 容错性</h3><p>系统对于错误包容的能力</p><h3 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h3><p>其关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的不同服务器节<br>点上，从而达到高可用性及较好的用户操作体验。</p><h2 id="三、分布式架构网络通信"><a href="#三、分布式架构网络通信" class="headerlink" title="三、分布式架构网络通信"></a>三、分布式架构网络通信</h2><h3 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1. 基本原理"></a>1. 基本原理</h3><p>基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、aio三种方式</p><h3 id="2-RPC"><a href="#2-RPC" class="headerlink" title="2. RPC"></a>2. RPC</h3><p>RPC全称为remote procedurecall，即远程过程调用。可以做到像本地调用一样调用远程服务，是一种进程间的通信方式，<strong>RPC并不是一个具体的技术，而是指整个网络远程调用过程。</strong></p><p>RPC架构：一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。</p><ul><li>客户端(Client)，服务的调用方。</li><li>客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li><li>服务端(Server)，真正的服务提供者。</li><li>服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。<br><img src="https://user-gold-cdn.xitu.io/2020/6/29/17300bece0339a47?w=1592&h=986&f=png&s=1062631" srcset="/img/loading.gif" alt></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/29/17300bfae56b636a?w=1358&h=1266&f=png&s=162833" srcset="/img/loading.gif" alt></p><h3 id="3-RMI"><a href="#3-RMI" class="headerlink" title="3. RMI"></a>3. RMI</h3><p>Java RMI 指的是远程方法调用 (Remote Method Invocation),是java原生支持的远程调用 ,采用JRMP（Java Remote Messageing protocol）作为通信协议，可以认为是纯java版本的分布式远程调用解决方案，这里的通信可以理解为一个虚拟机上的对象调用另一个虚拟机上对象的方法。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/29/17300c83441ecbe2?w=1292&h=1144&f=png&s=185479" srcset="/img/loading.gif" alt></p><h3 id="4-BIO、NIO、AIO"><a href="#4-BIO、NIO、AIO" class="headerlink" title="4. BIO、NIO、AIO"></a>4. BIO、NIO、AIO</h3><ul><li>BIO：一个socket连接一个线程。简单易用但资源开销太高。</li><li>NIO：<br><img src="https://user-gold-cdn.xitu.io/2020/6/29/17300cb6896dad24?w=762&h=590&f=png&s=89755" srcset="/img/loading.gif" alt><br>  当一个连接创建后，不会需要对应一个线程，这个连接会被注册到多路复用器，所以一个连接只需要一个线程即可，所有的连接需要一个线程就可以操作，该线程的多路复用器会轮训，发现连接有请求时，才开启一个线程处理。<strong>大多数情况下，1w个连接里面同一时刻只有少量的连接有数据可读。</strong></li><li>AIO：异步非阻塞IO。A代表asynchronize，主动通知，完成后会调用回调函数。使用场景：连接数目多且连接比较长（重操作）的架构，比如相册服务器。重点调用了OS参与并发操作，编程比较复杂。Java7开始支持</li></ul><h3 id="5-Netty"><a href="#5-Netty" class="headerlink" title="5. Netty"></a>5. Netty</h3><p>简化和流程化了 NIO 的开发过程，NIO 的 Bug。例如 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17300d384577a4e1?w=1544&h=932&f=png&s=284577" srcset="/img/loading.gif" alt></p><p>Netty模型：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17302ae16e332c98?w=1632&h=1018&f=png&s=263790" srcset="/img/loading.gif" alt></p><p>Netty 抽象出两组线程池， BossGroup 专门负责接收客 户端连接， WorkerGroup 专门负责网络读写操作。NioEventLoop 表示一个不断循环执行处理 任务的线程， <strong>每个NioEventLoop 都有一个selector</strong>，用于监听绑定在其上的socket网络通道。NioEventLoop内部采用串行化设计，从消息的读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送， 始终由 IO 线 程 NioEventLoop 负责。</p><h3 id="6-Netty核心组件"><a href="#6-Netty核心组件" class="headerlink" title="6. Netty核心组件"></a>6. Netty核心组件</h3><h4 id="6-1-ChannelHandler-及其实现类"><a href="#6-1-ChannelHandler-及其实现类" class="headerlink" title="6.1 ChannelHandler 及其实现类"></a>6.1 ChannelHandler 及其实现类</h4><p>ChannelHandler 接口定义了许多事件处理的方法，我们可以通过重写这些方法去实现具 体的业务逻辑。我们经常需要自定义一个Handler类去继承ChannelInboundHandlerAdapter， 然后通过 重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法：</p><ul><li>public void channelActive(ChannelHandlerContext ctx)， 通道就绪事件</li><li>public void channelRead(ChannelHandlerContext ctx, Object msg)， 通道读取数据事件</li><li>public void channelReadComplete(ChannelHandlerContext ctx) ， 数据读取完毕事件</li><li>public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)， 通道发生异常事件</li></ul><h4 id="6-2-ChannelPipeline"><a href="#6-2-ChannelPipeline" class="headerlink" title="6.2 ChannelPipeline"></a>6.2 ChannelPipeline</h4><p>ChannelPipeline 是一个 Handler 的集合， 它负责处理和拦截 inbound 或者 outbound 的事 件和操作， 相当于一个贯穿 Netty 的链。</p><ul><li>ChannelPipeline addFirst(ChannelHandler…handlers)，把一个业务处理类（handler） 添加到链中的第一个位置</li><li>ChannelPipeline addLast(ChannelHandler…handlers)，把一个业务处理类（handler） 添加到链中的最后一个位置</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/30/17302c2217871f50?w=1400&h=690&f=png&s=649514" srcset="/img/loading.gif" alt></p><h4 id="6-3-ChannelHandlerContext"><a href="#6-3-ChannelHandlerContext" class="headerlink" title="6.3 ChannelHandlerContext"></a>6.3 ChannelHandlerContext</h4><p>这 是 事 件 处 理 器 上 下 文 对 象 ， Pipeline 链 中 的 实 际 处 理 节 点 。 每 个 处 理 节 点ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。常用方法如下所示：</p><ul><li>ChannelFuture close()， 关闭通道</li><li>ChannelOutboundInvoker flush()， 刷新</li><li>ChannelFuture writeAndFlush(Object msg) ， 将 数 据 写 到 ChannelPipeline 中 当 前</li><li>ChannelHandler 的下一个 ChannelHandler 开始处理（出站）</li></ul><h4 id="6-4-ChannelFuture"><a href="#6-4-ChannelFuture" class="headerlink" title="6.4 ChannelFuture"></a>6.4 ChannelFuture</h4><p>表示 Channel 中异步 I/O 操作的结果， <strong>在 Netty 中所有的 I/O 操作都是异步的， I/O 的调 用会直接返回， 调用者并不能立刻获得结果， 但是可以通过 ChannelFuture 来获取 I/O 操作 的处理状态。</strong> 常用方法如下所示：</p><ul><li>Channel channel()， 返回当前正在进行 IO 操作的通道</li><li>ChannelFuture sync()， 等待异步操作执行完毕</li></ul><h4 id="6-5-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-5-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.5 EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.5 EventLoopGroup 和其实现类 NioEventLoopGroup</h4><p>EventLoopGroup 是一组 EventLoop 的抽象， Netty 为了更好的利用多核 CPU 资源， 一般 会有多个 EventLoop同时工作。<strong>每个EventLoop维护着一个Selector实例。EventLoopGroup提供next接口，可以从组里面按照一定规则获取其中一个 EventLoop 来处理任务。</strong> 在 Netty服务器端编程中，我们一般都需要提供两个EventLoopGroup，例如：BossEventLoopGroup和WorkerEventLoopGroup。</p><ul><li>public NioEventLoopGroup()， 构造方法</li><li>public Future&lt;?&gt; shutdownGracefully()， 断开连接， 关闭线程</li></ul><h4 id="6-6-ServerBootstrap-和-Bootstrap"><a href="#6-6-ServerBootstrap-和-Bootstrap" class="headerlink" title="6.6 ServerBootstrap 和 Bootstrap"></a>6.6 ServerBootstrap 和 Bootstrap</h4><p>ServerBootstrap 是 Netty中的服务器端启动助手，通过它可以完成服务器端的各种配置； Bootstrap 是 Netty 中的客户端启动助手， 通过它可以完成客户端的各种配置。 常用方法如下 所示：</p><ul><li>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于<br>服务器端， 用来设置两个 EventLoop</li><li>public B group(EventLoopGroup group) ， 该方法用于客户端， 用来设置一个 EventLoop</li><li>public B channel(Class&lt;? extends C&gt; channelClass)， 该方法用来设置一个服务器端的通道实现</li><li>public <t> B option(ChannelOption<t> option, T value)， 用来给 ServerChannel 添加配置</t></t></li><li>public <t> ServerBootstrap childOption(ChannelOption<t> childOption, T value)， 用来给接收到的通道添加配置</t></t></li><li>public ServerBootstrap childHandler(ChannelHandler childHandler)， 该方法用来设置业务处理类（自定义的 handler）</li><li>public ChannelFuture bind(int inetPort) ， 该方法用于服务器端， 用来设置占用的端口号</li><li>public ChannelFuture connect(String inetHost, int inetPort) 该方法用于客户端， 用来连接服务器端</li></ul><h3 id="7-实现基础RPC"><a href="#7-实现基础RPC" class="headerlink" title="7. 实现基础RPC"></a>7. 实现基础RPC</h3><p>主要注意编码器、解码器、序列化、客户端通过动态代理隐藏具体网络实现、服务端通过反射调用实现类来解藕。</p><p>源码地址-&gt; <a href="https://gitee.com/znbsmd/lagou_homework/tree/master/rpc_homework/code" target="_blank" rel="noopener">https://gitee.com/znbsmd/lagou_homework/tree/master/rpc_homework/code</a></p><blockquote><p><em>《lagouedu》分布式原理总结</em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>分布式集群架构场景化解决⽅案</title>
    <link href="/2020/06/27/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%9C%BA%E6%99%AF%E5%8C%96%E8%A7%A3%E5%86%B3%E2%BD%85%E6%A1%88/"/>
    <url>/2020/06/27/%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84%E5%9C%BA%E6%99%AF%E5%8C%96%E8%A7%A3%E5%86%B3%E2%BD%85%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="一、一致性Hash算法"><a href="#一、一致性Hash算法" class="headerlink" title="一、一致性Hash算法"></a>一、一致性Hash算法</h1><ul><li><p>简单介绍下Hash算法，⽐如说在安全加密领域MD5、SHA等加密算法，在数据存储和查找⽅⾯有Hash表等, 以上<br>都应⽤到了Hash算法。</p></li><li><p>查找效率(时间&amp;空间，时间优先) ：<br>  顺序查找法（for遍历） &lt; ⼆分查找（折半查找） &lt; 直接寻址法（数组） &lt;  开放寻址法（简单hash） &lt; 拉链法(hash+链表)。</p></li><li><p>如果Hash算法设计的⽐较好的话，那么查询效率会更接近于O(1)，如果Hash算法设计的⽐较low，那么<br>查询效率就会很低了 （<strong>hash冲突造成链表过长</strong>）</p></li></ul><h2 id="1-Hash算法应⽤场景"><a href="#1-Hash算法应⽤场景" class="headerlink" title="1. Hash算法应⽤场景"></a>1. Hash算法应⽤场景</h2><p>Hash算法在很多分布式集群产品中都有应⽤，⽐如分布式集群架构Redis、Hadoop、ElasticSearch，<br>Mysql分库分表，Nginx负载均衡等</p><p>主要的应⽤场景归纳起来两个：</p><ul><li><p>请求的负载均衡（⽐如nginx的ip_hash策略）</p><ul><li>如果没有IP_hash策略，那么如何实现会话粘滞？可以维护⼀张映射表，存储客户端IP或者sessionid与具体⽬标服务器的映射关系&lt;ip,tomcat1&gt;。不过缺点明显 ，用户多浪费空间，需要维护，成本大。</li><li>使用hash 算法实现得以解决。</li></ul></li><li><p>分布式存储</p><p>  例子 ：集群中有redis1，redis2，redis3 三台Redis服务器，查找时候使用hash(key1)%3=index，用余数定位服务器。（mysql分表同理）</p></li></ul><h2 id="2-普通Hash存在的问题"><a href="#2-普通Hash存在的问题" class="headerlink" title="2. 普通Hash存在的问题"></a>2. 普通Hash存在的问题</h2><p>以ip_hash为例，如果一个服务宕机了，需要重新求模重新计算。服务器多了，缩容和扩容都会出现问题，比如⽤户在原来服务器中的会话都会丢失。</p><h2 id="3-⼀致性Hash算法"><a href="#3-⼀致性Hash算法" class="headerlink" title="3. ⼀致性Hash算法"></a>3. ⼀致性Hash算法</h2><h4 id="3-1-设计思路"><a href="#3-1-设计思路" class="headerlink" title="3.1 设计思路"></a>3.1 设计思路</h4><p>思路如下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f3c8a682f68ed?w=1238&h=162&f=png&s=27861" srcset="/img/loading.gif" alt><br>1-&gt;2的32次⽅减1，把它想成一个闭环（hash环）我们把服务器的ip或者主机名求<br>hash值然后对应到hash环上，那么针对客户端⽤户，也根据它的ip进⾏hash求值，对应到环上某个位<br>置，然后如何确定⼀个客户端路由到哪个服务器处理呢？按照顺时针⽅向找最近的服务器节点。（<strong>简单理解为双方同时hash，找最近的节点）</strong><br><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f3eb9ae372df0?w=1282&h=782&f=png&s=224279" srcset="/img/loading.gif" alt></p><p>假如 3下线了，原来打到3的请求重新路由到4，对其他客户端没有影响。<strong>避免大量请求迁移</strong>，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f3ed78ddd6cc3?w=1090&h=738&f=png&s=207431" srcset="/img/loading.gif" alt></p><p>假如 增加了服务器5，原来到3 的路由到5，也是迁移了一小部分，<strong>避免了大量请求迁移</strong>。如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f3ef40628a0dd?w=1068&h=708&f=png&s=180428" srcset="/img/loading.gif" alt></p><p>综上，，每⼀台服务器负责⼀段，⼀致性哈希算法对于节点的增减都只需重定位环空间中的⼀⼩<br>部分数据，具有较好的容错性和可扩展性。</p><h4 id="3-2-数据倾斜问题"><a href="#3-2-数据倾斜问题" class="headerlink" title="3.2 数据倾斜问题"></a>3.2 数据倾斜问题</h4><p>但是节点太少的情况下，会产生数据倾斜问题。例如只有2台服务器，根据一致性hash，大量请求会打到节点1，节点2 负责的非常少。这就是<strong>数据倾斜问题</strong>。</p><h4 id="3-3-虚拟节点解决方案"><a href="#3-3-虚拟节点解决方案" class="headerlink" title="3.3 虚拟节点解决方案"></a>3.3 虚拟节点解决方案</h4><p>此时，虚拟节点解决方案就来了：将每一个节点计算多个hash，每个hash计算结果都设置成当前节点，成为<strong>虚拟节点</strong>。</p><p>具体做法：在服务器ip后面增加编号来实现，比如，可以为每台服务器计算三个虚拟节点， 如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f3f7be3fab24d?w=1340&h=568&f=png&s=153215" srcset="/img/loading.gif" alt></p><h2 id="4-手写一致性hash-帮助理解"><a href="#4-手写一致性hash-帮助理解" class="headerlink" title="4. 手写一致性hash 帮助理解"></a>4. 手写一致性hash 帮助理解</h2><p>github地址-&gt; <a href="https://github.com/znbsmd/handwriting_framework/tree/master/ConsistentHash" target="_blank" rel="noopener">https://github.com/znbsmd/handwriting_framework/tree/master/ConsistentHash</a></p><h2 id="5-Nginx-配置⼀致性Hash负载均衡策略"><a href="#5-Nginx-配置⼀致性Hash负载均衡策略" class="headerlink" title="5. Nginx 配置⼀致性Hash负载均衡策略"></a>5. Nginx 配置⼀致性Hash负载均衡策略</h2><p>ngx_http_upstream_consistent_hash 模块是⼀个负载均衡器，使⽤⼀个内部⼀致性hash算法来选择<br>合适的后端节点。<br>该模块可以根据配置参数采取不同的⽅式将请求均匀映射到后端机器，</p><ul><li>consistent_hash $remote_addr：可以根据客户端ip映射</li><li>consistent_hash $request_uri：根据客户端请求的uri映射</li><li>consistent_hash $args：根据客户端携带的参数进⾏映</li></ul><p>ngx_http_upstream_consistent_hash模块是⼀个第三⽅模块，需要下载安装后使⽤-&gt;<a href="https://github.com/replay/ngx_http_consistent_hash" target="_blank" rel="noopener">https://github.com/replay/ngx_http_consistent_hash</a>  使用步骤如下：</p><ul><li><p>解压到nginx 源码目录</p></li><li><p>./configure —add-module=/root/ngx_http_consistent_hash-master</p></li><li><p>make</p></li><li><p>make install</p></li><li><p>在nginx.conf⽂件中配置</p>  <div class="hljs"><pre><code class="hljs undefined">upstream zjnServer &#123;    consistent_hash <span class="hljs-variable">$request_uri</span>;<span class="hljs-comment">// 根据客户端请求的uri映射</span>    server 127<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span>:<span class="hljs-number">8080</span>;    server 127<span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.1</span>:<span class="hljs-number">8081</span>;&#125;</code></pre></div></li></ul><h1 id="二、集群时钟同步问题"><a href="#二、集群时钟同步问题" class="headerlink" title="二、集群时钟同步问题"></a>二、集群时钟同步问题</h1><h2 id="1-时钟不同步导致的问题"><a href="#1-时钟不同步导致的问题" class="headerlink" title="1. 时钟不同步导致的问题"></a>1. 时钟不同步导致的问题</h2><p>下单分发到不同的服务器，由于创建时间都是取系统时间，由于时间不同，导致数据错乱。</p><h2 id="2-集群时钟同步配置"><a href="#2-集群时钟同步配置" class="headerlink" title="2. 集群时钟同步配置"></a>2. 集群时钟同步配置</h2><ul><li><p>集群时钟同步思路</p><ul><li><p>分布式集群中各个服务器节点都可以连接互联⽹<br><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f4334602d0f58?w=1070&h=330&f=png&s=62511" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">#使⽤ ntpdate ⽹络时间同步命令</span>ntpdate -u ntp.api.<span class="hljs-keyword">bz </span><span class="hljs-comment">#从⼀个时间服务器同步时间</span></code></pre></div><p>最后使用crontab 定时任务去同步</p></li><li><p>分布式集群中某⼀个服务器节点可以访问互联⽹或者所有节点都不能够访问互联⽹</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f436632770682?w=1146&h=346&f=png&s=61019" srcset="/img/loading.gif" alt><br>选node1 作为主时间服务器，（如果这台服务器能够访问互联⽹，可以让这台服务器和⽹络时间保持同步，如果不能就⼿动设置⼀个时间）</p></li><li><p>设置好node1 时间</p></li><li><p>把A配置为时间服务器（修改/etc/ntp.conf⽂件）</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment"># 1、如果有 restrict default ignore，注释掉它</span><span class="hljs-comment"># 2、添加如下⼏⾏内容</span>restrict 172.17.0.0 mask 255.255.255.0 nomodify notrap #放开局域⽹同步功能,172.17.0.0是你的局域⽹⽹段<span class="hljs-built_in">server </span>127.127.1.0 # local<span class="hljs-built_in"> clock</span>fudge 127.127.1.0 stratum 10<span class="hljs-comment"># 3、重启⽣效并配置ntpd服务开机⾃启动</span><span class="hljs-built_in">service </span>ntpd restartchkconfig ntpd on</code></pre></div></li><li><p>集群中其他节点就可以从A服务器同步时间</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">ntpdate</span> 172<span class="hljs-selector-class">.17</span><span class="hljs-selector-class">.0</span><span class="hljs-selector-class">.17</span></code></pre></div></li></ul></li></ul><h1 id="三、分布式ID解决⽅案"><a href="#三、分布式ID解决⽅案" class="headerlink" title="三、分布式ID解决⽅案"></a>三、分布式ID解决⽅案</h1><p>分表后，ID不能重复</p><ul><li><p>UUID(可以⽤)</p>  <div class="hljs"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;         System.out.println(java.util.UUID.randomUUID().toString());    &#125;&#125;</code></pre></div></li><li><p>独⽴数据库的⾃增ID,设置单独的数据库，在插入前优先插入，单独维护（不推荐）</p></li><li><p>SnowFlake 雪花算法（可以⽤，推荐）</p></li><li><p>雪花算法是⼀个算法，基于这个算法可以⽣成ID，⽣成的ID是⼀个long型，那么在Java中⼀个long<br>型是8个字节，算下来是64bit，如下是使⽤雪花算法⽣成的⼀个ID的⼆进制形式示意：</p><p>  <img src="https://user-gold-cdn.xitu.io/2020/6/27/172f447b62d8b2a1?w=1134&h=536&f=png&s=150350" srcset="/img/loading.gif" alt><br>  ⼀些互联⽹公司也基于上述的⽅案封装了⼀些分布式ID⽣成器，⽐如滴滴的tinyid（基于数据库实现）、百度的uidgenerator（基于SnowFlake）和美团的leaf（基于数据库和SnowFlake）等</p></li><li><p>redis.incr (推荐)</p><ul><li><p>引入jedis jar</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>编写测试类</p><div class="hljs"><pre><code class="hljs undefined">Jedis jedis = <span class="hljs-keyword">new</span> Jedis(<span class="hljs-string">"127.0.0.1"</span>,<span class="hljs-number">6379</span>);    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">long</span> id = jedis.incr(<span class="hljs-string">"id"</span>);        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"从redis中获取的分布式id为："</span> + id);        &#125;     <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != jedis) &#123;        jedis.close();    &#125;&#125;</code></pre></div></li></ul></li></ul><h1 id="四、分布式调度问题"><a href="#四、分布式调度问题" class="headerlink" title="四、分布式调度问题"></a>四、分布式调度问题</h1><h2 id="1-分布式调度有两层含义"><a href="#1-分布式调度有两层含义" class="headerlink" title="1. 分布式调度有两层含义"></a>1. 分布式调度有两层含义</h2><ul><li>同一个定时任务部署多份，只有一个运行</li><li>定时任务拆分，同时执行</li></ul><h2 id="2-定时任务与消息队列的区别"><a href="#2-定时任务与消息队列的区别" class="headerlink" title="2. 定时任务与消息队列的区别"></a>2. 定时任务与消息队列的区别</h2><p>本质不同，定时任务是时间驱动，⽽MQ是事件驱动；定时任务作业更倾向于批处理，MQ倾向于逐条处理；</p><h2 id="3-定时任务的实现⽅式"><a href="#3-定时任务的实现⽅式" class="headerlink" title="3. 定时任务的实现⽅式"></a>3. 定时任务的实现⽅式</h2><p>任务调度框架Quartz</p><h2 id="4-分布式调度框架Elastic-Job"><a href="#4-分布式调度框架Elastic-Job" class="headerlink" title="4. 分布式调度框架Elastic-Job"></a>4. 分布式调度框架Elastic-Job</h2><p>Elastic-Job是当当⽹开源的⼀个分布式调度解决⽅案，基于Quartz⼆次开发的，由两个相互独⽴的⼦项<br>⽬Elastic-Job-Lite和Elastic-Job-Cloud组成。地址-&gt; ：<a href="https://github.com/elasticjob" target="_blank" rel="noopener">https://github.com/elasticjob</a></p><p>主要功能：</p><ul><li>分布式避免同一任务重复执行</li><li>基于cron表达式</li><li>弹性扩容，增加减少，能转移到别的实例执行</li><li>失效转移，执行失败后，转移其他实例执行</li><li>错过执⾏作业重触发 若因某种原因导致作业错过执⾏，⾃动记录错过执⾏的作业，并在上次作业完成后⾃动触发。</li><li>支持并行调度 支持任务分片，任务分⽚是指将⼀个任务分为多个⼩任务项在多个实例同时执⾏。</li><li>作业分⽚⼀致性 当任务被分⽚后，保证同⼀分⽚在分布式环境中仅⼀个执⾏实例。</li></ul><h4 id="4-1-Elastic-Job-Lite应⽤"><a href="#4-1-Elastic-Job-Lite应⽤" class="headerlink" title="4.1 Elastic-Job-Lite应⽤"></a>4.1 Elastic-Job-Lite应⽤</h4><p>jar包（API） + 安装zk软件</p><p>Elastic-Job依赖于Zookeeper进⾏分布式协调，所以需要安装Zookeeper软件（3.4.6版本以上）</p><ul><li><p>安装配置zk</p></li><li><p>引入jar</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.dangdang<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elastic-job-lite-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>定时任务实例…</p></li><li><p>Leader节点选举机制<br>  每个Elastic-Job的任务执⾏实例App作为Zookeeper的客户端来操作ZooKeeper的znode</p><ul><li>多个实例同时创建/leader节点</li><li>/leader节点只能创建⼀个，后创建的会失败，创建成功的实例会被选为leader节点，执⾏任务</li></ul></li></ul><h4 id="4-2-Elastic-Job-Lite轻量级去中⼼化的特点"><a href="#4-2-Elastic-Job-Lite轻量级去中⼼化的特点" class="headerlink" title="4.2 Elastic-Job-Lite轻量级去中⼼化的特点"></a>4.2 Elastic-Job-Lite轻量级去中⼼化的特点</h4><p><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f469538f1b30c?w=1276&h=602&f=png&s=125139" srcset="/img/loading.gif" alt></p><h4 id="4-2-任务分⽚"><a href="#4-2-任务分⽚" class="headerlink" title="4.2 任务分⽚"></a>4.2 任务分⽚</h4><p>ElasticJob可以把作业分为多个的task（每⼀个task就是⼀个任务分⽚），每<br>⼀个task交给具体的⼀个机器实例去处理（⼀个机器实例是可以处理多个task的），但是具体每个task<br>执⾏什么逻辑由我们⾃⼰来指定。<br><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f46ad0e00d4cf?w=1024&h=526&f=png&s=89997" srcset="/img/loading.gif" alt></p><p>Strategy策略定义这些分⽚项怎么去分配到各个机器上去，<strong>默认是平均分配</strong>，可以定制，⽐如某⼀个机<br>器负载 ⽐较⾼或者预配置⽐较⾼，那么就可以写策略。分⽚和作业本身是通过⼀个注册中⼼协调的，因<br>为在分布式环境下，状态数据肯定集中到⼀点，才可以在分布式中沟通。</p><h4 id="4-3-弹性扩容"><a href="#4-3-弹性扩容" class="headerlink" title="4.3 弹性扩容"></a>4.3 弹性扩容</h4><p>新增加⼀个运⾏实例app3，它会⾃动注册到注册中⼼，注册中⼼发现新的服务上线，注册中⼼会通知<br>ElasticJob 进⾏重新分⽚，那么总得分⽚项有多少，那么就可以搞多少个实例机器，⽐如完全可以分1000⽚<br>最多就可以有多少app实例，完全可以分1000⽚，那么就可以搞1000台机器⼀起执⾏作业</p><p>注意：</p><ol><li>分⽚项也是⼀个JOB配置，修改配置，重新分⽚，在下⼀次定时运⾏之前会重新调⽤分⽚算法，那么<br>这个分⽚算法的结果就是：哪台机器运⾏哪⼀个⼀⽚，这个结果存储到zk中的，主节点会把分⽚给分好<br>放到注册中⼼去，然后执⾏节点从注册中⼼获取信息(执⾏节点在定时任务开启的时候获取相应的分⽚)。</li><li>如果所有的节点挂掉值剩下⼀个节点，所有分⽚都会指向剩下的⼀个节点，这也是ElasticJob的⾼可⽤。</li></ol><h1 id="五、Session共享问题"><a href="#五、Session共享问题" class="headerlink" title="五、Session共享问题"></a>五、Session共享问题</h1><h2 id="1-Session问题原因分析"><a href="#1-Session问题原因分析" class="headerlink" title="1. Session问题原因分析"></a>1. Session问题原因分析</h2><p>因为Http协议是⽆状态，Http为什么要设计为⽆状态协议？早期都是静态⻚⾯⽆所谓有⽆状态，后来有动态的内容更丰富，就需要有状态，出现了两种⽤于保持Http状态的技术，那就是Cookie和Session。</p><p>使用nginx默认轮询策略，会出现Session打到不同的服务器问题。</p><h2 id="2-解决Session⼀致性的⽅案"><a href="#2-解决Session⼀致性的⽅案" class="headerlink" title="2. 解决Session⼀致性的⽅案"></a>2. 解决Session⼀致性的⽅案</h2><ul><li><p>Nginx的 IP_Hash 策略（可以使⽤）</p><ul><li>优点：配置简单，不⼊侵应⽤，不需要额外修改代码</li><li>缺点：<ul><li>服务器重启Session丢失</li><li>存在单点负载⾼的⻛险（恶意攻击）</li><li>单点故障问题（重新hash，导致会话丢失）</li></ul></li></ul></li><li><p>Session复制（不推荐）</p><ul><li>大数据时代缺点一堆，就不细说了</li></ul></li><li><p>redis，Session共享，Session集中存储（推荐）</p><ul><li><p>唯一缺点：对应⽤有⼊侵，引⼊了和Redis的交互代码（有专门jar包，暂无缺点）</p></li><li><p>引入jar</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ul><ul><li><p>配置redis</p><div class="hljs"><pre><code class="hljs undefined">spring<span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.database</span>=<span class="hljs-number">0</span>spring<span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.host</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>spring<span class="hljs-selector-class">.redis</span><span class="hljs-selector-class">.port</span>=<span class="hljs-number">6379</span></code></pre></div><ul><li>主run方法添加注解</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@EnableRedisHttpSession</span></code></pre></div><ul><li>原理：主要是在过滤器进行请求拦截<br><img src="https://user-gold-cdn.xitu.io/2020/6/27/172f626e4c83c2ba?w=1146&h=740&f=png&s=144419" srcset="/img/loading.gif" alt></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx 使用&amp; 剖析</title>
    <link href="/2020/06/23/Nginx-%E4%BD%BF%E7%94%A8-%E5%89%96%E6%9E%90/"/>
    <url>/2020/06/23/Nginx-%E4%BD%BF%E7%94%A8-%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Nginx基础"><a href="#一、Nginx基础" class="headerlink" title="一、Nginx基础"></a>一、Nginx基础</h1><ul><li><p>Nginx 到底是什么？</p><p>Nginx是⼀个⾼性能的HTTP和反向代理web服务器，核⼼特点是占有内存少，并发能⼒强</p></li><li><p>Nginx ⼜能做什么事情（应⽤场景）</p><ul><li>Http服务器（Web服务器）性能⾮常⾼，⾮常注重效率，能够经受⾼负载的考验。<br>⽀持50000个并发连接数，不仅如此，CPU和内存的占⽤也⾮常的低，10000个没有活动的连接才占⽤2.5M的内存。</li><li>反向代理服务器 （浏览器发送请求到Nginx，由Nginx反向代理选择原始服务器得到结果，最终再返回给客户端浏览器 Nginx + Tomcat）</li><li>正向代理 （国内访问 google）</li><li>负载均衡服务器 （由Nginx反向代理多台Tomcat,这样⼀个寻找确定的过程就叫做负载均衡）</li><li>动静分离（静态资源由Nginx 直接处理，动态Servlet 请求代理到Tomcat）</li></ul></li><li><p>Nginx 特点</p><ul><li>跨平台</li><li>配置简单</li><li>高并发，性能好，稳定，宕机率低</li></ul></li><li><p>Nginx主要命令</p><ul><li>nginx -s start</li><li>nginx -s stop</li><li>nginx -s reload (重新加载nginx.conf配置⽂件,Master 节点不重启)</li></ul></li></ul><h1 id="二、Nginx-核心配置文件解读"><a href="#二、Nginx-核心配置文件解读" class="headerlink" title="二、Nginx 核心配置文件解读"></a>二、Nginx 核心配置文件解读</h1><p>Nginx 核心配置文件conf/nginx.conf包含三块内容：全局块、events块、http块。</p><ul><li><p>全局块 </p><p>  从配置⽂件开始到events块之间的内容，此处的配置影响nginx服务器整体的运⾏，⽐如worker进程的数量、错误⽇志的位置等<br>  <img src="https://user-gold-cdn.xitu.io/2020/6/23/172e16edfeb5cc94?w=1274&h=324&f=png&s=128586" srcset="/img/loading.gif" alt></p></li><li><p>events块 </p><p>  events块主要影响nginx服务器与⽤户的⽹络连接，⽐如worker_connections 1024，标识每个workderprocess⽀持的最⼤连接数为1024<br>  <img src="https://user-gold-cdn.xitu.io/2020/6/23/172e16fdaa99c511?w=1280&h=172&f=png&s=73330" srcset="/img/loading.gif" alt></p></li><li><p>http块<br>  http块是配置最频繁的部分，虚拟主机的配置，监听端⼝的配置，请求转发、反向代理、负载均衡等   <strong>⚠️http下可配置多个server</strong><br>  <img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1712d2aa05f7?w=1284&h=450&f=png&s=104836" srcset="/img/loading.gif" alt><br>  <img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1773fff662af?w=1180&h=1118&f=png&s=359247" srcset="/img/loading.gif" alt></p></li></ul><h1 id="三、Nginx应⽤场景之反向代理"><a href="#三、Nginx应⽤场景之反向代理" class="headerlink" title="三、Nginx应⽤场景之反向代理"></a>三、Nginx应⽤场景之反向代理</h1><ul><li><p>部署tomcat 8080</p></li><li><p>修改nginx配置<br><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e17c236275c13?w=1206&h=582&f=png&s=231162" srcset="/img/loading.gif" alt></p></li><li><p>nginx -s relod （重启，配置生效）</p></li><li><p>注意 location 语法，nginx中server/location == tomcat中的Host/Context</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">location</span> <span class="hljs-title">[=|~|~*|^~] /uri</span>/ &#123; … &#125;</code></pre></div><p>在nginx配置⽂件中，location主要有这⼏种形式：</p><ol><li><p>精确匹配 location = /lagou { }</p></li><li><p>匹配路径的前缀 location ^~ /lagou { }</p></li><li><p>不区分⼤⼩写的正则匹配 location ~* /lagou { }</p></li><li><p>正则匹配 location ~ /lagou { }</p></li><li><p>普通路径前缀匹配 location /lagou { }</p><p>优先级 ：asc</p></li></ol></li></ul><h1 id="四、Nginx应⽤场景之负载均衡"><a href="#四、Nginx应⽤场景之负载均衡" class="headerlink" title="四、Nginx应⽤场景之负载均衡"></a>四、Nginx应⽤场景之负载均衡</h1><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e183308ca4142?w=1148&h=460&f=png&s=60377" srcset="/img/loading.gif" alt></p><h2 id="1-Nginx负载均衡策略"><a href="#1-Nginx负载均衡策略" class="headerlink" title="1. Nginx负载均衡策略"></a>1. Nginx负载均衡策略</h2><ul><li><p>轮询 （默认策略）</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">upstream</span> lagouServer&#123;    <span class="hljs-attribute">server</span> <span class="hljs-number">111.229.248.243:8080</span>;    <span class="hljs-attribute">server</span> <span class="hljs-number">111.229.248.243:8082</span>;&#125;<span class="hljs-attribute">location</span> /abc &#123;    <span class="hljs-attribute">proxy_pass</span> http://lagouServer/;&#125;</code></pre></div></li><li><p>weight 权重</p>  <div class="hljs"><pre><code class="hljs undefined">upstream lagouServer&#123;   <span class="hljs-built_in"> server </span>111.229.248.243:8080 <span class="hljs-attribute">weight</span>=1;   <span class="hljs-built_in"> server </span>111.229.248.243:8082 <span class="hljs-attribute">weight</span>=2;&#125;</code></pre></div></li><li><p>ip_hash 按 ip 走，每一个客户端会打进同一个服务</p>  <div class="hljs"><pre><code class="hljs undefined">upstream lagouServer&#123;    ip_hash;   <span class="hljs-built_in"> server </span>111.229.248.243:8080;   <span class="hljs-built_in"> server </span>111.229.248.243:8082;&#125;</code></pre></div></li></ul><h1 id="五、Nginx应⽤场景之动静分离"><a href="#五、Nginx应⽤场景之动静分离" class="headerlink" title="五、Nginx应⽤场景之动静分离"></a>五、Nginx应⽤场景之动静分离</h1><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e1868f495ae27?w=1126&h=402&f=png&s=53943" srcset="/img/loading.gif" alt></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e187dda381c4f?w=1152&h=286&f=png&s=94411" srcset="/img/loading.gif" alt></p><h1 id="六、-Nginx底层进程机制剖析"><a href="#六、-Nginx底层进程机制剖析" class="headerlink" title="六、 Nginx底层进程机制剖析"></a>六、 Nginx底层进程机制剖析</h1><h2 id="1-Nginx-启动"><a href="#1-Nginx-启动" class="headerlink" title="1.Nginx 启动"></a>1.Nginx 启动</h2><p>以daemon多进程⽅式在后台运⾏，有⼀个Master进程和多个Worker进程</p><ul><li>Master 进程<ul><li>接收外界信号像Worker 发送信号 如 nginx -s reload</li><li>监控Worker，Worker异常退出，Master 自动重启新的Worker</li></ul></li><li>Worker 进程<ul><li>处理网络请求，各Worker独立，一个请求只能在一个Worker。worker进程的个数是可以设置的，⼀般设置与机器cpu核数⼀致。</li></ul></li></ul><h2 id="2-Nginx进程模型示意图"><a href="#2-Nginx进程模型示意图" class="headerlink" title="2. Nginx进程模型示意图"></a>2. Nginx进程模型示意图</h2><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172e18d53ac59fd3?w=1294&h=772&f=png&s=154951" srcset="/img/loading.gif" alt></p><ul><li><p>举例以 ./nginx -s reload 来说明nginx信号处理这部分</p><ol><li>Master 对配置文件进行语法检测</li><li>配置（⽐如修改了监听端⼝，那就尝试分配新的监听端⼝）</li><li>配置成功则使⽤新的配置，新建worker进程</li><li>new worker success，old worker close</li><li>old worker 会继续运行到请求没有为止才关闭</li></ol></li><li><p>worker进程处理请求</p><ul><li>请求进来有多个Worker ，每个Worker都有可能处理请求</li><li>Master 启动好后，会建立socket链接，然后fork出多个Worker。所以，所有Worker进程的监听描述符listenfd在新连接到来时都变得可读</li><li>nginx 使用互斥锁保证只有一个Worker处理一个请求。拿到互斥锁的那个进程注册listenfd读事件，在读事件⾥调⽤accept接受该连接，然后解析、处理、返回客户端</li></ul></li><li><p>nginx多进程模型好处</p><ul><li>每个worker进程都是独⽴的，不需要加锁，节省开销</li><li>每个worker进程都是独⽴的，互不影响，⼀个异常结束，其他的照样能提供服务</li><li>多进程模型为reload热部署机制提供了⽀撑</li></ul></li></ul><blockquote><p><em>《lagouedu》nginx总结</em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tomcat 深度剖析及性能调优</title>
    <link href="/2020/06/21/Tomcat-%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    <url>/2020/06/21/Tomcat-%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E5%8F%8A%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Tomcat-系统架构与原理剖析"><a href="#一、Tomcat-系统架构与原理剖析" class="headerlink" title="一、Tomcat 系统架构与原理剖析"></a>一、Tomcat 系统架构与原理剖析</h1><p>b/s（浏览器/服务器模式） 浏览器是客户端（发送http请求） ———&gt; 服务器端</p><h2 id="1-浏览器访问服务器的流程"><a href="#1-浏览器访问服务器的流程" class="headerlink" title="1. 浏览器访问服务器的流程"></a>1. 浏览器访问服务器的流程</h2><p>http请求的处理过程：<br><img src="https://img-blog.csdnimg.cn/20200620122417265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="http请求处理流程"></p><h2 id="2-Tomcat-系统总体架构"><a href="#2-Tomcat-系统总体架构" class="headerlink" title="2. Tomcat 系统总体架构"></a>2. Tomcat 系统总体架构</h2><h4 id="2-1-Tomcat-请求处理⼤致过程"><a href="#2-1-Tomcat-请求处理⼤致过程" class="headerlink" title="2.1 Tomcat 请求处理⼤致过程"></a>2.1 Tomcat 请求处理⼤致过程</h4><p>Tomcat是⼀个Http服务器（能够接收并且处理http请求，所以tomcat是⼀个http服务器）<br><img src="https://img-blog.csdnimg.cn/20200620122828349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Tomcat请求流程"><br>Servlet接⼝和Servlet容器这⼀整套内容叫作Servlet规范。<br>Tomcat 两个重要的身份 1. http服务器 2. Servlet 容器</p><h4 id="2-2-Tomcat-Servlet容器处理流程"><a href="#2-2-Tomcat-Servlet容器处理流程" class="headerlink" title="2.2 Tomcat Servlet容器处理流程"></a>2.2 Tomcat Servlet容器处理流程</h4><p>当⽤户请求某个URL资源时<br>1）HTTP服务器会把请求信息使⽤ServletRequest对象封装起来<br>2）进⼀步去调⽤Servlet容器中某个具体的Servlet<br>3）在 2）中，<strong>Servlet容器拿到请求后，根据URL和Servlet的映射关系，找到相应的Servlet</strong><br>4）如果Servlet还没有被加载，就⽤<strong>反射机制创建这个Servlet，并调⽤Servlet的init⽅法来完成初始化</strong><br>5）接着调⽤这个具体Servlet的service⽅法来处理请求，请求处理结果使⽤ServletResponse对象封装<br>6）把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端<br><img src="https://img-blog.csdnimg.cn/20200620124116245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="servlet处理流程"></p><h4 id="2-3-Tomcat-系统总体架构"><a href="#2-3-Tomcat-系统总体架构" class="headerlink" title="2.3 Tomcat 系统总体架构"></a>2.3 Tomcat 系统总体架构</h4><p><img src="https://img-blog.csdnimg.cn/20200620124724476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="总体架构图"><br><strong>连接器，负责对外交流</strong>： 处理Socket连接，负责⽹络字节流与Request和Response对象的转化；<br><strong>容器，负责内部处理</strong>：加载和管理Servlet，以及具体处理Request请求；</p><h2 id="3-Tomcat-连接器组件-Coyote"><a href="#3-Tomcat-连接器组件-Coyote" class="headerlink" title="3. Tomcat 连接器组件 Coyote"></a>3. Tomcat 连接器组件 Coyote</h2><h4 id="3-1-Coyote-简介"><a href="#3-1-Coyote-简介" class="headerlink" title="3.1 Coyote 简介"></a>3.1 Coyote 简介</h4><p>Coyote 是Tomcat 中连接器的组件名称 , 是对外的接⼝。客户端通过Coyote与服务器建⽴连接、发送请<br>求并接受响应 。<br>（1）Coyote 封装了底层的⽹络通信（Socket 请求及响应处理）<br>（2）Coyote 使Catalina 容器（容器组件）与具体的请求协议及IO操作⽅式完全解耦<br>（3）Coyote 将Socket 输⼊转换封装为 Request 对象，进⼀步封装后交由Catalina 容器进⾏处理，处<br>理请求完成后, Catalina 通过Coyote 提供的Response 对象将结果写⼊输出流<br>（4）<strong>Coyote 负责的是具体协议（应⽤层）和IO（传输层）相关内容</strong></p><p><img src="https://img-blog.csdnimg.cn/20200620125035665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Coyote"><br>Tomcat⽀持多种应⽤层协议和I/O模型，如下：<br><img src="https://img-blog.csdnimg.cn/20200620125154474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Tomcat支持应用协议"><br>在 8.0 之前 ，Tomcat 默认采⽤的I/O⽅式为 BIO。</p><h4 id="3-2-Coyote-的内部组件及流程"><a href="#3-2-Coyote-的内部组件及流程" class="headerlink" title="3.2 Coyote 的内部组件及流程"></a>3.2 Coyote 的内部组件及流程</h4><p><img src="https://img-blog.csdnimg.cn/20200620125637616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Coyote内部处理组件流程"></p><p>Coyote 组件以及作用 ：</p><table><thead><tr><th align="left">组件</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">EndPoint</td><td align="left">EndPoint 是监听的接⼝，是Socket接收和发送处理器，是对传输层的抽象，因此EndPoint⽤来实现TCP/IP协议的</td></tr><tr><td align="left">Processor</td><td align="left">Processor 是Coyote 协议处理接⼝，Processor⽤来实现HTTP协议，Processor接收来⾃EndPoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应⽤层协议的抽象</td></tr><tr><td align="left">ProtocolHandler</td><td align="left">Coyote 协议接⼝， 通过Endpoint 和 Processor ， 实现针对具体协议的处理能⼒。Tomcat 按照协议和I/O 提供了6个实现类 ： AjpNioProtocol ，AjpAprProtocol，AjpNio2Protocol ，Http11NioProtocol Http11Nio2Protocol ，Http11AprProtocol</td></tr><tr><td align="left">Adapter</td><td align="left">协议不同，请求信息也不同，Tomcat定义了Request封装信息。将ProtocolHandler 处理成 ServletRequest，这是经典的适配器模式，连接器调用CoyoteAdapter的Sevice⽅法，将Tomcat Request -&gt; ServletRequest</td></tr></tbody></table><h2 id="4-Tomcat-Servlet-容器-Catalina"><a href="#4-Tomcat-Servlet-容器-Catalina" class="headerlink" title="4. Tomcat Servlet 容器 Catalina"></a>4. Tomcat Servlet 容器 Catalina</h2><h4 id="4-1-Tomcat-模块分层结构图及Catalina位置"><a href="#4-1-Tomcat-模块分层结构图及Catalina位置" class="headerlink" title="4.1 Tomcat 模块分层结构图及Catalina位置"></a>4.1 Tomcat 模块分层结构图及Catalina位置</h4><p>Tomcat 可以通过 （conf/server.xml）的组件构成的Web容器，⽽Catalina是Tomcat的<br>servlet容器。<strong>Catalina 才是 Tomcat 的核⼼。</strong> 其他模块都是为Catalina 提供⽀撑的。 ⽐如 ： 通过 Coyote 模块提供链接通信，Jasper 模块提供 JSP 引擎，Naming 提供JNDI 服务，Juli 提供⽇志服务。</p><p><img src="https://img-blog.csdnimg.cn/20200620131348121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Catalina分层结构图"></p><h4 id="4-2-Servlet-容器-Catalina-的结构"><a href="#4-2-Servlet-容器-Catalina-的结构" class="headerlink" title="4.2 Servlet 容器 Catalina 的结构"></a>4.2 Servlet 容器 Catalina 的结构</h4><p>Catalina实例<img src="https://img-blog.csdnimg.cn/20200620131908197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="catalina实例图"><br>可认知为整个Tomcat就是一个Catalina实例，Tomcat启动会初始化这个实例，<strong>Catalina 实例通过加载server.xml 完成其他实例创建，创建管理一个Server，Server创建多个Serivce，每个Service有多个Connector 和一个Container。</strong></p><p><strong>⚠️：多个Connector 对应 一个 Container/Engine</strong></p><table><thead><tr><th align="left">组件</th><th align="left">作用描述</th></tr></thead><tbody><tr><td align="left">Catalina</td><td align="left">解析conf/server.xml，以此创建Server并管理。</td></tr><tr><td align="left">Server</td><td align="left">表示整个Catalina Servlet容器以及其他组件，负责启动Servlet引擎，Tomcat连接器Connector</td></tr><tr><td align="left">Service</td><td align="left">Server内部组件，⼀个Server包含多个Service。它将若⼲个Connector组件绑定到⼀个Container</td></tr><tr><td align="left">Container</td><td align="left">容器，负责处理⽤户的servlet请求，并返回对象给web⽤户的模块</td></tr></tbody></table><h4 id="4-3-Container-组件的具体结构"><a href="#4-3-Container-组件的具体结构" class="headerlink" title="4.3 Container 组件的具体结构"></a>4.3 Container 组件的具体结构</h4><p>Container组件下有⼏种具体的组件，分别是Engine、Host、Context和Wrapper。这4种组件（容器）<br>是⽗⼦关系。（<strong>都是一对多</strong>）Tomcat通过⼀种分层的架构，使得Servlet容器具有很好的灵活性。包含如下组件：</p><ul><li>Engine ：表示整个Catalina的Servlet引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine，但是可以包含多个Host。</li><li>Host ：代表一个虚拟主机，（例如一个<a href="http://www.abc.com域名就是一个虚拟主机），而一个虚拟主机可以包含多个Context。" target="_blank" rel="noopener">www.abc.com域名就是一个虚拟主机），而一个虚拟主机可以包含多个Context。</a></li><li>Context ：代表一个Web应用，⼀个Web应⽤可包含多个Wrapper。</li><li>Wrapper ：表示⼀个Servlet，Wrapper 作为容器中的最底层，不能包含⼦容器</li></ul><p><strong>上述组件的配置其实就体现在conf/server.xml中。</strong></p><h1 id="二、Tomcat-服务器核⼼配置详解"><a href="#二、Tomcat-服务器核⼼配置详解" class="headerlink" title="二、Tomcat 服务器核⼼配置详解"></a>二、Tomcat 服务器核⼼配置详解</h1><h2 id="1-配置路径-amp-如何配置"><a href="#1-配置路径-amp-如何配置" class="headerlink" title="1. 配置路径 &amp; 如何配置"></a>1. 配置路径 &amp; 如何配置</h2><p>根目录 -&gt; conf/server.xml，server.xml中包含了 Servlet容器的相关配置，即 Catalina 的配置。主要是标签的使用。</p><h4 id="主要标签结构如下："><a href="#主要标签结构如下：" class="headerlink" title="主要标签结构如下："></a>主要标签结构如下：</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">&lt;!--Server 根元素，创建⼀个Server实例，⼦标签有 Listener、GlobalNamingResources、Service--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Server</span>&gt;</span><span class="hljs-comment">&lt;!--定义监听器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span>/&gt;</span><span class="hljs-comment">&lt;!--定义服务器的全局JNDI资源 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>/&gt;</span><span class="hljs-comment">&lt;!--定义⼀个Service服务，⼀个Server标签可以有多个Service服务实例--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Service</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Server</span>&gt;</span></code></pre></div><h6 id="Server-标签"><a href="#Server-标签" class="headerlink" title="Server 标签"></a>Server 标签</h6><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--port：关闭服务器的监听端⼝ shutdown：关闭服务器的指令字符串--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Server</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8005"</span> <span class="hljs-attr">shutdown</span>=<span class="hljs-string">"SHUTDOWN"</span>&gt;</span><span class="hljs-comment">&lt;!-- 以⽇志形式输出服务器 、操作系统、JVM的版本信息 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span><span class="hljs-comment">&lt;!-- Security listener. Documentation at /docs/config/listeners.html&lt;Listener className="org.apache.catalina.security.SecurityListener" /&gt;--&gt;</span><span class="hljs-comment">&lt;!--APR library loader. Documentation at /docs/apr.html --&gt;</span><span class="hljs-comment">&lt;!-- 加载（服务器启动） 和 销毁 （服务器停⽌） APR。 如果找不到APR库， 则会输出⽇志， 并不影响 Tomcat启动 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.AprLifecycleListener"</span><span class="hljs-attr">SSLEngine</span>=<span class="hljs-string">"on"</span> /&gt;</span><span class="hljs-comment">&lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;</span><span class="hljs-comment">&lt;!-- 避免JRE内存泄漏问题 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 加载（服务器启动） 和 销毁（服务器停⽌） 全局命名服务 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span><span class="hljs-comment">&lt;!-- 在Context停⽌时重建 Executor 池中的线程， 以避免ThreadLocal 相关的内存泄漏 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Listener</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span><span class="hljs-comment">&lt;!-- Global JNDI resourcesDocumentation at /docs/jndi-resources-howto.htmlGlobalNamingResources 中定义了全局命名服务--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">GlobalNamingResources</span>&gt;</span><span class="hljs-comment">&lt;!-- Editable user database that can also be used byUserDatabaseRealm to authenticate users--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Resource</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"UserDatabase"</span> <span class="hljs-attr">auth</span>=<span class="hljs-string">"Container"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"org.apache.catalina.UserDatabase"</span><span class="hljs-attr">description</span>=<span class="hljs-string">"User database that can be updated and saved"</span><span class="hljs-attr">factory</span>=<span class="hljs-string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span><span class="hljs-attr">pathname</span>=<span class="hljs-string">"conf/tomcat-users.xml"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">GlobalNamingResources</span>&gt;</span><span class="hljs-comment">&lt;!-- A "Service" is a collection of one or more "Connectors" that sharea single "Container" <span class="hljs-doctag">Note:</span> A "Service" is not itself a "Container",so you may not define subcomponents such as "Valves" at this level.Documentation at /docs/config/service.html--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span></code></pre></div><h6 id="Service-标签"><a href="#Service-标签" class="headerlink" title="Service 标签"></a>Service 标签</h6><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--该标签⽤于创建 Service 实例，默认使⽤ org.apache.catalina.core.StandardService。默认情况下，Tomcat 仅指定了Service 的名称， 值为 "Catalina"。Service ⼦标签为 ： Listener、Executor、Connector、Engine，其中：Listener ⽤于为Service添加⽣命周期监听器，Executor ⽤于配置Service 共享线程池，Connector ⽤于配置Service 包含的链接器，Engine ⽤于配置Service中链接器对应的Servlet 容器引擎--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Service</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">Service</span>&gt;</span></code></pre></div><h6 id="Executor-标签"><a href="#Executor-标签" class="headerlink" title="Executor 标签"></a>Executor 标签</h6><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 默认情况下，Service 并未添加共享线程池配置。 如果我们想添加⼀个线程池， 可以在&lt;Service&gt; 下添加如下配置：name：线程池名称，⽤于 Connector中指定namePrefix：所创建的每个线程的名称前缀，⼀个单独的线程名称为namePrefix+threadNumbermaxThreads：池中最⼤线程数minSpareThreads：活跃线程数，也就是核⼼池线程数，这些线程不会被销毁，会⼀直存在maxIdleTime：线程空闲时间，超过该时间后，空闲线程会被销毁，默认值为6000（1分钟），单位毫秒maxQueueSize：在被执⾏前最⼤线程排队数⽬，默认为Int的最⼤值，也就是⼴义的⽆限。除⾮特殊情况，这个值 不需要更改，否则会有请求不会被处理的情况发⽣prestartminSpareThreads：启动线程池时是否启动 minSpareThreads部分线程。默认值为false，即不启动threadPriority：线程池中线程优先级，默认值为5，值从1到10className：线程池实现类，未指定情况下，默认实现类为org.apache.catalina.core.StandardThreadExecutor。如果想使⽤⾃定义线程池⾸先需要实现org.apache.catalina.Executor接⼝--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Executor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"commonThreadPool"</span><span class="hljs-attr">namePrefix</span>=<span class="hljs-string">"thread-exec-"</span><span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"200"</span><span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"100"</span><span class="hljs-attr">maxIdleTime</span>=<span class="hljs-string">"60000"</span><span class="hljs-attr">maxQueueSize</span>=<span class="hljs-string">"Integer.MAX_VALUE"</span><span class="hljs-attr">prestartminSpareThreads</span>=<span class="hljs-string">"false"</span><span class="hljs-attr">threadPriority</span>=<span class="hljs-string">"5"</span><span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.core.StandardThreadExecutor"</span>/&gt;</span></code></pre></div><h6 id="Connector-标签"><a href="#Connector-标签" class="headerlink" title="Connector 标签"></a>Connector 标签</h6><p>Connector 标签⽤于创建链接器实例<br>默认情况下，server.xml 配置了两个链接器，⼀个⽀持HTTP协议，⼀个⽀持AJP协议<br>⼤多数情况下，我们并不需要新增链接器配置，只是根据需要对已有链接器进⾏优化</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--port：端⼝号，Connector ⽤于创建服务端Socket 并进⾏监听， 以等待客户端请求链接。如果该属性设置为0， Tomcat将会随机选择⼀个可⽤的端⼝号给当前Connector 使⽤protocol：当前Connector ⽀持的访问协议。 默认为 HTTP/1.1 ， 并采⽤⾃动切换机制选择⼀个基于 JAVANIO 的链接器或者基于本地APR的链接器（根据本地是否含有Tomcat的本地库判定）connectionTimeOut:Connector 接收链接后的等待超时时间， 单位为 毫秒。 -1 表示不超时。redirectPort：当前Connector 不⽀持SSL请求， 接收到了⼀个请求， 并且也符合security-constraint 约束，需要SSL传输，Catalina⾃动将请求重定向到指定的端⼝。executor：指定共享线程池的名称， 也可以通过maxThreads、minSpareThreads 等属性配置内部线程池。URIEncoding:⽤于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 , Tomcat7.x版本默认为ISO-8859-1--&gt;</span><span class="hljs-comment">&lt;!--org.apache.coyote.http11.Http11NioProtocol ， ⾮阻塞式 Java NIO 链接器--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span> <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8009"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"AJP/1.3"</span> <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span></code></pre></div><p>可以使⽤共享线程池</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span><span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span><span class="hljs-attr">executor</span>=<span class="hljs-string">"commonThreadPool"</span><span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"1000"</span><span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">"100"</span><span class="hljs-attr">acceptCount</span>=<span class="hljs-string">"1000"</span><span class="hljs-attr">maxConnections</span>=<span class="hljs-string">"1000"</span><span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span><span class="hljs-attr">compression</span>=<span class="hljs-string">"on"</span><span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">"2048"</span><span class="hljs-attr">disableUploadTimeout</span>=<span class="hljs-string">"true"</span><span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span><span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">"UTF-8"</span> /&gt;</span></code></pre></div><h6 id="Engine-标签"><a href="#Engine-标签" class="headerlink" title="Engine 标签"></a>Engine 标签</h6><p>Engine 表示 Servlet 引擎</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--name： ⽤于指定Engine 的名称， 默认为CatalinadefaultHost：默认使⽤的虚拟主机名称， 当客户端请求指向的主机⽆效时， 将交由默认的虚拟主机处理， 默认为localhost--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Engine</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"Catalina"</span> <span class="hljs-attr">defaultHost</span>=<span class="hljs-string">"localhost"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">Engine</span>&gt;</span></code></pre></div><h6 id="Host-标签"><a href="#Host-标签" class="headerlink" title="Host 标签"></a>Host 标签</h6><p>Host 标签⽤于配置⼀个虚拟主机</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"localhost"</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span> <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span></code></pre></div><h6 id="Context-标签"><a href="#Context-标签" class="headerlink" title="Context 标签"></a>Context 标签</h6><p>Context 标签⽤于配置⼀个Web应⽤，如下：</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"www.abc.com"</span> <span class="hljs-attr">appBase</span>=<span class="hljs-string">"webapps"</span> <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">"true"</span><span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-comment">&lt;!--docBase：Web应⽤⽬录或者War包的部署路径。可以是绝对路径，也可以是相对于 Host appBase的相对路径。path：Web应⽤的Context 路径。如果我们Host名为localhost， 则该web应⽤访问的根路径为：http://localhost:8080/web_demo。--&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">"/Users/yingdian/web_demo"</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/web3"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Context</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"org.apache.catalina.valves.AccessLogValve"</span><span class="hljs-attr">directory</span>=<span class="hljs-string">"logs"</span><span class="hljs-attr">prefix</span>=<span class="hljs-string">"localhost_access_log"</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">".txt"</span><span class="hljs-attr">pattern</span>=<span class="hljs-string">"%h %l %u %t &amp;quot;%r&amp;quot; %s %b"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span></code></pre></div><p><strong>注：Context 不配置 path 默认 还是走Host</strong></p><h1 id="三、⼿写实现迷你版-Tomcat"><a href="#三、⼿写实现迷你版-Tomcat" class="headerlink" title="三、⼿写实现迷你版 Tomcat"></a>三、⼿写实现迷你版 Tomcat</h1><p>实现简单功能 ：<br>1）提供服务，接收请求（Socket通信）<br>2）请求信息封装成Request对象（Response对象）<br>3）客户端请求资源，资源分为静态资源（html）和动态资源（Servlet）<br>4）资源返回给客户端浏览器</p><p>源码地址 -&gt; xxxxx</p><h1 id="四、Tomcat-源码构建及核⼼流程源码剖析"><a href="#四、Tomcat-源码构建及核⼼流程源码剖析" class="headerlink" title="四、Tomcat 源码构建及核⼼流程源码剖析"></a>四、Tomcat 源码构建及核⼼流程源码剖析</h1><h2 id="1-源码构建"><a href="#1-源码构建" class="headerlink" title="1. 源码构建"></a>1. 源码构建</h2><h4 id="1-1-下载源码"><a href="#1-1-下载源码" class="headerlink" title="1.1 下载源码"></a>1.1 下载源码</h4><p>地址为 ：<a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a> -&gt; Source Code Distributions -&gt; tar.gz</p><h4 id="1-2-源码导⼊IDE之前准备⼯作"><a href="#1-2-源码导⼊IDE之前准备⼯作" class="headerlink" title="1.2 源码导⼊IDE之前准备⼯作"></a>1.2 源码导⼊IDE之前准备⼯作</h4><ul><li>解压 tar.gz 压缩包，得到⽬录 apache-tomcat-8.5.50-src</li><li>进⼊ apache-tomcat-8.5.50-src ⽬录，创建⼀个pom.xml⽂件，⽂件内容如下<div class="hljs"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span>         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span>         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>apache-tomcat-8.5.50-src<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Tomcat8.5<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>        <span class="hljs-comment">&lt;!--指定源⽬录--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>Tomcat8.5<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">sourceDirectory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">sourceDirectory</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>            <span class="hljs-comment">&lt;!--引⼊编译插件--&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>11<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span>    <span class="hljs-comment">&lt;!--tomcat 依赖的基础包--&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.easymock<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>easymock<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ant<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wsdl4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jaxrpc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.eclipse.jdt.core.compiler<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ecj<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.xml.soap<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.xml.soap-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li></ul><ul><li><p>在 apache-tomcat-8.5.50-src ⽬录中创建 source ⽂件夹</p></li><li><p>将 conf、webapps ⽬录移动到刚刚创建的 source ⽂件夹中 (为了方便调试管理)</p></li></ul><h4 id="1-3-导⼊源码⼯程到IDE并进⾏配置"><a href="#1-3-导⼊源码⼯程到IDE并进⾏配置" class="headerlink" title="1.3 导⼊源码⼯程到IDE并进⾏配置"></a>1.3 导⼊源码⼯程到IDE并进⾏配置</h4><ul><li><p>将源码⼯程导⼊到 IDEA 中</p></li><li><p>给 tomcat 的源码程序启动类 Bootstrap 配置 VM 参数，因为 tomcat 源码运⾏也需要加载配置⽂件等。</p><div class="hljs"><pre><code class="hljs undefined"> -Dcatalina.home=/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-<span class="hljs-number">8.5</span>.<span class="hljs-number">50</span>-src/source-Dcatalina.base=/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-<span class="hljs-number">8.5</span>.<span class="hljs-number">50</span>-src/source-Djava<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.manager</span>=org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.juli</span><span class="hljs-selector-class">.ClassLoaderLogManager</span>-Djava<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.file</span>=/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-<span class="hljs-number">8.5</span>.<span class="hljs-number">50</span>-src/source/conf/logging.properties</code></pre></div></li><li><p>执行BootStrap main 启动 tomcat，访问会遇到Jsp引擎Jasper没有被初始化，在 org.apache.catalina.startup.ContextConfig -&gt;configureStart 加入 context.addServletContainerInitializer(new JasperInitializer(),null);<br><img src="https://img-blog.csdnimg.cn/20200621153744777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="描述代码"></p></li><li><p>重启Tomcat，至此源码调试环境搭建完成。</p></li></ul><h2 id="2-核⼼流程源码剖析"><a href="#2-核⼼流程源码剖析" class="headerlink" title="2. 核⼼流程源码剖析"></a>2. 核⼼流程源码剖析</h2><h4 id="2-1-生命周期接口Lifecycle"><a href="#2-1-生命周期接口Lifecycle" class="headerlink" title="2.1 生命周期接口Lifecycle"></a>2.1 生命周期接口Lifecycle</h4><ul><li>Lifecycle⽣命周期接⼝主要⽅法示意<br><img src="https://img-blog.csdnimg.cn/20200621155048250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Lifecycle方法"></li><li>Tomcat中的各容器组件都会涉及创建、销毁等，因此<strong>设计了⽣命周期接⼝Lifecycle进⾏统⼀规范，各容器组件实现Lifecycle接⼝</strong>。<br>继承Lifecycle 的类如下：<br><img src="https://img-blog.csdnimg.cn/20200621154817665.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="继承Lifecycle的类"></li></ul><h4 id="2-2-核⼼流程源码剖析"><a href="#2-2-核⼼流程源码剖析" class="headerlink" title="2.2 核⼼流程源码剖析"></a>2.2 核⼼流程源码剖析</h4><p>源码追踪部分我们关注两个流程：<strong>Tomcat启动流程和Tomcat请求处理流程</strong></p><p>Tomcat启动流程 ：<br><img src="https://img-blog.csdnimg.cn/20200621155305466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="启动时序图"><br>Tomcat请求处理流程 ：</p><ul><li>请求处理流程分析</li><li><img src="https://img-blog.csdnimg.cn/20200621155711301.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="请求处理流程"></li><li>请求处理流程示意图<br><img src="https://img-blog.csdnimg.cn/20200621155848332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="请求流程示意图"></li><li>Mapper组件体系结构<br><img src="https://img-blog.csdnimg.cn/20200621160024122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Mapper组件体系结构"></li></ul><h1 id="五、Tomcat-类加载机制剖析"><a href="#五、Tomcat-类加载机制剖析" class="headerlink" title="五、Tomcat 类加载机制剖析"></a>五、Tomcat 类加载机制剖析</h1><p>Java类（.java）—&gt; 字节码⽂件(.class) —&gt; 字节码⽂件需要被加载到jvm内存当中（这个过程就是⼀个类加载的过程）<br>类加载器（ClassLoader，说⽩了也是⼀个类，jvm启动的时候先把类加载器读取到内存当中去，其他的类（⽐如各种jar中的字节码⽂件，⾃⼰开发的代码编译之后的.class⽂件等等））要说 Tomcat 的类加载机制，⾸先需要来看看 Jvm 的类加载机制，因为 <strong>Tomcat 类加载机制是在 Jvm 类加载机制基础之上进⾏了⼀些变动。</strong></p><h2 id="1-JVM-的类加载机制"><a href="#1-JVM-的类加载机制" class="headerlink" title="1. JVM 的类加载机制"></a>1. JVM 的类加载机制</h2><p>JVM 的类加载机制中有⼀个⾮常重要的⻆⾊叫做类加载器（ClassLoader），类加载器有⾃⼰的体系，Jvm内置了⼏种类加载器，包括：引导类加载器、扩展类加载器、系统类加载器，他们之间形成⽗⼦关系，通过 Parent 属性来定义这种关系，最终可以形成树形结构。</p><p><img src="https://img-blog.csdnimg.cn/20200621161139924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="类加载结构图"><br><strong>⚠️rt.jar 里为java核⼼库 java.*</strong></p><p>另外：⽤户可以⾃定义类加载器（Java编写，⽤户⾃定义的类加载器，可加载指定路径的 class ⽂件）<br>　　当 JVM 运⾏过程中，⽤户⾃定义了类加载器去加载某些类时，会按照下⾯的步骤（⽗类委托机制）<br>　　1） ⽤户⾃⼰的类加载器，把加载请求传给⽗加载器，⽗加载器再传给其⽗加载器，⼀直到加载器树的顶层<br>　　2 ）最顶层的类加载器⾸先针对其特定的位置加载，如果加载不到就转交给⼦类<br>　　3 ）如果⼀直到底层的类加载都没有加载到，那么就会抛出异常 ClassNotFoundException<br>　 因此，按照这个过程可以想到，如果同样在 classpath 指定的⽬录中和⾃⼰⼯作⽬录中存放相同的class，会优先加载 classpath ⽬录中的⽂件。</p><h2 id="2-双亲委派机制"><a href="#2-双亲委派机制" class="headerlink" title="2. 双亲委派机制"></a>2. 双亲委派机制</h2><h4 id="2-1-什么是双亲委派机制"><a href="#2-1-什么是双亲委派机制" class="headerlink" title="2.1 什么是双亲委派机制"></a>2.1 什么是双亲委派机制</h4><p>当某个类加载器需要加载某个.class⽂件时，它⾸先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，⾃⼰才会去加载这个类。</p><h4 id="2-2-双亲委派机制的作⽤"><a href="#2-2-双亲委派机制的作⽤" class="headerlink" title="2.2 双亲委派机制的作⽤"></a>2.2 双亲委派机制的作⽤</h4><ul><li><strong>防⽌重复加载同⼀个.class</strong>。通过委托去向上⾯问⼀问，加载过了，就不⽤再加载⼀遍。保证数据安全。</li><li><strong>保证核⼼.class不能被篡改</strong>。通过委托⽅式，不会去篡改核⼼.class，即使篡改也不会去加载，即使加载也不会是同⼀个.class对象了。不同的加载器加载同⼀个.class也不是同⼀个.class对象。这样保证了class执⾏安全（如果⼦类加载器先加载，那么我们可以写⼀些与java.lang包中基础类同名的类， 然后再定义⼀个⼦类加载器，这样整个应⽤使⽤的基础类就都变成我们⾃⼰定义的类了。）<br><strong>⚠️ Object类 —–&gt; ⾃定义类加载器（会出现问题的，那么真正的Object类就可能被篡改了）</strong></li></ul><h2 id="3-Tomcat-的类加载机制"><a href="#3-Tomcat-的类加载机制" class="headerlink" title="3. Tomcat 的类加载机制"></a>3. Tomcat 的类加载机制</h2><p>Tomcat 的类加载机制相对于 Jvm 的类加载机制做了⼀些改变。<br>没有严格的遵从双亲委派机制，也可以说打破了双亲委派机制<br>⽐如：有⼀个tomcat，webapps下部署了两个应⽤<br>app1/lib/a-1.0.jar com.lagou.edu.Abc<br>app2/lib/a-2.0.jar com.lagou.edu.Abc<br>不同版本中Abc类的内容是不同的，代码是不⼀样的。<br><img src="https://img-blog.csdnimg.cn/20200621162549763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Tomcat类加载机制"></p><ul><li><p>引导类加载器 和 扩展类加载器 的作⽤不变</p></li><li><p>系统类加载器正常情况下加载的是 CLASSPATH 下的类，但是 Tomcat 的启动脚本并未使⽤该变量，⽽是加载tomcat启动的类，⽐如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下。也就是说<strong>先不会加载系统类加载器</strong>。</p></li><li><p>Common 通⽤类加载器加载Tomcat使⽤以及应⽤通⽤的⼀些类，位于CATALINA_HOME/lib下，⽐如servlet-api.jar。</p></li><li><p>Catalina ClassLoader ⽤于加载服务器内部可⻅类，这些类应⽤程序不能访问。</p></li><li><p>Shared ClassLoader ⽤于加载应⽤程序共享类，这些类服务器不会依赖。</p></li><li><p>Webapp ClassLoader，每个应⽤程序都会有⼀个独⼀⽆⼆的Webapp ClassLoader，他⽤来加载本应⽤程序 /WEB-INF/classes 和 /WEB-INF/lib 下的类。</p><p>所以tomcat 8.5 默认改变了严格的双亲委派机制，把WebappClassLoader提到前面了。整体加载流程如下：</p></li><li><p>⾸先从 Bootstrap Classloader加载指定的类</p></li><li><p>如果未加载到，则从 /WEB-INF/classes加载</p></li><li><p>如果未加载到，则从 /WEB-INF/lib/*.jar 加载</p></li><li><p>如果未加载到，则依次从 System、Common、Shared 加载（在这最后⼀步，遵从双亲委派机制</p></li></ul><h1 id="六、Tomcat-对-Https-的⽀持及-Tomcat-性能优化策略"><a href="#六、Tomcat-对-Https-的⽀持及-Tomcat-性能优化策略" class="headerlink" title="六、Tomcat 对 Https 的⽀持及 Tomcat 性能优化策略"></a>六、Tomcat 对 Https 的⽀持及 Tomcat 性能优化策略</h1><h2 id="1-Tomcat-对-HTTPS-的⽀持"><a href="#1-Tomcat-对-HTTPS-的⽀持" class="headerlink" title="1. Tomcat 对 HTTPS 的⽀持"></a>1. Tomcat 对 HTTPS 的⽀持</h2><h4 id="1-1-Https-介绍"><a href="#1-1-Https-介绍" class="headerlink" title="1.1 Https 介绍"></a>1.1 Https 介绍</h4><p>Https是⽤来加强数据传输安全的</p><p>HTTPS和HTTP的主要区别 ：</p><ol><li>HTTPS协议使⽤时需要到电⼦商务认证授权机构（CA）申请SSL证书</li><li>HTTP默认使⽤8080端⼝，HTTPS默认使⽤8443端⼝</li><li>HTTPS则是具有SSL加密的安全性传输协议，对数据的传输进⾏加密，效果上相当于HTTP的升级<br>版</li><li>HTTP的连接是⽆状态的，不安全的；HTTPS协议是由SSL+HTTP协议构建的可进⾏加密传输、身<br>份认证的⽹络协议，⽐HTTP协议安全</li></ol><h4 id="1-2-HTTPS⼯作原理"><a href="#1-2-HTTPS⼯作原理" class="headerlink" title="1.2 HTTPS⼯作原理"></a>1.2 HTTPS⼯作原理</h4><p><img src="https://img-blog.csdnimg.cn/2020062117000843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="Https工作原理"><br>总共是4次建立握手链接。</p><ol><li>浏览器将自己支持的加密规则发送网站</li><li>网站选出加密算法，将身份、证书发回浏览器（证书包括地址、加密公钥、证书颁发机构）</li><li>使用公钥加密生成随机密码➕ 握手信息发给网站</li><li>网站收到请求使用私钥解出密码，使用密码解密握手信息，使用密码再加密一段握手信息，发送浏览器</li><li>浏览器解密并计算握手信息的Hash，如果一致，握手结束</li><li>之后的所有通信由之前浏览器生成的随机密码并利用对称加密算法进行加密</li></ol><h4 id="1-3-Tomcat-对-HTTPS-的⽀持"><a href="#1-3-Tomcat-对-HTTPS-的⽀持" class="headerlink" title="1.3 Tomcat 对 HTTPS 的⽀持"></a>1.3 Tomcat 对 HTTPS 的⽀持</h4><ol><li><p>使⽤ JDK 中的 keytool ⼯具⽣成免费的秘钥库⽂件(证书)。</p><div class="hljs"><pre><code class="hljs powershell">keytool -genkey -alias zjn -keyalg RSA -keystore zjn.keystore</code></pre></div></li><li><p>配置conf/server.xml</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8443"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span><span class="hljs-attr">maxThreads</span>=<span class="hljs-string">"150"</span> <span class="hljs-attr">schema</span>=<span class="hljs-string">"https"</span> <span class="hljs-attr">secure</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">SSLEnabled</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">SSLHostConfig</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">Certificate</span><span class="hljs-attr">certificateKeystoreFile</span>=<span class="hljs-string">"/Users/zjn/code/lagou_lesson/lagou_exercise/apache-tomcat-8.5.50-src/source/conf/zjn.keystore"</span> <span class="hljs-attr">certificateKeystorePassword</span>=<span class="hljs-string">"123321"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"RSA"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SSLHostConfig</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span></code></pre></div></li><li><p>使⽤https协议访问8443端⼝（<a href="https://localhost:8443）" target="_blank" rel="noopener">https://localhost:8443）</a></p></li></ol><h2 id="2-Tomcat-性能优化策略"><a href="#2-Tomcat-性能优化策略" class="headerlink" title="2. Tomcat 性能优化策略"></a>2. Tomcat 性能优化策略</h2><p>系统性能的衡量指标，主要是响应时间和吞吐量 :</p><p>1）响应时间：执⾏某个操作的耗时。<br>2)  吞吐量：系统在给定时间内能够⽀持的事务数量，单位为TPS（Transactions PerSecond的缩写，也<br>就是事务数/秒，⼀个事务是指⼀个客户机向服务器发送请求然后服务器做出反应的过程。</p><p>Tomcat优化从两个⽅⾯进⾏ :</p><p>1）JVM虚拟机优化（优化内存模型）<br>2）Tomcat⾃身配置的优化（⽐如是否使⽤了共享线程池？IO模型？）</p><p>学习优化的原则<br>提供给⼤家优化思路，没有说有明确的参数值⼤家直接去使⽤，必须根据⾃⼰的真实⽣产环境来进⾏调<br>整，调优是⼀个过程</p><h4 id="2-1-虚拟机运⾏优化（参数调整）"><a href="#2-1-虚拟机运⾏优化（参数调整）" class="headerlink" title="2.1 虚拟机运⾏优化（参数调整）"></a>2.1 虚拟机运⾏优化（参数调整）</h4><p>Java 虚拟机的运⾏优化主要是内存分配和垃圾回收策略的优化：</p><ul><li>内存直接影响服务的运⾏效率和吞吐量</li><li>垃圾回收机制会不同程度地导致程序运⾏中断（垃圾回收策略不同，垃圾回收次数和回收效率都是<br>不同的）Stop The World～</li></ul><h6 id="2-1-1-Java-虚拟机内存相关参数"><a href="#2-1-1-Java-虚拟机内存相关参数" class="headerlink" title="2.1.1 Java 虚拟机内存相关参数"></a>2.1.1 Java 虚拟机内存相关参数</h6><table><thead><tr><th align="center">参数</th><th align="center">参数作用</th><th align="center">优化建议</th></tr></thead><tbody><tr><td align="center">-server</td><td align="center">启动Server，以服务端模式运⾏服</td><td align="center">服务端模式建议开启</td></tr><tr><td align="center">-Xms</td><td align="center">最小堆内存</td><td align="center">建议与-Xmx设置相同</td></tr><tr><td align="center">-Xmx</td><td align="center">最⼤堆内存</td><td align="center">建议设置为可⽤内存的80%</td></tr><tr><td align="center">-XX:MetaspaceSize</td><td align="center">元空间初始值</td><td align="center"></td></tr><tr><td align="center">-XX:MaxMetaspaceSize</td><td align="center">元空间最⼤内存</td><td align="center">默认无限</td></tr><tr><td align="center">-XX:NewRatio</td><td align="center">年轻代和⽼年代⼤⼩⽐值，取值为整数，默认为2</td><td align="center">不需要修改</td></tr><tr><td align="center">-XX:SurvivorRatio</td><td align="center">Eden区与Survivor区⼤⼩的⽐值，取值为整数，默认为8</td><td align="center">不需要修改</td></tr></tbody></table><p> <strong>JVM内存模型</strong><br><img src="https://img-blog.csdnimg.cn/20200621174250128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="JVM内存模型"></p><p>参数调整示例<br>    <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">"-server -Xms2048m -Xmx2048m -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m"</span></code></pre></div></p><p>将上述参数 放入 /bin/catalina.sh 大长篇注释下方就可以了。<br>调整后查看可使⽤JDK提供的内存映射⼯具</p><div class="hljs"><pre><code class="hljs powershell">jhsdb jmap --heap --pid <span class="hljs-number">22498</span>(进程号)</code></pre></div><h6 id="2-1-2-垃圾回收（GC）策略"><a href="#2-1-2-垃圾回收（GC）策略" class="headerlink" title="2.1.2 垃圾回收（GC）策略"></a>2.1.2 垃圾回收（GC）策略</h6><p>垃圾回收性能指标 :</p><ul><li>吞吐量：<strong>⼯作时间（排除GC时间）占总时间的百分⽐</strong>， ⼯作时间并不仅是程序运⾏的时间，还包<br>含内存分配时间。</li><li>暂停时间：由垃圾回收导致的应⽤程序停⽌响应次数/时间。</li></ul><p>垃圾收集器 :</p><ul><li>串⾏收集器（Serial Collector）<br>单线程执⾏所有的垃圾回收⼯作， 适⽤于单核CPU服务器</li></ul><p><strong>⼯作进程—–|（单线程）垃圾回收线程进⾏垃圾收集|—⼯作进程继续</strong></p><ul><li>并⾏收集器（Parallel Collector）</li></ul><p><strong>⼯作进程—–|（多线程）垃圾回收线程进⾏垃圾收集|—⼯作进程继续</strong><br>⼜称为吞吐量收集器（关注吞吐量）， 以并⾏的⽅式执⾏年轻代的垃圾回收， 该⽅式可以显著降<br>低垃圾回收的开销(指多条垃圾收集线程并⾏⼯作，但此时<strong>⽤户线程仍然处于等待状态</strong>)。适⽤于多<br>处理器或多线程硬件上运⾏的数据量较⼤的应⽤</p><ul><li>并发收集器（Concurrent Collector）<br>以并发的⽅式执⾏⼤部分垃圾回收⼯作，以缩短垃圾回收的暂停时间。适⽤于那些响应时间优先于<br>吞吐量的应⽤， 因为该收集器虽然最⼩化了暂停时间(<strong>指⽤户线程与垃圾收集线程同时执⾏,但不⼀<br>定是并⾏的，可能会交替进⾏)， 但是会降低应⽤程序的性能</strong></li><li>CMS收集器（Concurrent Mark Sweep Collector）</li></ul><p><strong>并发标记清除收集器</strong>， 适⽤于那些更愿意缩短垃圾回收暂停时间并且负担的起与垃圾回收共享处<br>理器资源的应⽤</p><ul><li><p>G1收集器（Garbage-First Garbage Collector）<br>适⽤于<strong>⼤容量内存的多核服务器</strong>， 可以在满⾜垃圾回收暂停时间⽬标的同时， 以最⼤可能性实现<br>⾼吞吐量(JDK1.7之后)</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">-XX:+UseSerialGC</td><td align="left">启⽤串⾏收集器</td></tr><tr><td align="left">-XX:+UseParallelGC</td><td align="left">启⽤并⾏垃圾收集器，配置了该选项，那么 -XX:+UseParallelOldGC默认启⽤</td></tr><tr><td align="left">-XX:+UseParNewGC</td><td align="left">年轻代采⽤并⾏收集器，如果设置了 -XX:+UseConcMarkSweepGC选项，⾃动启⽤</td></tr><tr><td align="left">-XX:+ParallelGCThreads</td><td align="left">年轻代及⽼年代垃圾回收使⽤的线程数。默认值依赖于JVM使⽤的CPU个数</td></tr><tr><td align="left">-XX:+UseConcMarkSweepGC（CMS）</td><td align="left">对于⽼年代，启⽤CMS垃圾收集器。 当并⾏收集器⽆法满⾜应⽤的延迟需求是，推荐使⽤CMS或G1收集器。启⽤该选项后， -XX:+UseParNewGC⾃动启⽤。</td></tr><tr><td align="left">-XX:+UseSerialGC</td><td align="left">启⽤G1收集器。 G1是服务器类型的收集器， ⽤于多核、⼤内存的机器。它在保持⾼吞吐量的情况下，⾼概率满⾜GC暂停时间的⽬标。</td></tr></tbody></table><p>  将上述参数 放入 /bin/catalina.sh 大长篇注释下方就可以了。</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">JAVA_OPTS</span>=<span class="hljs-string">"-XX:+UseG1GC"</span></code></pre></div><p>  接下来使用 jdk 自带的 jconsole 监控可查看启用的垃圾回收器，如下图：<br><img src="https://img-blog.csdnimg.cn/202006212029416.png" srcset="/img/loading.gif" alt="G1"></p></li></ul><h4 id="2-2-Tomcat-配置调优"><a href="#2-2-Tomcat-配置调优" class="headerlink" title="2.2 Tomcat 配置调优"></a>2.2 Tomcat 配置调优</h4><p>Tomcat⾃身相关的调优</p><ul><li><p>使用并调整tomcat线程池 conf/server.xml<br><img src="https://img-blog.csdnimg.cn/20200621203144530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FhejY0NTAxNTc0NQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="server.xml配置调优"></p></li><li><p>调整tomcat的连接器，同样在 conf/server.xml </p><table><thead><tr><th align="center">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">maxConnections</td><td align="left"><strong>最⼤连接数</strong>，当到达该值后，服务器接收但不会处理更多的请求， 额外的请求将会阻塞直到连接数低于maxConnections 。可通过ulimit -a 查看服务器限制。对于CPU要求更⾼(计算密集型)时，建议不要配置过⼤ ; 对于CPU要求不是特别⾼时，建议配置在2000左右(受服务器性能影响)。 当然这个需要服务器硬件的⽀持</td></tr><tr><td align="center">maxThreads</td><td align="left">最⼤线程数,需要根据服务器的硬件情况，进⾏⼀个合理的设置</td></tr><tr><td align="center">acceptCount</td><td align="left">最⼤排队等待数,当服务器接收的请求数量到达maxConnections ，此时Tomcat会将后⾯的请求，存放在任务队列中进⾏排序， acceptCount指的就是任务队列中排队等待的请求数 。 <strong>⼀台Tomcat的最⼤的请求处理数量，是maxConnections+acceptCount</strong></td></tr></tbody></table><p><strong>⚠️ 基础小知识：Uimit -n 查看文件描述符，每个进程开启一个soeket连接，都会占用一个文件描述符。所以 可打开的最大文件数就是最大连接数。在Linux系统中一切皆可以看成是文件。因为建立链接也是要读写</strong></p></li><li><p>禁⽤ AJP 连接器</p><div class="hljs"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;Connector port="8009" protocol="AJP/1.3" redirectPort="8443" /&gt; --&gt;</span></code></pre></div><p><strong>⚠️AJPV13协议是面向包的。WEB服务器和 servlet容器通过TCP链接来交互；为节省SOCKET创建的昂贵代价，WEB服务器会尝试维护一个永久TCP链接到servlet容器，并且在多个请求和响应周期过程会重用链接，所以用不到AJP。</strong></p></li></ul><p>我们一般是使用Nginx+tomcat的架构，所以用不着AJP协议</p><ul><li><p>调整 IO 模式<br>修改如下内容：</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"HTTP/1.1"</span>                    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>                    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span></code></pre></div><p>  修改protocol的值为org.apache.coyote.http11.Http11NioProtocol</p>  <div class="hljs"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8080"</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span>                    <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">"20000"</span>                    <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">"8443"</span> /&gt;</span></code></pre></div><p>  Tomcat8之前的版本默认使⽤BIO（阻塞式IO），对于每⼀个请求都要创建⼀个线程来处理，不适合⾼并发；Tomcat8以后的版本默认使⽤NIO模式（⾮阻塞式IO）<br>  当Tomcat并发性能有较⾼要求或者出现瓶颈时，我们可以尝试使⽤APR模式，APR（Apache Portable Runtime）是从操作系统级别解决异步IO问题，使⽤时需要在操作系统上安装APR和Native（因为APR原理是使⽤使⽤JNI技术调⽤操作系统底层的IO接⼝）</p></li><li><p>动静分离（前后端分离用不上）<br>可以使⽤Nginx+Tomcat相结合的部署⽅案，Nginx负责静态资源访问，Tomcat负责Jsp等动态资源访问处理（因为Tomcat不擅⻓处理静态资源）目前都是前后端分离，Nginx 一般用作反向代理，打到不同的Tomcat。</p></li></ul><blockquote><p><em>《拉勾教育》Tomcat 笔记整理</em></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Tomcat</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>spring-mvc 思维导图 （知识点&amp;手写mvc核心思想）</title>
    <link href="/2020/06/12/spring-mvc-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%89%8B%E5%86%99mvc%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%89/"/>
    <url>/2020/06/12/spring-mvc-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE-%EF%BC%88%E7%9F%A5%E8%AF%86%E7%82%B9-%E6%89%8B%E5%86%99mvc%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h4 id="脑图清晰版地址-："><a href="#脑图清晰版地址-：" class="headerlink" title="脑图清晰版地址 ："></a>脑图清晰版地址 ：</h4><p><a href="https://www.processon.com/view/link/5ee1b6bae401fd1fd288645d" target="_blank" rel="noopener">https://www.processon.com/view/link/5ee1b6bae401fd1fd288645d</a></p><h4 id="缩略图-："><a href="#缩略图-：" class="headerlink" title="缩略图 ："></a>缩略图 ：</h4><p><img src="/images/springmvc_optimized.png" srcset="/img/loading.gif" alt></p><p>（from lagouedu lesson notes）</p>]]></content>
    
    
    <categories>
      
      <category>lagouedu notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>spring-mvc 源码解读记录</title>
    <link href="/2020/06/12/spring-mvc-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/06/12/spring-mvc-%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Spring-mvc-初始化（分析Bean在servlet创建的时机）"><a href="#一、Spring-mvc-初始化（分析Bean在servlet创建的时机）" class="headerlink" title="一、Spring-mvc 初始化（分析Bean在servlet创建的时机）"></a>一、Spring-mvc 初始化（分析Bean在servlet创建的时机）</h2><p>首先我们通过断点调试知道AbstractApplicationContext#refresh 为Bean初始化的核心方法。测试发现，启动tomcat 并不会初始化Bean，只有真正访问才能执行到HttpServletBean#initServletBean方法，通过调用栈发现，最终执行到refresh，初始化Bean开始。</p><p>到最后finishRefresh()执行中，进去会发现AbstractApplicationContext#publishEvent方法，真正的事件驱动，发布事件，最终会发布给监听的DispatcherServlet#onRefresh 方法<br>DispatcherServlet#initStrategies初始化策略才真正执行。<br><strong>也就达成 servlet 请求-&gt; bean 初始化 -&gt; initStrategies 初始化策略的整个流程。</strong></p><p>时序图如下 ：</p><p><img src="/images/spring-mvc-init.jpg" srcset="/img/loading.gif" alt></p><p>原图链接 -&gt; <a href="https://www.processon.com/view/link/5ee2f8836376891e81c63250" target="_blank" rel="noopener">https://www.processon.com/view/link/5ee2f8836376891e81c63250</a></p>]]></content>
    
    
    <categories>
      
      <category>spring-mvc</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>spring 思维导图</title>
    <link href="/2020/06/04/spring-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <url>/2020/06/04/spring-%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h4 id="脑图清晰版地址-："><a href="#脑图清晰版地址-：" class="headerlink" title="脑图清晰版地址 ："></a>脑图清晰版地址 ：</h4><p><a href="https://www.processon.com/view/link/5ee0f974f346fb1ae5591907#map" target="_blank" rel="noopener">https://www.processon.com/view/link/5ee0f974f346fb1ae5591907#map</a></p><h4 id="缩略图-："><a href="#缩略图-：" class="headerlink" title="缩略图 ："></a>缩略图 ：</h4><p><img src="/images/springiocaop_optimized.png" srcset="/img/loading.gif" alt></p><p>（from lagouedu lesson notes）</p>]]></content>
    
    
    <categories>
      
      <category>lagouedu notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mybatis 思维导图</title>
    <link href="/2020/05/23/mybatis%20%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1&amp;%E8%84%91%E5%9B%BE%E6%80%BB%E7%BB%93/"/>
    <url>/2020/05/23/mybatis%20%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1&amp;%E8%84%91%E5%9B%BE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4 id="脑图清晰版地址-："><a href="#脑图清晰版地址-：" class="headerlink" title="脑图清晰版地址 ："></a>脑图清晰版地址 ：</h4><p><a href="https://www.processon.com/view/link/5ecc8744e0b34d5f262e4113" target="_blank" rel="noopener">https://www.processon.com/view/link/5ecc8744e0b34d5f262e4113</a></p><h4 id="缩略图-："><a href="#缩略图-：" class="headerlink" title="缩略图 ："></a>缩略图 ：</h4><p><img src="/images/mybatis_optimized.png" srcset="/img/loading.gif" alt></p><h4 id="源码传送门-："><a href="#源码传送门-：" class="headerlink" title="源码传送门 ："></a>源码传送门 ：</h4><p><a href="https://github.com/znbsmd/simple_mybatis_framework.git" target="_blank" rel="noopener">https://github.com/znbsmd/simple_mybatis_framework.git</a></p><p>（from lagouedu lesson notes）</p>]]></content>
    
    
    <categories>
      
      <category>lagouedu notes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java 版本切换</title>
    <link href="/2020/05/18/java-%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/"/>
    <url>/2020/05/18/java-%E7%89%88%E6%9C%AC%E5%88%87%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="记一次本地开发版本切换"><a href="#记一次本地开发版本切换" class="headerlink" title="记一次本地开发版本切换"></a>记一次本地开发版本切换</h2><p>mac 下：</p><h3 id="1-vi-bash-profile"><a href="#1-vi-bash-profile" class="headerlink" title="1. vi ~/.bash_profile"></a>1. vi ~/.bash_profile</h3><ul><li><p>设置 JDK 11 </p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_11_HOME</span>=$(/usr/libexec/java_home -v 11)</code></pre></div></li><li><p>设置 JDK 12</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_12_HOME</span>=$(/usr/libexec/java_home -v 12)</code></pre></div><ul><li>alias命令动态切换JDK版本</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-built_in">alias</span> jdk11=<span class="hljs-string">"export JAVA_HOME=<span class="hljs-variable">$JAVA_11_HOME</span>"</span><span class="hljs-built_in">alias</span> jdk12=<span class="hljs-string">"export JAVA_HOME=<span class="hljs-variable">$JAVA_12_HOME</span>"</span></code></pre></div><h3 id="2-source-bash-profile"><a href="#2-source-bash-profile" class="headerlink" title="2. source ~/.bash_profile"></a>2. source ~/.bash_profile</h3><h3 id="3-jdk11-or-jdk-12"><a href="#3-jdk11-or-jdk-12" class="headerlink" title="3. jdk11 or  jdk 12"></a>3. jdk11 or  jdk 12</h3><p>执行 jdk11 / jdk 12 命令可来回切换。java -version 查看</p><p>注⚠️： </p><ol><li><p>zsh 可以设置在 ~/.zshrc </p></li><li><p>$(/usr/libexec/java_home -v 12) 别忘了加上 shell变量符号，读到真实命令地址。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>工具篇</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>调优案例分许与实战</title>
    <link href="/2020/05/17/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E8%AE%B8%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/2020/05/17/%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E8%AE%B8%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-案例分析"><a href="#一、-案例分析" class="headerlink" title="一、 案例分析"></a>一、 案例分析</h2><h4 id="1-大内存硬件伤的程序部署策略"><a href="#1-大内存硬件伤的程序部署策略" class="headerlink" title="1. 大内存硬件伤的程序部署策略"></a>1. 大内存硬件伤的程序部署策略</h4><p>场景： 一个15w pv的在线文档网站， -Xms 设置堆 为 12G，一次full GC 停顿高达 14秒。造成网站失去响应。<br>原因是文档序列化产生的大对象，直接进入老年代。（缩小堆内存确实可以减少长时间停顿，但是在硬件上内存资源就浪费了。）</p><p>解决方案：</p><ol><li>直接使用64位系统，并为JVM分配大内存。通过扩大堆内存减少垃圾回收次数，从而避免程序频繁的停顿。如若能把次数控制在每天1、2次，并且发生在深夜的话，那么也不是不能接受。</li></ol><p>带来的问题：</p><div class="hljs"><pre><code>- 内存回收导致的长时间停顿。- 64位JDK性能较32位JDK低。- 相同的程序在64位JDK要比在32位JDK消耗更大的内存。- 堆溢出后几乎无法生存堆转储快照(产生的Dump文件高达10多G，并且即便生成快照也几乎无法进行分析)。</code></pre></div><ol start="2"><li>虚拟机建立逻辑集群</li></ol><p>64位JDK有不少问题存在，因此采用32位JDK建立逻辑集群的方式仍有不少人选择，具体做法是在机器上启动多个服务器应用进程，每个进程设置不同的端口，然后再启动一个负载均衡的进程，使用反向代理的方式将请求分发给各个服务器应用进程。</p><p>带来的问题：</p><ul><li>磁盘等共享资源竞争</li><li>大量使用本地缓存，造成大量内存浪费，缓存集中缓存redis</li><li>各个节点受到32位系统的限制</li></ul><p>每个方案都会有相应的问题，具体根据应用场景来分析。<br>书中选择方案2，因为 用户对响应比较在意，对处理器性能要求并不是很大，所以选择 5个 32位 逻辑集群解决此问题。</p><h4 id="2-集群间同步导致的内存溢出"><a href="#2-集群间同步导致的内存溢出" class="headerlink" title="2. 集群间同步导致的内存溢出"></a>2. 集群间同步导致的内存溢出</h4><p>场景：</p><p>基于B/S的MIS系 统 ,硬件为两台2个CPU、8GB内存的HP小型机,服务器是WebLogic 9.2 ,每台机器启动了3个WebLogic实 例 ,构成一个6个节点的亲合式集群。由于是亲合式集群,节点之间没有进行Sessurn同步,但是有一些需求要实现部分数据在各个节点间共享。开始这些数据存放在数据库中,但由于读写频繁竞争很激烈,性能影响较大,后面 使用JBossCache构建了 一个全局缓存。全局缓存启用后,服务正常使用了一段较长的时间, 但最近却不定期地出现了多次的内存溢出问题。</p><p>发现问题：</p><p>让服务带着-XX : +HeapDumpOnOutOfMemoryError參数运行了一段时间。在最近一次溢出之后,管理员发回了 heapdump文件 ,发现里面存在着大量的org.jgroups.protocols.pbcast.NAKACK对象。</p><p>缺陷：</p><p>缺陷是这一类被集群共享的数据要使用类似JBossCache这种集群缓存来同步的话 ,可以允许读操作频繁,因为数据在本地内存有一份副本,<strong>读取的动作不会耗费多少资源 ,但不应当有过于频繁的写操作,那样会带来很大的网络同步的开销。所以要采用 集中式缓存</strong></p><h4 id="3-堆外内存导致的溢出错误"><a href="#3-堆外内存导致的溢出错误" class="headerlink" title="3. 堆外内存导致的溢出错误"></a>3. 堆外内存导致的溢出错误</h4><p>场景：</p><p>电子考试系统。普通PC机 , Core i5 CPU , 4GB内存,运行32位Windows操作系统。选用CometD 1.1.1作为服务端推送框架。服务端不定时拋出内存溢出异常,服务器不一定每次都会出现异常,32位系统最多到1.6GB就基本无法再加大了,而且开大了基本没效果,拋出内存溢出异常好像还更加频繁了。加入-XX :+HeapDumpOnOutOfMemoryError,居然也没有任何反应,拋出内存溢出异常时什么文件都没有产生。无奈之下只好挂着jstat并一直紧盯屏幕,发现GC并不频 繁 ,Eden区、Survivor区、老年代以及永久代内存全部都表示“情绪稳定,压力不大”, 但就是照样不停地拋出内存溢出异常,管理员压力很大。最后 ,在内存溢出后从系统日志中找到异常堆栈。</p><div class="hljs"><pre><code class="hljs undefined">[org<span class="hljs-selector-class">.eclipse</span><span class="hljs-selector-class">.jetty</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.log</span>]handle failed java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.OutOfMemoryError</span>:null at sun<span class="hljs-selector-class">.raise</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.allocateMemory</span> (Native Method )at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.DirectByteBuffer</span>.&lt;init&gt; (DirectByteBuffer<span class="hljs-selector-class">.java</span> :<span class="hljs-number">99</span> )at java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.ByteBuffer</span><span class="hljs-selector-class">.allocateDirect</span> (ByteBuffer<span class="hljs-selector-class">.java</span> :<span class="hljs-number">288</span> )at org<span class="hljs-selector-class">.eclipse</span><span class="hljs-selector-class">.jetty</span><span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.DirectNIOBuffer</span>.&lt;init&gt;...</code></pre></div><p>问题所在：</p><p>32位 Windows平台的限制是2GB ,其中划了1.6GB给Java堆 ,而Direct Memory内存并不算入1.6GB的堆之内,因此它最大也只能在剩余的0.4GB空间中分出一部分。在此应用中导致溢出的关键是:垃圾收集进行时,虚拟机虽然会对Direct Memory进行回收,但是Direct Memory却不能像新生代、老年代那样,发现空间不足了就通知收集器进行垃圾回收,它只能等待老年代满了后Full GC , 然后“顺便地”帮它清理掉内存的废弃对象。否则它只能一直等到拋出内存溢出异常时,先catch掉 ,再在catch块里面“大喊声:“System.gc()! ”。要是虚拟机还是不听 ( 譬如打开了-XX:+DisableExplicitGC开关),那就只能眼睁睁地看着堆中还有许多空闲内存 ,自己却不得不拋出内存溢出异常了。而本案例中使用的CometD 1.1.1框架,正好有大量的NIO操作需要使用到Direct Memory内存。<strong>简言之：就是java直接内存不会主动gc，只能等full gc ，顺便gc。</strong></p><p>解决方案&amp;总结：</p><p>下面这些区域还会占用较多的内存,这里所有的内存总和受到操作系统进程最大内存的限制：</p><ul><li>Direct Memory : 可通过-XX : MaxDirectMemorySize调整大小,内存不足时拋出OutOfMemoryError或者OutOfMemoryError : Direct buffer memory。</li><li>线程堆栈:可通过-Xss调整大小,内存不足时拋出StackOverflowError (纵向无法分配, 即无法分配新的栈帧)或者OutOfMemoryError : unable to create new native thread (横向无法分配 ,即无法建立新的线程)。</li><li>Socket缓存区:每个Socket连接都Receive和Send两个缓存区,分别占大约37KB和25KB内存,连接多的话这块内存占用也比较可观。如果无法分配,则可能会拋出IOException : Too many open files异常。</li><li>JNI代码 :如果代码中使用JNI调用本地库,那本地库使用的内存也不在堆中。</li><li>虚拟机和GC:虚拟机、GC的代码执行也要消耗一定的内存。</li></ul><h4 id="4-外部命令导致系统缓慢"><a href="#4-外部命令导致系统缓慢" class="headerlink" title="4. 外部命令导致系统缓慢"></a>4. 外部命令导致系统缓慢</h4><p>场景：</p><p>一个数字校园应用系统，通过操作系统的mpstat工具发现CPU使用率很高,并且系统占用绝大多数的CPU资源的程序并不是应用系统本身。Dtrace运行后发现最消耗CPU资源的竟然是“fork”系统调用。</p><p>问题所在：</p><p>每个用户请求执行shell脚本来获得系统的一些信息。通过Java的 Runtime.getRuntime().exec() 方法来调用的。但是它在Java 虚拟机中是非常消耗资源的操作,即使外部命令本身能很快执行完毕,频繁调用时创建进程 的开销也非常可观。Java虚拟机执行这个命令的过程是:首先克隆一个和当前虚拟机拥有一样环境变量的进程,再用这个新的进程去执行外部命令,最后再退出这个进程。如果频繁执 行这个操作,系统的消耗会很大,不仅是CPU, 内存负担也很重。</p><p>解决方案：</p><p>去掉shell ，改成java api 调用。</p><h4 id="5-服务器JVM进程崩溃"><a href="#5-服务器JVM进程崩溃" class="headerlink" title="5. 服务器JVM进程崩溃"></a>5. 服务器JVM进程崩溃</h4><p>场景：</p><p>B/S 系统出现集群节点的虚拟机进程自动关闭的现象，查看log，出现 java.net.SocketException :Connection reset 异常。这是一个远端断开连接的异常,业务场景是一个OA门户做了集成 ,在MIS系统工作流的待办事项变化时,要通过Web服务通知0A门户系统,把待办事项的变化同步到OA门户之中。通过SoapU测试了一下同步待办事项的几个Web服务,发现调用后竟然需要长达3分钟才能返回,并且返回结果都是连接中断。</p><p>解决方案：</p><p>由于两边处理速度不对等，导致请求积压，改为生产者/消费者模式的消息队列实现后,系统恢复正常。</p><h4 id="6-不恰当数据结构导致内存占用过大"><a href="#6-不恰当数据结构导致内存占用过大" class="headerlink" title="6. 不恰当数据结构导致内存占用过大"></a>6. 不恰当数据结构导致内存占用过大</h4><p>场景：</p><p>后台RPC服务器,使用64位虚拟机,内存配置为-Xms4g-Xmx8g-Xmnlg, 使用ParNew+CMS的收集器组合。<br>业务上需要每10分钟加载一个约80MB的数据文件到内存进行数据分析,这些数据会在内存中形成超过100万个HashMap&lt;Long,Long&gt;Entry,在这段时间里面Minor GC就会造成超过500毫秒的停顿,对于这个停顿时间就接受不了了。</p><p>原因：</p><p>查看GC日志得到800MB的Eden空间很快被填满从而引发GC ,但Minor GC之后,新生代中绝大部分对象依然是存活的。ParNew收集器使用的是复制算法,这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的,如果存活对象过多,把这些对象复制到Survivor并维持这些对象引用的正确就成为一个沉重的负担,因此导致GC暂停时间明显变长。</p><p>解决方案：</p><p>HashMap&lt; Long,Long&gt; 结构来存储数据文件空间效率太低。修改存文件的数据结构。(Long(24B)x2)+Entry(32B)+HashMap Ref(8B)=88B,空间效率为16B/88B=18%,太低了。</p><h4 id="7-由Windows虚拟内存导致的长时间停顿"><a href="#7-由Windows虚拟内存导致的长时间停顿" class="headerlink" title="7. 由Windows虚拟内存导致的长时间停顿"></a>7. 由Windows虚拟内存导致的长时间停顿</h4><p>场景：</p><p>带心跳检测功能的GUI桌面程序,每15秒会发送一次心跳检测信号,如果对方30秒以内都没有信号返回,那就认为和对方程序的连接已经断开。程序上线后发现心跳检测有误报的概率,查询日志发现误报的原因是程序会偶尔出现间隔约一分钟左右的时间完全无日志输出,处于停顿状态。从日志中可以看出,真正执行GC动作的时间不是很长,但从准备开始GC ,到真正开始GC之间所消耗的时间却占了绝大部分。</p><p>原因：</p><p>最小化的时候,资源管理中显示的占用内存大幅度减小,但是虚拟内存则没有变化,因此怀疑程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中了,这样发生GC时就有可能因为恢复页面文件的操作而导致不正常的GC停顿。</p><p>解决方案：</p><p>加入参数“-Dsun.awt.keepWorkingSetOnMinimize=true”来解决。这个参数在许多AWT的程序上都有应用,例如JDK自带的Visual VM,用于保证程序在恢复最小化时能够立即响应。</p><h4 id="8-安全点导致的长时间停顿"><a href="#8-安全点导致的长时间停顿" class="headerlink" title="8. 安全点导致的长时间停顿"></a>8. 安全点导致的长时间停顿</h4><p>场景：</p><p>HBase集群，运行在JDK 8上，使用G1收集器。Spark离线分析任务对其进行访问，同时有很多其他在线集群Replication过来的数据写入，因为集群读写压力较大，而离线分析任务对延迟又不会特别敏感，所以将-XX：MaxGCPauseMillis（最大暂停时间）参数设置到了500毫秒。不过运行一段时间后发现垃圾收集的停顿经常达到3秒以上，而且实际垃圾收集器进行回收的动作就只占其中的几百毫秒。</p><p>解决方案：</p><ol><li><p>第一步是把这两个特别慢的线程给找出来，添加-XX：+SafepointTimeout和-XX：SafepointTimeoutDelay=2000两个参数，让虚拟机在等到线程进入安全点的时间超过2000毫秒时就认定为超时，log就会输出线程名称</p></li><li><p>把循环索引的数据类型从int改为long即可。</p></li></ol><p>（没太理解 ，先记下。）</p>]]></content>
    
    
    <categories>
      
      <category>《深入理解java虚拟机》读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JVM 检测工具集</title>
    <link href="/2020/05/11/JVM-%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E9%9B%86/"/>
    <url>/2020/05/11/JVM-%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h2 id="一-基础故障处理工具"><a href="#一-基础故障处理工具" class="headerlink" title="一.  基础故障处理工具"></a>一.  基础故障处理工具</h2><ol><li><p>jps ： 虚拟机进程状况工具</p><p> jps -l 列出 java 所以进程<br> jsp -v 列出虚拟机参数</p></li><li><p>jstat ： 虚拟机统计信息监视工具</p><p> jstat -gcutil 3455 输出已使用空间占总空间百分比。</p></li><li><p>jinfo : Java 配置信息工具</p><p> jinfo -flag 查看jvm参数默认值</p></li><li><p>jmap ： Java 内存映像工具</p><p> 生成堆转储快照（heapdump / dump）</p><p> example : jmap -dump:live,format=b,file=heap.bin <pid></pid></p></li><li><p>jhat : 快照分析工具</p><p> jhat heap.bin 生成本地访问地址。</p></li><li><p>jstack ： java 堆栈跟踪工具</p></li></ol><h2 id="二、-可视化工具"><a href="#二、-可视化工具" class="headerlink" title="二、 可视化工具"></a>二、 可视化工具</h2><ol><li><p>JHSDB ： 服务性代理的调试工具</p></li><li><p>JConsole ： java 监视与管理控制台</p></li><li><p>visualvm 可视化分析，功能强大，9 以后 不在jdk 包里 ，下载地址： <a href="https://visualvm.github.io/download.html" target="_blank" rel="noopener">https://visualvm.github.io/download.html</a></p></li><li><p>Java Mission Control :可持续在线监控工具</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《深入理解java虚拟机》读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收器与内存分配策略</title>
    <link href="/2020/04/26/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <url>/2020/04/26/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-概述"><a href="#一、-概述" class="headerlink" title="一、 概述"></a>一、 概述</h2><p>程序计数器、虚拟机栈、本地方法栈随线程而生，随线程而灭。栈中的栈帧分配多少内存基本是在类结构确定下来时就已知的，大体可认为是编译期已知的，因此这几个内存分配区域都具备确定性。当方法结束或线程调用结束，内存自然就回收了，不必如何考虑回收。</p><h2 id="二、-对象已死？"><a href="#二、-对象已死？" class="headerlink" title="二、 对象已死？"></a>二、 对象已死？</h2><p>对象死去将不会被任何途径使用对象了。</p><ol><li><p>引用计数算法</p><p> 单纯的引用计数（引用加一减一）很难解决循环引用问题。</p></li><li><p>可达性分析算法</p><p> 通过一系列称为“GC Roots”的根对象作为起始节点，通过节点开始，根据引用关系向下搜索，走过的所有路径称为“引用链”，如果路径上没有任何引用链相连，就是对象不可达，不会判断可回收对象。</p><p> 固定作为GC Roots对象包含以下几种：</p><ul><li>在虚拟机栈中引用对象，如被线程调用的方法堆栈中使用的参数、局部变量、临时变量等。</li><li>在方法区中类静态引用变量，如java类的引用类型静态变量。</li><li>在方法区中类常量引用变量，如字符串常量池里的引用。</li><li>方法栈中native 中引用对象。</li><li>java虚拟机内部引用，如基本数据类型对应的Class对象，一些常驻的异常对象（NullPointExcepiton、OutOfMemoryError），还有系统类加载器。</li><li>所有被ybchronized关键字持有的对象。</li><li>反映Java虚拟机内部情况的KMXBean、JVMTI中注册的回调、本地代码缓存等。<br>除了以上还会有局部回收和分代收集共建完成GC Roots。</li></ul></li><li><p>再谈引用</p><p> 如果只有被引用或未被引用就会显得过于狭隘，对描述一些“食之无味，弃之可惜”的对象就显得无力，很多系统缓存功能就能够兼容这种能力。</p><p> 在jdk 1.2以后，对引用进行扩充，分为强引用、软引用、弱引用、虚引用，强度逐渐减弱。</p><ul><li>强： new Object();</li><li>软： 描述还有用但非必须的对象。在系统要发生内存溢出异常前，会把这些对象进行二次回收。 SoftReference。</li><li>弱： 非必须的对象。生存到下一次垃圾收集为止。无论内存是否充足。 WeakReference。</li><li>虚： 此对象被收集时收到系统同志，其他毫无用处。PhantomReference。</li></ul></li><li><p>生存还是死亡</p><p> 需要2此标记才能死亡。</p><ul><li><p>没有 GC Roots相连，标记一次，</p></li><li><p>没必要执行finalize()【没重写finalize()或者finalize()已经被虚拟机调用过。】这种叫没必要执行。标记一次。</p><p>如果必须执行finalize()，重写finalize()把引用链重新引用上，则仍然可以存活。（但是不承诺执行完。finalize()只会被系统自动调用一次）</p><p>不建议用finalize()，完成可以用try/cache代替并做的更好。因为它运行代价高，并不能保证调用顺序，不确定性大（不承诺执行完），只是java刚诞生让c/c++更接受java做的一点妥协。</p></li></ul></li><li><p>回收方法区</p><p> 回收方法区性价比比较低。回收需要满足3个条件</p><ul><li>该类所有实例被回收，包括任何派生子类</li><li>加载该类的类加载器已经被回收</li><li>该类对应的Class 对象没有引用，无法反射创建。<br>在大量使用反射代理框架，通常都需要Java虚拟机具备卸载的能力，保证方法区造成过大压力。</li></ul></li></ol><h2 id="三、-垃圾回收算法"><a href="#三、-垃圾回收算法" class="headerlink" title="三、 垃圾回收算法"></a>三、 垃圾回收算法</h2><p>各个平台虚拟机操作都有差异。</p><ol><li><p>分代收集理论</p><p> 夸代相互引用，会让新生代晋升到老年代，进而消除。</p></li><li><p>标记清除算法</p><p> 缺点：内存碎片化，（因为对象不移动，所以导致块是不连续的，容易出现空闲内存很多，但分配大对象时找不到合适的块。）大量对象标记清除过长效率低；</p></li></ol><ol start="3"><li><p>标记复制算法</p><p> 半区复制，分为2块区域，当一块用完了就把存活的放在另外一块，然后针对整个半区回收。缺点：空间浪费。一般都是回收新生代，因为大部分对象有98%都熬不过第一轮。<br> 后面优化为Appel 回收 按实际场景设置比例分区，分为 Eden和 2个Survivor。其中一个Survivor进行存活对象保存。另外进行分配担保，当Survivor回收时候没有足够空间存放上一次新生代收集下来的存活对象，会进入老年代。</p></li><li><p>标记- 整理算法</p><p> 清除并重新整理。</p></li></ol><p>标记复制与标记整理都有弊端，复制分配时复杂，整理是回收时复杂（大的对象移动是一种负重。）</p><h2 id="四、-HotSpot-算法细节实现"><a href="#四、-HotSpot-算法细节实现" class="headerlink" title="四、 HotSpot 算法细节实现"></a>四、 HotSpot 算法细节实现</h2><ol><li><p>ZGC收集器 （5月17日补充…）</p><ul><li><p>解决的问题<br>ZGC 是最新的 JDK1.11 版本中提供的高效垃圾回收算法，ZGC 针对大堆内存设计可以支持 TB 级别的堆，ZGC 非常高效，能够做到 10ms 以下的回收停顿时间。</p></li><li><p>简介：<br>采用染色指针技术， 把标记直接记录在引用对象的指针上。</p></li><li><p>优势：</p><ol><li><p>某个Region存活对象被移走后，可以立即被释放或重用掉。</p></li><li><p>读屏障（一部分是因为染色在指针记录，一部分是 ZGC不支持分代回收，无夸代引用的问题。），ZGC 使用读屏障来解决 GC 线程和应用线程可能并发修改对象状态的问题，而不是简单粗暴的通过 STW 来进行全局的锁定。使用读屏障只会在单个对象的处理上有概率被减速。</p></li><li><p>可扩展， Linux 64位指针还有 18位没用，<br>如果可用18位存储标志信息，可以腾出 已用的4 个标志位， 也就是可用 46位最大寻址，那可以扩展到64TB（2的46次幂）</p></li></ol></li><li><p>ZGC工作原理：</p><ol><li><p>并发标记 开始进行回收时，ZGC 首先会进行一个短暂的 STW，来进行 roots 标记。这个步骤非常短，因为 roots 的总数通常比较小。</p></li><li><p>并发预备重分配</p></li><li><p>重分配（核心）：<br> 把存活的对象分配到新的Region中，为每个Region维护一个转发表，记录从旧对象到新对象的转向关系。因为有染指，从引用旧知道一个对象是否处于重新分配集中。如果并发访问重分配集中，会被内存屏障截获，然后立即根据Region 表中的转发记录将访问转发到新复制的对象上，并同时修正新的引用值，指向新对象，这叫指针的“自愈”。好处是只有第一次访问旧对象会陷入转发，只慢一次。</p></li><li><p>并发重映射：<br> 重映射清理旧引用为了不变慢，（清理后顺便释放转发表这样的附带收益），所以说这并不是很“迫切”。因此，ZGC 很巧妙的把并发重映射阶段要做的工作，合并到下一次垃圾回收，反正都是要遍历所有对象。节省资源。</p></li></ol></li></ul></li></ol><div class="hljs"><pre><code>- 染色指针的解释：    - 目前在Linux下64位的操作系统中高18位是不能用来寻址的，但是剩余的46为却可以支持64T的空间，到目前为止我们几乎还用不到这么多内存。于是ZGC将46位中的高4位取出，用来存储4个标志位，剩余的42位可以支持4TB(2的42次幂)的内存，也直接导致ZGC可以管理的内存不超过4TB。    - 限制：只能在64位系统上，因为ZGC设置就是用的42-46位，32位明显不够嘛。。并且不支持压缩指针（这一块可以参考Java对象模型中的OOP，meta中有一个Klass直接指向Klass，还一个压缩指针）</code></pre></div><p>先注重实战，建议先略过～（用到在回来补充）</p><h2 id="七、选择适合的策略"><a href="#七、选择适合的策略" class="headerlink" title="七、选择适合的策略"></a>七、选择适合的策略</h2><p>各类策略各有优势，根据实际场景选择。</p><ol><li>垃圾回收日志</li></ol><ul><li>GC基本信息：jdk9 之前 使用 -XX：+PrintGC 之后 -Xlog:gc</li><li>GC详细信息： 9 之前 -XX:+PrintGCDetails, 大于9  -X-log：gc*</li></ul><p>…</p><h2 id="八、-实战：内存分配与回收策略"><a href="#八、-实战：内存分配与回收策略" class="headerlink" title="八、 实战：内存分配与回收策略"></a>八、 实战：内存分配与回收策略</h2><ol><li><p>对象优先分配在Eden</p><p> 没有足够空间进行一次Minor GC。</p></li><li><p>大对象直接进入老年代</p></li><li><p>长期存活对象进入老年代</p></li><li><p>动态对象年龄判定</p></li><li><p>空间分配担保</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《深入理解java虚拟机》读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java 内存区域与内存溢出异常</title>
    <link href="/2020/04/25/java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <url>/2020/04/25/java-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-运行时数据区域"><a href="#一、-运行时数据区域" class="headerlink" title="一、 运行时数据区域"></a>一、 运行时数据区域</h2><ol><li><p>程序计数器</p><p> 线程私有。<strong>当前线程执行的字节码的行号跟踪器，字节码解释器工作时就是改变计数器的值来选取下一条需要执行的字节码指令。</strong>（分支、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器。）</p></li><li><p>虚拟机栈</p><p> 线程私有。生命周期与线程相同。虚拟机栈描述的是java方法执行的线程内存模型（JMM）：每个方法被执行，虚拟机同步创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<strong>每一个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟栈中从入栈到出栈的过程。</strong></p></li><li><p>本地方法栈</p><p> 线程私有。与虚拟栈相似。为native服务。</p></li><li><p>java 堆</p><p> 线程共享。几乎所有的对象实例都在这里分配。堆是垃圾收集器管理的内存区域。堆是可以扩展的，也可以实现成固定大小的。通过-Xmx和-Xms 设定。当java没有内存实例分配，并缺堆无法扩展时，java 会抛出OOM异常。</p></li><li><p>方法区</p><p> 与java堆一样，线程共享。存储被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。java8 之前 方法区即永久代（有-XX：MaxPermSize 上限），就算不设置也有默认大小。之所以这么设计初衷是想把方法区像堆一样管理。但是并不是所有公司的虚拟机都有永久代概念，而且这种设计更容易导致溢出。在jdk 6 时候 HotSpot 就已经把原本放在永久代里的字符串常量池、静态变量等移出，而到了java8 完全废弃了永久代的概念，采用本地内存中实现的元空间，把java 7 还剩余的内容（主要是类型信息）移到了元空间。</p></li><li><p>运行时常量池</p><p> 是方法区的一部分。Class 文件除了有类的版本、字段、方法、接口等描述信息外，还有常量池表，用于存放编译生成的各种字面量与符引用，在类加载后存放到方法区的运行时常量池中。</p><p> 运行时常量池除了保存Class文件中的描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p><p> 运行时常量池相对于Class 文件常量池另一个重要的特性是具备动态性，在运行时也可以将新的常量放入池中，例如 String.intern()方法。</p></li><li><p>直接内存</p><p> 并不是虚拟机运行时数据区的一部分。也不是定义的内存区域，但是也被频繁使用，也可能导致OOM的异常出现。</p><p> 在jdk 1.4 中新加入NIO 使用native分配堆外内存，然后通过堆里的DirectByteBuffer 对象作为这块内存的引用进行操作。避免在java堆和Native堆来回复制数据。受物理内存限制，导致OOM。</p></li></ol><h2 id="二、HotSpot-虚拟机对象探秘"><a href="#二、HotSpot-虚拟机对象探秘" class="headerlink" title="二、HotSpot 虚拟机对象探秘"></a>二、HotSpot 虚拟机对象探秘</h2><ol><li><p>对象创建</p><p> 当遇到 new 指令时，首先将检查指令的参数是否在常量池定位一个类的符号引用，并检查符号引用代表的类是否被加载、解析、初始化。如果没有则被加载。</p><p> 在检查通过后，为新对象分配内存。对象所需要的内存在类加载后便可完全确定。（假如java堆分配规整，则可以用“指针碰撞”）。但是实际不会规整，虚拟机必须维护一个列表。（记录哪些内存可用，哪些不可用。）所以使用CMS这种基于清除的算法收集器时候，只能采用复杂的空间列表来分配内存。</p><p> 修改指针所指向的位置，在并发情况喜爱也不是线程安全的，一种是虚拟机采用CAS配上失败重试保证原子性。另一种是按照线程划分在不同的空间中进行。只有线程本地缓存用完了，新的线程缓存区才需要同步锁定。</p><p> 接下来java虚拟机还要堆对象进行必要设置，例如对象GC分代信息、对象hash码、哪个类的实例以及是否使用偏向锁都存放在对象头中。</p><p> 上面结束后，从虚拟机视角来看，一个新的对象已经产生。但是从java程序来看才刚开始—构造函数，还没执行，new指令后戒指 执行init方法，这才是完全构造出来。</p></li><li><p>对象的内存布局</p><ul><li>对象头 Mark Word<br><img src="/images/mark_word.png" srcset="/img/loading.gif" alt></li><li>实例数据<br>  真正存储的有效信息。</li><li>对齐填充<br>  占位符作用，补齐实例数据。</li></ul></li><li><p>对象访问定位</p><ul><li>句柄访问 在对象被移动只改变句柄存放的指针</li><li>直接指针 速度快，常用定位方式<br><img src="/images/reference.png" srcset="/img/loading.gif" alt></li></ul></li></ol><h2 id="三、-OOM-异常"><a href="#三、-OOM-异常" class="headerlink" title="三、 OOM 异常"></a>三、 OOM 异常</h2><ol><li><p>堆溢出</p><p> 常见的溢出情况。通过内存映像分析工具堆快照进行分析。简单思路：1.找到泄露对象 与哪些先看GC Root关联，或者别的原因导致垃圾回收不回收他们。2. 如果都必须存活，那么需要通过（-Xmx / -Xms）看有没有向上调整的空间。3.最后从代码检查是否某些对象生命周期过长、持有时间过长、存储结构设计不合理，尽量减少运行内存消耗。</p></li><li><p>虚拟机栈和本地方法栈溢出</p><p> 溢出情况：</p><ol><li><p>线程请求栈深度大于虚拟机所允许的最大深度，抛出StackOverFlowError。</p></li><li><p>扩展栈容量无法申请足够内存时，将抛出OOM。（HotSpot 不支持扩展）</p></li><li><p>创建多线程还可能出现OOM，把内存耗尽</p><p>解决方案：</p></li><li><p>出现StackOverFlowError 会有明确错误堆栈可供分析，确定是哪个方法，栈深度大多数到达1000-2000是完全没有问题的。（说他是大多数是因为每个方法压入的帧大小不一样。）这个深度完全够用。但是如果是建立过多的线程，在不能减少线程数或者更换64位虚拟内存来解决内存溢出的方式，就只能通过减少最大堆和减少栈容量来获取更多的线程。一般不建议，如果没有很多经验，是比较难以把控。</p></li></ol></li><li><p>方法区和运行时常量池溢出</p><ol><li><p>String.intern()循环注入常量池，设置-XX：MaxPermSize=6M 在jdk 6 出现的OOM 提示信息是“PermGen space”。在jdk 7 及以上，常量池被移至堆中（ java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中），限制方法区的容量对测试用例毫无意义。通过-Xmx 设置 6MB 会产生OOM。<strong>注意：jdk6 String.intern()会把字符串拷贝到永久代，和Stringbuilder创建字符串在堆中，所以引用不是同一个引用。用==判断会出现false。</strong></p></li><li><p>使用CGLib这类动态代理出现OOM，在jdk7中 ，大量动态创建空类，会提示“PermGen space”OOM异常。jdk 8中将不会有这种提示溢出。不过为了防止破坏性操作，也提供了一些参数：</p><ul><li>-XX:MaxMetaspaceSize: 设置元空间最大值，默认-1，不限制。受限本地内存。</li><li>-XX:MetaspaceSize: 指定元空间初始空间大小，字节单位，到达峰值就会触发垃圾收集进行类卸载，同时收集器会对此值进行调整：如果释放郭达，就降低，反之在不超过MetaspaceSize，适当提高。</li><li>-XX:MinMetaspaceFreeRatio:在垃圾回收之后控制最小元空间剩余容量百分比，可减少因为元空间不足导致的垃圾回收的频率。-XX:MaxMetaspaceFreeRatio相反。<strong>太小会增长缓慢，太大会浪费内存。</strong></li></ul></li></ol></li><li><p>本机直接内存溢出</p><p> 直接内存可通过-XX:MaxDirectMemorySize参数指定，也可以反射获取Unsafe实例进行内存分配。在jdk 10 将Unsafe开发给外部使用，虽然使用DirectByteBuffer会出现OOM，但是是通过计算得知内存无法分配在代码里手动抛出的异常，方法是Unsafe::allocateMemory()。<strong>如果发现OOM后发现Heap Dump重的Dump文件很小，而又间接直接使用DirectMemory（NIO），那么就要检查直接内存的原因了。</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>《深入理解java虚拟机》读书笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>公平锁误区(no 100% fair)</title>
    <link href="/2020/04/23/%E5%85%AC%E5%B9%B3%E9%94%81%E8%AF%AF%E5%8C%BA-no-100-fair/"/>
    <url>/2020/04/23/%E5%85%AC%E5%B9%B3%E9%94%81%E8%AF%AF%E5%8C%BA-no-100-fair/</url>
    
    <content type="html"><![CDATA[<p>今天用pushy 推送框架做了一个高吞吐apns推送，其中使用到 Semaphore （共享锁概念），用来控制推送流量，理论知识终于能得以实践了，用时候才明白好多地方了解不到位，下面来一一作答：</p><h3 id="误区一-："><a href="#误区一-：" class="headerlink" title="误区一 ："></a>误区一 ：</h3><p><img src="/images/fair_unfair.png" srcset="/img/loading.gif" alt></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>看到这里，误区来了，都以为公平锁是按线程启动顺序执行，其实并不是，原因在javadoc文档里都已经说的很明确了。传送门-&gt;<a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/Semaphore.html。" target="_blank" rel="noopener">https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/concurrent/Semaphore.html。</a></p><p> <strong>个人理解 公平锁FIFO （先进先出）在有队列时候按队列顺序取得许可，Semaphore 使用getQueueLength() 可查看是否有队列。（开始的误解是 设置3个线程进来的时候 是没有队列的，以为是按单个线程的顺序，其实是按3个一组的时候并没有队列，并不是按顺序执行的。后面有排队才是按 线程启动 acquire顺序执行的，可能说的不明白，每次acquire 后 把getQueueLength() 打印出来就明白了。)。总结就是公平锁是线程启动与acquire顺序基本一致。</strong></p><h3 id="误区二-："><a href="#误区二-：" class="headerlink" title="误区二 ："></a>误区二 ：</h3><p>误区一 是基本一致并不是100%一致的原因就是有可能同一个线程启动，并且同一个线程获取许可，这种是不100%按顺序的，原理就是 线程启动顺序并不是按顺序acquire()的，毕竟不是原子性的，所以不一定保证按顺序进入队列，只是能保证先acquire()先排队等待，防止部分线程饿死（demo就不写了，容易看乱，我就是被demo弄混乱了一整天）。</p>]]></content>
    
    
    <categories>
      
      <category>误区-踩坑</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>万恶的值传递和引用传递</title>
    <link href="/2020/04/16/%E4%B8%87%E6%81%B6-%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2020/04/16/%E4%B8%87%E6%81%B6-%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<p>今天面试栽倒了值传递和引用传递，记住了理论忘记了实际应用，归根结底还是没了解透彻，掌握了皮毛，接下来就要好好记下一笔，从此永固脑海。</p><p>在说明值传递和引用传递 需要了解几点知识，如下：</p><h2 id="一-形参与实参"><a href="#一-形参与实参" class="headerlink" title="一. 形参与实参"></a>一. 形参与实参</h2><ol><li><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p></li><li><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入</p></li></ol><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> a</span>)</span>&#123; <span class="hljs-comment">//形参</span>    a = <span class="hljs-number">20</span>;    System.<span class="hljs-keyword">out</span>.println(a);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;    <span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;    <span class="hljs-comment">//实参</span>    func(a);&#125;</code></pre></div><h2 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二. 数据类型"></a>二. 数据类型</h2><p>定义编程语言中相同类型的数据存储形式，决定了如何将代表这些值的位存储到计算机的内存中。所以，数据在内存中的存储，是根据数据类型来划定存储形式和存储位置的。</p><p>java的数据类型为4大类8大种：</p><ol><li>int、long、short、byte // 整型</li><li>float、double // 浮点</li><li>char // 字符</li><li>boolean //布尔</li></ol><p>有了数据类型，JVM对程序数据的管理就规范化喽。</p><h2 id="三-栈-（每个方法调用存在每个栈中）"><a href="#三-栈-（每个方法调用存在每个栈中）" class="headerlink" title="三. 栈 （每个方法调用存在每个栈中）"></a>三. 栈 （每个方法调用存在每个栈中）</h2><p>是Java方法执行的内存模型，栈中存放着栈帧，每个栈帧分别对应一个被调用的方法，方法的调用过程对应栈帧在虚拟机中入栈到出栈的过程。栈是线程私有的，也就是线程之间的栈是隔离的；当程序中某个线程开始执行一个方法时就会相应的创建一个栈帧并且入栈（位于栈顶），在方法结束后，栈帧出栈。</p><p>   <strong>栈帧:是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。</strong></p><div class="hljs"><pre><code>每个栈帧中包括：- 局部变量表:用来存储方法中的局部变量（非静态变量、函数形参）。当变量为基本数据类型时，直接存储值，当变量为引用类型时，存储的是指向具体对象的引用。- 操作数栈:Java虚拟机的解释执行引擎被称为&quot;基于栈的执行引擎&quot;，其中所指的栈就是指操作数栈。- 指向运行时常量池的引用:存储程序执行时可能用到常量的引用。- 方法返回地址:存储方法执行完成后的返回地址。![](/images/data_stack.png)</code></pre></div><h2 id="四-数据如何在内存中存储"><a href="#四-数据如何在内存中存储" class="headerlink" title="四. 数据如何在内存中存储"></a>四. 数据如何在内存中存储</h2><ol><li><p>基本数据类型的局部变量</p> <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">int a</span> = 10;<span class="hljs-attribute">a</span> = 20;</code></pre></div><p> 基本数据类型的数据本身是不会改变的，当局部变量重新赋值时，并不是在内存中改变字面量内容，而是重新在栈中寻找已存在的相同的数据，若栈中不存在，则重新开辟内存新数据，并且把要重新赋值的局部变量的引用指向新数据所在地址。</p></li><li><p>基本数据类型的成员变量 （对象里的变量叫成员变量）</p><p> 基本数据类型的成员变量名和值都存储于堆中，其生命周期和对象的是一致的。</p></li><li><p>基本数据类型的静态变量（static int a = 1）</p><p> 基本数据类型的静态变量名以及值存储于方法区的运行时常量池中，<strong>静态变量随类加载而加载，随类消失而消失。</strong></p></li><li><p>引用数据类型的存储</p> <div class="hljs"><pre><code class="hljs undefined">Person per;<span class="hljs-comment">//定义变量</span>per=<span class="hljs-keyword">new</span><span class="hljs-type"></span> Person();<span class="hljs-comment">//赋值</span></code></pre></div><p> 对于引用数据类型的对象/数组，变量名存在栈中，变量值存储的是对象的地址，并不是对象的实际内容。</p></li></ol><h2 id="五-值传递和引用传递"><a href="#五-值传递和引用传递" class="headerlink" title="五. 值传递和引用传递"></a>五. 值传递和引用传递</h2><ol><li><p>值传递：</p><p> 在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。</p> <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BioServer</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span>(<span class="hljs-params">String s1</span>)</span>&#123;    s1 = <span class="hljs-string">"2"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>) throws IOException</span> &#123;    String s1 = <span class="hljs-string">"1"</span>;    change(s1);    System.<span class="hljs-keyword">out</span>.println(s1);<span class="hljs-comment">// "1"</span>     &#125;</code></pre></div><p> 也就是说，s1的改动，只是改变了当前栈帧（change方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，mian方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。因此：值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</p></li></ol><ol start="2"><li><p>引用传递（分为2种）（见证java中不包含引用传递的时候到了）先定义一个类：</p> <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> age;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;</code></pre></div><p> 第一种，实参和形参的共同指向同一个内存地址的时候，。对形参的操作会影响的真实内容。</p> <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeAge</span>(<span class="hljs-params">Person person</span>)</span>&#123;        person.setAge(<span class="hljs-number">2</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        Person p = <span class="hljs-keyword">new</span> Person();        p.setAge(<span class="hljs-number">1</span>);        changeAge(p);        System.<span class="hljs-keyword">out</span>.println(p.getAge());        <span class="hljs-comment">// 输出结果为 2</span>    &#125;&#125;</code></pre></div><p> 从第一种情况看，特别像引用传递，但是那只是特殊情况。</p><p> 第二种，在形参内改变形参指向的内存地址。</p> <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeAge</span>(<span class="hljs-params">Person person</span>)</span>&#123;        <span class="hljs-comment">// 新增指向新的对象地址</span>        person = <span class="hljs-keyword">new</span> Person();        person.setAge(<span class="hljs-number">2</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        Person p = <span class="hljs-keyword">new</span> Person();        p.setAge(<span class="hljs-number">1</span>);        changeAge(p);        System.<span class="hljs-keyword">out</span>.println(p.getAge());        <span class="hljs-comment">// 输出结果为 1</span>    &#125;&#125;</code></pre></div><p> 对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系。</p></li></ol><p>总结：</p><ol><li>如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。</li><li>如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</li></ol>]]></content>
    
    
    <categories>
      
      <category>java基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>spring 框架</title>
    <link href="/2020/04/02/spring-%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/04/02/spring-%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="一、-Bean-生命周期"><a href="#一、-Bean-生命周期" class="headerlink" title="一、 Bean 生命周期"></a>一、 Bean 生命周期</h2><ol><li>Bean容器找到配置文件中的Spring Bean 的定义。</li><li>Bean容器利用Java Reflection API 创建一个Bean的实例。</li><li>如果涉及到一些属性值 利用set方法设置一些属性值。</li><li>如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字。</li><li>与上面的类似，如果实现了其他*Aware接口，就调用相应的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessBeforeInitialization()方法</li><li>如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。</li><li>如果Bean在配置文件中的定义包含init-method属性，执行指定的方法。</li><li>如果有和加载这个Bean的Spring容器相关的BeanPostProcessor对象，执行postProcessAfterInitialization()方法</li><li>当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。</li><li>当要销毁Bean的时候，如果Bean在配置文件中的定义包含destroy-method属性，执行指定的方法。</li></ol><p><img src="/images/bean.png" srcset="/img/loading.gif" alt></p><p>其实很多时候我们并不会真的去实现上面说描述的那些接口，那么下面我们就除去那些接口，针对bean的单例和非单例来描述下bean的生命周期：</p><ul><li>单例管理的对象</li></ul><div class="hljs"><pre><code class="hljs undefined">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">"ServiceImpl"</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">"cn.csdn.service.ServiceImpl"</span> <span class="hljs-attribute">lazy-init</span>=<span class="hljs-string">"true"</span>/&gt;</code></pre></div><p>如果想对所有的默认单例bean都应用延迟初始化，可以在根节点beans设置default-lazy-init属性为true，如下所示：</p><div class="hljs"><pre><code class="hljs undefined">&lt;beans <span class="hljs-keyword">default</span>-<span class="hljs-built_in">lazy</span>-<span class="hljs-keyword">init</span>=<span class="hljs-string">"true"</span> …&gt;</code></pre></div><p>默认情况下，Spring 在读取 xml 文件的时候，就会创建对象。在创建对象的时候先调用构造器，然后调用 init-method 属性值中所指定的方法。对象在被销毁的时候，会调用 destroy-method 属性值中所指定的方法（例如调用Container.destroy()方法的时候）。写一个测试类，代码如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LifeBean</span> &#123;    <span class="hljs-keyword">private</span> String name;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LifeBean</span>(<span class="hljs-params"></span>)</span>&#123;          System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"LifeBean()构造函数"</span>);      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>(<span class="hljs-params"></span>)</span> &#123;          <span class="hljs-keyword">return</span> name;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(<span class="hljs-params">String name</span>)</span> &#123;          System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"setName()"</span>);          <span class="hljs-keyword">this</span>.name = name;      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>(<span class="hljs-params"></span>)</span>&#123;          System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"this is init of lifeBean"</span>);      &#125;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span>(<span class="hljs-params"></span>)</span>&#123;          System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"this is destory of lifeBean "</span> + <span class="hljs-keyword">this</span>);      &#125;  &#125;</code></pre></div><p>life.xml配置如下：</p><div class="hljs"><pre><code class="hljs undefined">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">"life_singleton"</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">"com.bean.LifeBean"</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">"singleton"</span>             <span class="hljs-attribute">init-method</span>=<span class="hljs-string">"init"</span> <span class="hljs-attribute">destroy-method</span>=<span class="hljs-string">"destory"</span> <span class="hljs-attribute">lazy-init</span>=<span class="hljs-string">"true"</span>/&gt;</code></pre></div><p>测试代码：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LifeTest</span> </span>&#123;    @Test     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> test() &#123;        AbstractApplicationContext <span class="hljs-keyword">container</span> =         <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">"life.xml"</span>);        LifeBean life1 = (LifeBean)<span class="hljs-keyword">container</span>.getBean(<span class="hljs-string">"life"</span>);        System.out.println(life1);        <span class="hljs-keyword">container</span>.close();    &#125;&#125;</code></pre></div><p>运行结果：</p><div class="hljs"><pre><code class="hljs undefined">LifeBean()构造函数<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">init</span> of lifeBeancom.bean.<span class="hljs-symbol">LifeBean@</span><span class="hljs-number">573f</span>2bb1……<span class="hljs-keyword">this</span> <span class="hljs-keyword">is</span> destory of lifeBean com.bean.<span class="hljs-symbol">LifeBean@</span><span class="hljs-number">573f</span>2bb1</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法</title>
    <link href="/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    <url>/2020/03/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>程序 = 数据结构 + 算法。虽然有些夸张，但足以说明数据结构与算法的重要性。 主要介绍以下4点：</p><ol><li><p>从搜索树到 B+ 树，讲解与树有关的数据结构；</p></li><li><p>字符串匹配相关的题目；</p></li><li><p>算法面试经常考察的 TopK 问题；</p></li><li><p>算法题的几种常用解题方法。</p></li></ol><p><strong>大O推导法，对于算法来说，总的时间复杂度等于其中最大的时间复杂度。</strong><br><strong>数据结构知识点：</strong></p><p><img src="/images/data_structure.png" srcset="/img/loading.gif" alt></p><ol><li><p>队列和栈是经常用的数据结构。队列是先进先出，栈是后进后出。</p></li><li><p>表，包括很多种，有占用连续空间的数组、用指针链接的单向和双向链表，首尾相接的循环链表、以及散列表，也叫哈希表。 </p></li><li><p>图，在特定领域使用的比较多，例如路由算法中会经常使用到，图分为有向图、无向图及带权图，这部分需要掌握图的深度遍历和广度遍历算法，了解最短路径算法。</p></li><li><p>树的内容，树一般用作查找与排序的辅助结构，剩下两个部分都和树有关，一个是二叉树，一个是多叉树。</p><ul><li>多叉树包括 B 树族，有 B 树、B+ 树、B* 树，比较适合用来做文件检索；另外一个是字典树，适合进行字符串的多模匹配。</li><li>二叉树包括平衡二叉树、红黑树、哈夫曼树，以及堆，适合用于进行数据查找和排序。这部分需要了解二叉树的构建、插入、删除操作的实现，需要掌握二叉树的前序、中序、后序遍历。</li></ul></li></ol><p><strong>算法知识点:</strong></p><p><img src="/images/algorithm.png" srcset="/img/loading.gif" alt></p><ol><li>算法题的常用算法解题方法。</li><li>复杂度是衡量算法好坏的标准之一，我们需要掌握计算算法时间复杂度和空间复杂度的方法。计算时间复杂度的方法一般是找到执行次数最多的语句，然后计算语句执行次数的数量级，最后用大写 O 来表示结果。</li><li>常用的字符串匹配算法，了解不同算法的匹配思路。 </li><li>排序也是经常考察的知识点，排序算法分为插入、交换、选择、归并、基数五类，其中快速排序和堆排序考察的频率最高，要重点掌握，需要能够手写算法实现。</li><li>常用的查找算法，包括二分查找、二叉排序树、B树、Hash、BloomFilter等，需要了解它们的适用场景，例如二分查找适合小数量集内存查找，B树适合文件索引，Hash常数级的时间复杂度更适合对查找效率要求较高的场合，BloomFilter 适合对大数据集进行数据存在性过滤。</li></ol><h2 id="一、详解二叉搜索树"><a href="#一、详解二叉搜索树" class="headerlink" title="一、详解二叉搜索树"></a>一、详解二叉搜索树</h2><h4 id="1-二叉搜索树"><a href="#1-二叉搜索树" class="headerlink" title="1. 二叉搜索树"></a>1. 二叉搜索树</h4><p><img src="/images/two_tree.png" srcset="/img/loading.gif" alt><br>二叉树的查询时间复杂度是 log(N)，但是随着不断的插入、删除节点，二叉树的树高可能会不断变大，当一个二叉搜索树所有节点都只有左子树或者都只有右子树时，其查找性能就退化成线性的了。</p><h4 id="2-平衡二叉树"><a href="#2-平衡二叉树" class="headerlink" title="2. 平衡二叉树"></a>2. 平衡二叉树</h4><p>平衡二叉树可以解决上面这个问题，平衡二叉树保证每个节点左右子树的高度差的绝对值不超过1，例如AVL树。AVL树是严格的平衡二叉树，插入或删除数据时可能经常需要旋转来保持平衡，插入或删除数据时可能经常需要旋转来保持平衡，比较适合插入、删除比较少的场景。</p><h4 id="3-红黑树"><a href="#3-红黑树" class="headerlink" title="3. 红黑树"></a>3. 红黑树</h4><p> 红黑树是一种更加实用的非严格的平衡二叉树。红黑树更关注局部平衡而非整体平衡，确保没有一条路径会比其他路径长出 2 倍，所以是接近平衡的，但减少了许多不必要的旋转操作，更加实用。Java 8 的 HashMap 中就应用了红黑树来解决散列冲突时的查找问题。TreeMap 也是通过红黑树来保证有序性的。<br> 红黑树除了拥有二叉搜索树的特点外，还有以下规则，如下图所示。</p><p><img src="/images/red_black_tree.png" srcset="/img/loading.gif" alt></p><ul><li>每个节点不是红色就是黑色</li><li>根结点是黑色</li><li>每个叶子节点（NIL）都是黑色空节点</li><li>红色节点的两个子节点都是黑色的</li><li>任意节点到器叶节点的每条路径上，包含相同数量的黑色节点</li></ul><h4 id="4-B-树-（B-树）"><a href="#4-B-树-（B-树）" class="headerlink" title="4. B 树 （B- 树）"></a>4. B 树 （B- 树）</h4><p>一种多叉树，也叫多路搜索树。B 树中每个节点可以存储多个元素，非常适合用在文件索引上，可以有效减少磁盘 IO 次数。B 树中所有结点的最大子节点数称为 B 树的阶，如下图所示是一棵 3 阶 B 树，也叫 2-3 树。</p><p><img src="/images/b_tree.png" srcset="/img/loading.gif" alt></p><p>一个m阶B树有如下特点：</p><div class="hljs"><pre><code>- 非叶节点最多有m棵子树- 根节点最少有两个子树，非根、非叶子节点最少有m/2棵子树- 非叶子结点中保存的关键字个数，等于该节点子树个数−1，就是说一个节点如果有 3棵子树，那么其中必定包含 2 个关键字；（节点中的数字是关键字）- 非叶子节点中的关键字大小有序，如上图中左边的节点中 37、51 两个元素就是有序的；- 节点中每个关键字的左子树中的关键字都小于该关键字，右子树中的关键字都大于该关键字。如上图中关键字 51 的左子树有 42、49，都小于 51，右子树的节点有 59，大于51；- 所有叶节点都在同一层。</code></pre></div><p>B 树在查找时，从根结点开始，对结点内的有序的关键字序列进行二分查找，如果找到就结束，没有找到就进入查询关键字所属范围的子树进行查找，直到叶节点。B 树一般应用在文件系统。<strong>4 阶 B 树表示每个节点最多有 4 个子树、3 个关键字，最少有 2 个子树、一个关键字，超过关键字限制需要拆分</strong></p><h4 id="5-B-树"><a href="#5-B-树" class="headerlink" title="5. B+ 树"></a>5. B+ 树</h4><p><img src="/images/b+tree.png" srcset="/img/loading.gif" alt><br>B+ 树的定义与 B 树基本相同，除了下面这几个特点。</p><div class="hljs"><pre><code>- 节点中的关键字与子树数目相同，比如节点中有 3 个关键字，那么就有 3 棵子树；- 关键字对应的子树中的节点都大于或等于关键字，子树中包括关键字自身；- 所有关键字都出现在叶子节点中；- 所有叶子节点都有指向下一个叶子节点的指针。</code></pre></div><p>与 B 树不同，<strong>B+ 树在搜索时不会在非叶子节点命中，一定会查询到叶子节点；另外一个，叶子节点相当于数据存储层，保存关键字对应的数据，而非叶子节点只保存关键字和指向叶节点的指针，不保存关键字对应的数据，所以同样数量关键字的非叶节点，B+ 树比 B 树要小很多。</strong></p><p>B+ 树更适合索引系统，MySQL 数据库的索引就提供了 B+ 树实现。原因有三个：</p><div class="hljs"><pre><code>- 由于叶节点之间有指针相连，B+ 树更适合范围检索；- 由于非叶节点只保存关键字和指针，同样大小非叶节点，B+ 树可以容纳更多的关键字，可以降低树高，查询时磁盘读写代价更低；- B+ 树的查询效率比较稳定。任何关键字的查找必须走一条从根结点到叶子结点的路，所有关键字查询的路径长度相同，效率相当。</code></pre></div><p>还有一种 B* 树的变种，在 B+ 树的非叶节点上，也增加了指向同一层下一个非叶节点的指针。</p><h2 id="二、字符串匹配"><a href="#二、字符串匹配" class="headerlink" title="二、字符串匹配"></a>二、字符串匹配</h2><h4 id="1-字符串匹配问题"><a href="#1-字符串匹配问题" class="headerlink" title="1. 字符串匹配问题"></a>1. 字符串匹配问题</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> class Main &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> isMatch(<span class="hljs-keyword">String</span> <span class="hljs-built_in">str</span>)&#123;        <span class="hljs-keyword">HashMap</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>();        bucket.put(<span class="hljs-string">')'</span>,<span class="hljs-string">'('</span>);        bucket.put(<span class="hljs-string">']'</span>,<span class="hljs-string">'['</span>);        bucket.put(<span class="hljs-string">'&#125;'</span>,<span class="hljs-string">'&#123;'</span>);        Stack&lt;Character&gt; characterStack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-keyword">for</span>(Character cs : <span class="hljs-built_in">str</span>.toCharArray())&#123;            characterStack.empty();            <span class="hljs-keyword">if</span>(bucket.containsValue(cs))&#123;                characterStack.push(cs);            &#125;            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bucket.containsKey(cs))&#123;                System.out.<span class="hljs-built_in">println</span>(characterStack);                System.out.<span class="hljs-built_in">println</span>(cs);                <span class="hljs-keyword">if</span>(characterStack.empty()||characterStack.pop()!= bucket.<span class="hljs-built_in">get</span>(cs))&#123;                    <span class="hljs-keyword">return</span>  <span class="hljs-keyword">false</span>;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> characterStack.empty();    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args)    &#123;        <span class="hljs-keyword">String</span> content = <span class="hljs-string">"(我是中国人)"</span>;        System.out.<span class="hljs-built_in">println</span>(isMatch(content));    &#125;&#125;</code></pre></div><h2 id="三、-排序"><a href="#三、-排序" class="headerlink" title="三、 排序"></a>三、 排序</h2><h4 id="1-TopK-问题"><a href="#1-TopK-问题" class="headerlink" title="1.TopK 问题"></a>1.TopK 问题</h4><p>解决思路：用前k个数创建大小为k的根堆，剩余N-K个数组和堆顶进行比较</p><p><strong>对于n个数，取Top k个数，时间复杂度为O(nlogk)，这样在n较大情况下，是优于nlogn的时间复杂度的。</strong></p><div class="hljs"><pre><code class="hljs undefined">package com.company;<span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopK</span>&lt;E extends Comparable&gt; &#123;</span>    <span class="hljs-keyword">private</span> PriorityQueue&lt;E&gt; <span class="hljs-built_in">queue</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxSize; <span class="hljs-comment">//堆的最大容量</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TopK</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxSize)</span> </span>&#123;        <span class="hljs-keyword">if</span> (maxSize &lt;= <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();        &#125;        <span class="hljs-keyword">this</span>.maxSize = maxSize;        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(maxSize, <span class="hljs-keyword">new</span> Comparator&lt;E&gt;() &#123;            @Override            <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> compare(E o1, E o2) &#123;                <span class="hljs-comment">// 最大堆用o2 - o1，最小堆用o1 - o2</span>                <span class="hljs-keyword">return</span> (o1.compareTo(o2));            &#125;        &#125;);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">queue</span>.size() &lt; maxSize) &#123;            <span class="hljs-built_in">queue</span>.add(e);        &#125; <span class="hljs-keyword">else</span> &#123;            E peek = <span class="hljs-built_in">queue</span>.peek();            <span class="hljs-keyword">if</span> (e.compareTo(peek) &gt; <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">queue</span>.poll();                <span class="hljs-built_in">queue</span>.add(e);            &#125;        &#125;    &#125;    <span class="hljs-keyword">public</span> List&lt;E&gt; sortedList() &#123;        List&lt;E&gt; <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-built_in">queue</span>);        Collections.sort(<span class="hljs-built_in">list</span>);        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span>[] <span class="hljs-built_in">array</span> = &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">8</span>&#125;;        TopK pq = <span class="hljs-keyword">new</span> TopK(<span class="hljs-number">4</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : <span class="hljs-built_in">array</span>) &#123;            pq.add(n);        &#125;        System.out.println(pq.sortedList());    &#125;&#125;</code></pre></div><h4 id="2-TopK-变种问题"><a href="#2-TopK-变种问题" class="headerlink" title="2. TopK 变种问题"></a>2. TopK 变种问题</h4><p>TopK 变种的问题，就是从 N 个有序队列中，找到最小或者最大的 K 个值。这个问题的不同点在于，是对多个数据集进行排序。由于初始的数据集是有序的，因此不需要遍历完 N 个队列中所有的元素。因此，解题思路是如何减少要遍历的元素。<br><img src="/images/topkb.png" srcset="/img/loading.gif" alt></p><h2 id="三、常用算法"><a href="#三、常用算法" class="headerlink" title="三、常用算法"></a>三、常用算法</h2><h4 id="1-分治法"><a href="#1-分治法" class="headerlink" title="1. 分治法"></a>1. 分治法</h4><p>分治法的思想是将一个难以直接解决的复杂问题或者大问题，分割成一些规模较小的相同问题，分而治之。比如快速排序、归并排序等都是应用了分治法。</p><p><img src="/images/fz.png" srcset="/img/loading.gif" alt></p><h4 id="2-动态规划法"><a href="#2-动态规划法" class="headerlink" title="2. 动态规划法"></a>2. 动态规划法</h4><p>动态规划法，与分治法类似，也是将问题分解为多个子问题。与分治法不同的是，子问题的解之间是有关联的。前一子问题的解，为后一子问题的求解提供了有用的信息。动态规划法依次解决各子问题，在求解每一个子问题时，列出所有局部解，通过决策保留那些有可能达到全局最优的局部解。最后一个子问题的解就是初始问题的解。</p><h4 id="4-贪心算法"><a href="#4-贪心算法" class="headerlink" title="4. 贪心算法"></a>4. 贪心算法</h4><p>第三个贪心算法，因为它考虑的是局部的最优解，所以贪心算法不是对所有问题都能得到整体最优解。贪心算法的关键是贪心策略的选择。贪心策略必须具备无后效性，就是说某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java JVM</title>
    <link href="/2020/03/30/Java-JVM/"/>
    <url>/2020/03/30/Java-JVM/</url>
    
    <content type="html"><![CDATA[<p>JVM 是Java 程序运行的基础。例如 JVM 内存模型、Java 的类加载机制、常用的 GC 算法。<br><img src="/images/jvm.png" srcset="/img/loading.gif" alt></p><h2 id="一、-JVM-内存模型"><a href="#一、-JVM-内存模型" class="headerlink" title="一、 JVM 内存模型"></a>一、 JVM 内存模型</h2><p><img src="/images/jvm_ram.png" srcset="/img/loading.gif" alt></p><ul><li>栈：也是方法栈，线程私有，用来存储局部变量表、操作栈、动态链接、方法出口等信息。</li><li>本地方法栈 ：和栈类似，也是用来保存线程执行方法时的信息，不同的是，执行 Java 方法使用栈，而执行 native 方法使用本地方法栈。 </li><li>程序计数器 ： 保存着当前线程所执行的字节码位置，每个线程工作时都有一个独立的计数器。程序计数器为执行 Java 方法服务，执行 native 方法时，程序计数器为空。 </li></ul><p><strong>栈、本地方法栈、程序计数器这三个部分都是线程独占的。</strong></p><ul><li><p>堆 ：被所有线程共享，存放实例对象，没有可用空间时候会抛出OOM异常。根据对象存活的周期不同，JVM 把堆内存进行分代管理，由垃圾回收器来进行对象的回收管理。 </p></li><li><p>方法区 ： 各个线程共享的内存区域，又叫非堆区。用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，<strong>JDK1.7中的永久代和JDK1.8中的Metaspace都是方法区的一种实现。</strong></p></li></ul><h2 id="二、-JMM-详解"><a href="#二、-JMM-详解" class="headerlink" title="二、 JMM 详解"></a>二、 JMM 详解</h2><p>JMM 是Java 内存模型，如下图所示，所有的共享变量都存储在主内存中共享。每个线程有自己的工作内存，工作内存中保存的是主内存中变量的副本，线程对变量的读写等操作必须在自己的工作内存中进行，而不能直接读写主内存中的变量。<br><img src="/images/jmm.png" srcset="/img/loading.gif" alt></p><p>在多线程进行数据交互时，例如线程 A 给一个共享变量赋值后，由线程 B 来读取这个值，A 修改完变量是修改在自己的工作区内存中，B 是不可见的，只有从 A 的工作区写回主内存，B 再从主内存读取自己的工作区才能进行进一步的操作。由于指令重排序的存在，这个写—读的顺序有可能被打乱。因此 JMM 需要提供原子性、可见性、有序性的保证。</p><h4 id="1-JMM-保证原子性、可见性，有序性"><a href="#1-JMM-保证原子性、可见性，有序性" class="headerlink" title="1. JMM 保证原子性、可见性，有序性"></a>1. JMM 保证原子性、可见性，有序性</h4><p><img src="/images/jmm_ensure.png" srcset="/img/loading.gif" alt></p><ul><li>原子性</li></ul><div class="hljs"><pre><code>JMM 保证对除long和double外的基础数据类型读写操作的原子性。（long 、 double 是 占 64位 所以在32位操作系统里会分开写入，高位32位，低位32位。 所以保证原子性要添加 volatile 关键字 ）。另外关键字 synchronized 也可以提供原子性保证。synchronized 的原子性是通过 Java 的两个高级的字节码指令 monitorenter 和 monitorexit 来保证的。 </code></pre></div><ul><li><p>可见性 </p><p>  JMM可见性的保证，一个是通过synchronized，另外一个就是volatile。volatile强制变量的赋值会同步刷新回主内存，强制变量的读取会从主内存重新加载，保证不同的线程总是能够看到该变量的最新值。 </p></li><li><p>有序性</p><p>  对有序性的保证，主要通过 volatile 和一系列 happens-before 原则。volatile 的另一个作用就是阻止指令重排序，这样就可以保证变量读写的有序性。</p><p>  happens-before原则包括一系列规则，如：</p><ul><li>程序顺序原则，即一个线程内必须保证语义串行性；</li><li>锁规则，即对同一个锁的解锁一定发生在再次加锁之前；</li><li>happens-before 原则的传递性、线程启动、中断、终止规则等。</li></ul><p>  <strong>happen-before 原则是 JMM 的核心所在，只有满足了 hb 原则才能保证有序性和可见性，否则编译器将会对代码重排序。hb 甚至将 lock 和 volatile 也定义了规则。通过适当的对 hb 规则的组合，可以实现对普通共享变量的正确使用</strong></p></li></ul><h2 id="三、-类加载机制"><a href="#三、-类加载机制" class="headerlink" title="三、 类加载机制"></a>三、 类加载机制</h2><p>类的加载指将编译好的 Class 类文件中的字节码读入内存中，将其放在方法区内并创建对应的 Class 对象。类的加载分为加载、链接、初始化，其中链接又包括验证、准备、解析三步。如下图所示。</p><h4 id="加载流程"><a href="#加载流程" class="headerlink" title="加载流程"></a>加载流程</h4><p> <img src="/images/jvm_class_loader.png" srcset="/img/loading.gif" alt></p> <ol style=" white-space: normal;"> <li><p style="text-align: justify; line-height: 1.75em;"><span style="font-family: &quot;Microsoft YaHei&quot;, sans-serif; color: rgb(63, 63, 63);">加载是文件到内存的过程。通过类的完全限定名查找此类字节码文件，并利用字节码文件创建一个 Class 对象。</span></p></li> <li><p style="text-align: justify; line-height: 1.75em;"><span style="font-family: &quot;Microsoft YaHei&quot;, sans-serif; color: rgb(63, 63, 63);">验证是对类文件内容验证。目的在于确保 Class 文件符合当前虚拟机要求，不会危害虚拟机自身安全。主要包括四种：文件格式验证，元数据验证，字节码验证，符号引用验证。</span></p></li> <li><p style="text-align: justify; line-height: 1.75em;"><span style="font-family: &quot;Microsoft YaHei&quot;, sans-serif; color: rgb(63, 63, 63);">准备阶段是进行内存分配。为类变量也就是类中由 static 修饰的变量分配内存，并且设置初始值。这里要注意，初始值是 0 或者&nbsp;null，而不是代码中设置的具体值，代码中设置的值是在初始化阶段完成的。另外这里也不包含用 final 修饰的静态变量，因为 final 在编译的时候就会分配。</span></p></li> <li><p style="text-align: justify; line-height: 1.75em;"><span style="font-family: &quot;Microsoft YaHei&quot;, sans-serif; color: rgb(63, 63, 63);">解析主要是解析字段、接口、方法。主要是将常量池中的符号引用替换为直接引用的过程。直接引用就是直接指向目标的指针、相对偏移量等。</span></p></li> <li><p style="text-align: justify; line-height: 1.75em;"><span style="font-family: &quot;Microsoft YaHei&quot;, sans-serif; color: rgb(63, 63, 63);">初始化，主要完成静态块执行与静态变量的赋值。这是类加载最后阶段，若被加载类的父类没有初始化，则先对父类进行初始化。</span></p></li></ol><p>只有对类主动使用时，才会进行初始化，初始化的触发条件包括在创建类的实例时、访问类的静态方法或者静态变量时、Class.forName() 反射类时、或者某个子类被初始化时。 </p><p>如上图所示，浅绿的两个部分表示类的生命周期，就是从类的加载到类实例的创建与使用，再到类对象不再被使用时可以被 GC 卸载回收。这里要注意一点，由 Java 虚拟机自带的三种类加载器加载的类在虚拟机的整个生命周期中是不会被卸载的，只有用户自定义的类加载器所加载的类才可以被卸载。</p><p><strong>符号引用 在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。</strong></p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><p><img src="/images/class_loader.png" srcset="/img/loading.gif" alt></p><p>如上图所示，浅绿的两个部分表示类的生命周期，就是从类的加载到类实例的创建与使用，再到类对象不再被使用时可以被 GC 卸载回收。这里要注意一点，由 Java 虚拟机自带的三种类加载器加载的类在虚拟机的整个生命周期中是不会被卸载的，只有用户自定义的类加载器所加载的类才可以被卸载。</p><p>Java 的类加载使用双亲委派模式，即一个类加载器在加载类时，先把这个请求委托给自己的父类加载器去执行，如果父类加载器还存在父类加载器，就继续向上委托，直到顶层的启动类加载器，如上图中蓝色向上的箭头。如果父类加载器能够完成类加载，就成功返回，如果父类加载器无法完成加载，那么子加载器才会尝试自己去加载。如图中的桔黄色向下的箭头。</p><p>这种双亲委派模式的好处，可以避免类的重复加载，另外也避免了 Java 的核心 API 被篡改。</p><h2 id="四、分代回收"><a href="#四、分代回收" class="headerlink" title="四、分代回收"></a>四、分代回收</h2><h4 id="1-分代划分"><a href="#1-分代划分" class="headerlink" title="1. 分代划分"></a>1. 分代划分</h4><p>Java 的堆内存被分代管理，为什么要分代管理呢？分代管理主要是为了方便垃圾回收，这样做基于2个事实，第一，大部分对象很快就不再使用；第二，还有一部分不会立即无用，但也不会持续很长时间。虚拟机划分为年轻代、老年代、和永久代，如下图所示。</p><p> <img src="/images/jvm_old_young.png" srcset="/img/loading.gif" alt></p><ul><li><p>年轻代 ：主要存放新创建的对象，分为Eden 区和 两个 Servivor 区。 大部分对象在 Eden 区中生成。当 Eden 区满时，还存活的对象会在两个 Survivor 区交替保存，达到一定次数的对象会晋升到老年代。 </p></li><li><p>老年代 ： 用来存放从年轻代晋升而来的，存活时间较长的对象。</p></li><li><p>永久代 ： 主要保存类信息等内容，这里的永久代是指对象划分方式，不是专指 1.7 的 PermGen，或者 1.8 之后的 Metaspace。 </p></li></ul><p>根据年轻代与老年代的特点，JVM 提供了不同的垃圾回收算法。垃圾回收算法按类型可以分为引用计数法、复制法和标记清除法。 </p><ul><li>引用计数法 ：通过对象被引用的次数来确定对象是否被使用，缺点是无法解决循环引用的问题。</li><li>复制算法 ： 需要 from 和 to 两块相同大小的内存空间，对象分配时只在 from 块中进行，回收时把存活对象复制到 to 块中，并清空 from 块，然后交换两块的分工，即把from 块作为 to 块，把 to 块作为 from 块。缺点是内存使用率较低。 </li></ul><p>JVM 中提供的年轻代回收算法 Serial、ParNew、Parallel Scavenge 都是复制算法，而 CMS、G1、ZGC 都属于标记清除算法。</p><h4 id="2-回收算法"><a href="#2-回收算法" class="headerlink" title="2. 回收算法"></a>2. 回收算法</h4><ul><li><p>CMS算法</p><p>  CMS 在 JDK1.7 之前可以说是最主流的垃圾回收算法。CMS 使用标记清除算法，优点是并发收集，停顿小。</p><p>  <img src="/images/jvm_cms.png" srcset="/img/loading.gif" alt></p><p>  在java语言中，可作为GC Root的对象包括以下几种对象：<br>  a.java虚拟机栈(栈帧中的本地变量表)中的引用的对象。<br>  b.方法区中的类静态属性引用的对象。<br>  c.方法区中的常量引用的对象。<br>  d.本地方法栈中JNI本地方法的引用对象。</p><ul><li>第一个阶段是初始标记，这个阶段会 stop the world，标记的对象只是从 root 集最直接可达的对象； </li><li>第二阶段是并发标记，这时 GC 线程和应用线程并发执行。主要是标记可达的对象；</li><li>第三个阶段是重新标记阶段，这个阶段是第二个 stop the world 的阶段，停顿时间比并发标记要小很多，但比初始标记稍长，主要对对象进行重新扫描并标记； </li><li>第四个阶段是并发清理阶段，进行并发的垃圾清理；</li><li>最后一个阶段是并发重置阶段，为下一次 GC 重置相关数据结构。 </li></ul></li><li><p>G1算法</p><p>  <img src="/images/jvm_g1.png" srcset="/img/loading.gif" alt><br>  G1 也和 CMS 一样会遍历全部的对象，然后标记对象引用情况，在清除对象后会对区域进行复制移动整合碎片空间。</p><p>  G1回收过程如下。G1的年轻代回收，采用复制算法，并行进行收集，收集过程会STW。G1的老年代回收时也同时会对年轻代进行回收。主要分为四个阶段：<br>  a. 依然是初始标记阶段完成对根对象的标记，这个过程是STW的；<br>  b. 并发标记阶段，这个阶段是和用户线程并行执行的；<br>  c. 最终标记阶段，完成三色标记周期；复制/清除阶段，这个阶段会优先对可回收空间较大的Region 进行回收，即 garbage first，这也是 G1 名称的由来。 </p><p>  G1采用每次只清理一部分而不是全部的Region的增量式清理，由此来保证每次GC停顿时间不会过长。总结如下，G1是逻辑分代不是物理划分，需要知道回收的过程和停顿的阶段。此外还需要知道，G1算法允许通过JVM参数设置Region的大小，范围是1～32MB，可以设置期望的最大GC停顿时间等。有兴趣读者也可以对CMS和G1使用的三色标记算法做简单了解。 </p><p>  <strong>STW(stop the world) 是等待所有用户线程进入安全点后并阻塞，做一些全局性操作的行为。</strong></p></li></ul><ul><li><p>ZGC算法</p><p>  ZGC是最新的JDK1.11版本中提供的高效垃圾回收算法，ZGC针对大堆内存设计可以支持TB级别的堆，ZGC非常高效，能够做到10ms以下的回收停顿时间。这么快的响应，ZGC 是如何做到的呢？这是由于 ZGC 具有以下特点。</p><ol><li>ZGC 使用了着色指针技术，我们知道 64 位平台上，一个指针的可用位是 64 位，ZGC 限制最大支持 4TB 的堆，这样寻址只需要使用 42 位，那么剩下 22 位就可以用来保存额外的信息，着色指针技术就是利用指针的额外信息位，在指针上对对象做着色标记。</li><li>第二个特点是使用读屏障，ZGC 使用读屏障来解决 GC 线程和应用线程可能并发修改对象状态的问题，而不是简单粗暴的通过 STW 来进行全局的锁定。使用读屏障只会在单个对象的处理上有概率被减速。</li><li>由于读屏障的作用，进行垃圾回收的大部分时候都是不需要 STW 的，因此 ZGC 的大部分时间都是并发处理，也就是 ZGC 的第三个特点。</li><li>第四个特点是基于 Region，这与 G1 算法一样，不过虽然也分了 Region，但是并没有进行分代。ZGC 的 Region 不像 G1 那样是固定大小，而是动态地决定 Region 的大小，Region 可以动态创建和销毁。这样可以更好的对大对象进行分配管理。</li><li>第五个特点是压缩整理。CMS 算法清理对象时原地回收，会存在内存碎片问题。ZGC 和 G1 一样，也会在回收后对 Region 中的对象进行移动合并，解决了碎片问题。</li></ol></li></ul><ul><li><p>ZGC回收过程</p><p>  <img src="/images/jvm_zgc.png" srcset="/img/loading.gif" alt><br>  开始进行回收时，ZGC 首先会进行一个短暂的 STW，来进行 roots 标记。这个步骤非常短，因为 roots 的总数通常比较小。</p><p>  然后就开始进行并发标记，如上图所示，通过对对象指针进行着色来进行标记，结合读屏障解决单个对象的并发问题。其实，这个阶段在最后还是会有一个非常短的 STW 停顿，用来处理一些边缘情况，这个阶段绝大部分时间是并发进行的，所以没有明显标出这个停顿。</p><p>  下一个是清理阶段，这个阶段会把标记为不在使用的对象进行回收，如上图所示，把橘色的不在使用的对象进行了回收。</p><p>  最后一个阶段是重定位，重定位就是对 GC 后存活的对象进行移动，来释放大块的内存空间，解决碎片问题。<br>  重定位最开始会有一个短暂的STW，用来重定位集合中的root对象。暂停时间取决于root的数量、重定位集与对象的总活动集的比率。最后是并发重定位，这个过程也是通过读屏障，与应用线程并发进行的。</p></li></ul><ul><li><p>科普内存碎片</p><p>  Java 中的内存碎片可以理解为外部碎片，因为标记-清除算法只负责将标记的需要回收的内存给回收，对于一块内存，会留下很多小的空的位置，但是这些位置不足以去申请一个连续的对象。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程与并发</title>
    <link href="/2020/03/26/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <url>/2020/03/26/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/thread.png" srcset="/img/loading.gif" alt></p><h2 id="一、-线程状态转换"><a href="#一、-线程状态转换" class="headerlink" title="一、 线程状态转换"></a>一、 线程状态转换</h2><p>线程是JVM 执行任务的最小单元，在JVM 运行中，线程一共有 NEW、RUNNABLE、BLOCKED、WATING、TIMED_WATIING、TERMINATED</p><p><img src="/images/threadstatus.png" srcset="/img/loading.gif" alt></p><h2 id="二、-线程同步与互斥（-CAS-ABA-synchronized-）"><a href="#二、-线程同步与互斥（-CAS-ABA-synchronized-）" class="headerlink" title="二、 线程同步与互斥（ CAS  ABA synchronized ）"></a>二、 线程同步与互斥（ CAS  ABA synchronized ）</h2><p>解决互斥主要是CAS、synchronized、lock。</p><h4 id="1-CAS"><a href="#1-CAS" class="headerlink" title="1. CAS"></a>1. CAS</h4><p>CAS是一种轻量级锁 JUC（即 java.util.concurrent 包，是JDK的核心工具包） 中很多 工具类实现就是基于CAS。<strong>比较并写回的操作是通过操作系统语言实现的，保证执行过程不会被中断。</strong> 操作流程如下：</p><p><img src="/images/CAS.png" srcset="/img/loading.gif" alt></p><h4 id="2-ABA"><a href="#2-ABA" class="headerlink" title="2.  ABA"></a>2.  ABA</h4><p>CAS出现ABA问题，如果线程1读取A之后发生了2次写入，线程2写入B，线程3写回 A ，使得线程1判断值是否改变时候并没有发生变化。因此就无法判断是否发生过。 ABA虽然不会影响结果但是还是要防范，防止出现问题都不知道谁操作的。记录还是要有的，解决办法就是像mysql 乐观锁一样 添加version 标记或时间戳。JUC 提供了 AtomicStampedReference类。</p><h4 id="3-synchronized"><a href="#3-synchronized" class="headerlink" title="3. synchronized"></a>3. synchronized</h4><ul><li>如何保证同一时刻只有一个线程可以进入临界区？</li></ul><p>同步方法，JVM使用ACC_SYNCHRONIZED标识来实现。同步方法是隐式的。一个同步方法会在运行时常量池中的method_info结构体中存放ACC_SYNCHRONIZED标识符。当一个线程访问方法时，会去检查是否存在ACC_SYNCHRONIZED标识，如果存在，则先要获得对应的monitor锁，然后执行方法。当方法执行结束(不管是正常return还是抛出异常)都会释放对应的monitor锁。如果此时有其他线程也想要访问这个方法时，会因得不到monitor锁而阻塞。当同步方法中抛出异常且方法内没有捕获，则在向外抛出时会先释放已获得的monitor锁.</p><p>同步代码块，JVM使用monitorenter和monitorexit两个指令实现同步。即JVM为代码块的前后真正生成了两个字节码指令来实现同步功能的。每个对象都会与一个monitor相关联，当某个monitor被拥有之后就会被锁住，当线程执行到monitorenter指令时，就会去尝试获得对应的monitor。步骤如下：每个monitor维护着一个记录着拥有次数的计数器。未被拥有的monitor的该计数器为0，当一个线程获得monitor（执行monitorenter）后，该计数器自增变为 1 当同一个线程再次获得该monitor的时候，计数器再次自增；当不同线程想要获得该monitor的时候，就会被阻塞。当同一个线程释放 monitor（执行monitorexit指令）的时候，计数器再自减。当计数器为0的时候。monitor将被释放，其他线程便可以获得monitor。</p><p>补充了解几个知识点：</p><ul><li><p>java 在内存布局分为三大块：</p><ul><li>对象头（Header）包含锁状态标识和monitor对象起始地址（Monitor其实是一种同步工具，类似对象内部锁）</li><li>实例数据</li><li>对象填充</li></ul></li><li><p>monitor 简单地说监视器就是一个概念，任何语言都可以实现。目的就是为了简化同步调用的过程。在Java中是ObjectMonitor(JVM源码中C++实现)来实现管程。管程封装了同步操作，对进程隐蔽了同步细节，简化了同步功能的调用界面。</p><ul><li>_count：记录owner线程获取锁的次数。这句话很好理解，这也决定了synchronized是可重入的。</li><li>_owner：指向拥有该对象的线程。</li><li>_WaitSet：存放处于wait状态的线程集合。</li><li>_EntryList：存放等待锁而被block的线程队列。<div class="hljs"><pre><code class="hljs undefined">synchronized(<span class="hljs-keyword">this</span>)&#123; <span class="hljs-comment">// 进入 EntryList</span>    <span class="hljs-keyword">this</span>.wait();<span class="hljs-comment">//进入 WaitSet</span>    &#125;</code></pre></div></li></ul></li></ul><ul><li>锁升级</li></ul><p>java 1.6后针对synchronized获取， JVM采用了锁升级优化方式，先是无竞争采用无锁，然后采用偏向锁，比较当前线程的threadID和Java对象头中的threadID是否一致，如果一致（还是线程1获取锁对象），则无需使用CAS来加锁、解锁；如果不一致（其他线程，如线程2要竞争锁对象，而偏向锁不会主动释放因此还是存储的线程1的threadID），那么需要查看Java对象头中记录的线程1是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程（线程2）可以竞争将其设置为偏向锁；如果存活，那么立刻查找该线程（线程1）的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程1，撤销偏向锁，升级为轻量级锁，如果线程1 不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。</p><ul><li>为什么要引入轻量级锁？</li></ul><p>轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。因为阻塞线程需要CPU从用户态转到内核态，代价较大，如果刚刚阻塞不久这个锁就被释放了，那这个代价就有点得不偿失了，因此这个时候就干脆不阻塞这个线程，让它自旋这等待锁释放。</p><p> <strong>注意：为了避免无用的自旋，轻量级锁一旦膨胀为重量级锁就不会再降级为轻量级锁了；偏向锁升级为轻量级锁也不能再降级为偏向锁。一句话就是锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。</strong></p><ul><li><p>锁粗化<br>按理来说，同步块的作用范围应该尽可能小，仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，缩短阻塞时间，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>但是加锁解锁也需要消耗资源，如果存在一系列的连续加锁解锁操作，可能会导致不必要的性能损耗。<br>锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁，避免频繁的加锁解锁操作。</p></li><li><p>锁消除<br>Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，经过逃逸分析，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间</p></li></ul><p>引用 ：<a href="https://blog.csdn.net/tongdanping/article/details/79647337" target="_blank" rel="noopener">https://blog.csdn.net/tongdanping/article/details/79647337</a></p><h4 id="4-AQS-与-Lock"><a href="#4-AQS-与-Lock" class="headerlink" title="4. AQS 与 Lock"></a>4. AQS 与 Lock</h4><p>AbstractQueuedSynchronized 队列同步器，是实现Lock的基础。<br>下图就是 AQS 的结构图，从图中可以看出，AQS 有一个 state 标记位，值为1  时表示有线程占用，其他线程需要进入到同步队列等待。同步队列是一个双向链表。<br><img src="/images/AQS.png" srcset="/img/loading.gif" alt></p><p>当获得锁的线程需要等待某个条件时，如wait，会进入condition的等待队列。等待队列可以有多个。当condition条件满足时，线程会从等待队列重写进入同步队列获取锁的竞争，ReentrantLock 就是基于AQS实现的。如下图所示，ReentrantLock 内部有公平锁和非公平锁两种实现，差别就在于新来的线程是否比已经在同步队列中的等待线程更早获得锁。</p><ul><li>FairSync 实现原理</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;    setExclusiveOwnerThread(current);    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;</code></pre></div><p>其中hasQueuedPredecessors是用于检查是否有等待队列的。</p><div class="hljs"><pre><code class="hljs undefined">public final boolean hasQueuedPredecessors() &#123;       <span class="hljs-keyword">Node</span> <span class="hljs-title">t</span> = tail; // <span class="hljs-keyword">Read</span> fields <span class="hljs-keyword">in</span> reverse initialization <span class="hljs-keyword">order</span>       <span class="hljs-title">Node</span> h = head;       <span class="hljs-keyword">Node</span> <span class="hljs-title">s</span>;       return h != t &amp;&amp;           ((s = h.next) == null || s.thread != Thread.currentThread());   &#125;</code></pre></div><ul><li>NonFairSync </li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">compareAndSetState</span>(<span class="hljs-number">0</span>, acquires)) &#123;        <span class="hljs-built_in">setExclusiveOwnerThread</span>(current);        <span class="hljs-keyword">return</span> true;    &#125;&#125;</code></pre></div><p><strong>公平锁每次会检测又没有等待队列的，而非公平锁多次强调随机抢占，不会检测是否有等待队列。如果被加入等待队列，公平锁和非公平锁没有区别。</strong></p><h2 id="三、线程池"><a href="#三、线程池" class="headerlink" title="三、线程池"></a>三、线程池</h2><p>线程池通过复用线程，避免频繁的创建和销毁。Java 的Executors 工具类中提供了5中类型的线程池创造方法，如下图所示，来看它们的特点和适用场景。</p><p> <img src="/images/thread_pool.png" srcset="/img/loading.gif" alt></p><h4 id="1-线程池参数"><a href="#1-线程池参数" class="headerlink" title="1. 线程池参数"></a>1. 线程池参数</h4><p> <img src="/images/threadpoolargs.png" srcset="/img/loading.gif" alt></p><ul><li><p>corePoolSize : 核心线程数，一直存活。</p></li><li><p>maximumPoolSize : 最多可创建的线程数。</p></li><li><p>keepAliveTime :   线程闲置超过设置时间会被销毁，可以通过 allowCoreThreadTimeOut 方法来允许核心线程被回收。</p></li><li><p>unit : keepAliveTime的时间单位</p></li><li><p>workQueue : 缓冲队列</p><ul><li>ArrayBlockingQueue 有届队列，是指队列有最大容量限制。</li><li>LinkedBlockingQueue 无界队列，队列不限制容量。</li><li>SynchronousQueue 同步队列 内部设有缓冲区。</li></ul></li><li><p>threadFactory 线程工厂创建新线程，可以用来对线程的一些属性形象定制，例如线程的group、线程名、优先级等。一般默认工厂即可。</p></li><li><p>设置拒绝策略 Abort 线程满后抛出异常 Discard 直接丢弃 CallerRuns 直接执行提交的任务。 DiscardOldest 丢弃最早的策略。</p></li></ul><h4 id="2-各种线程池都需要用哪几种参数"><a href="#2-各种线程池都需要用哪几种参数" class="headerlink" title="2. 各种线程池都需要用哪几种参数"></a>2. 各种线程池都需要用哪几种参数</h4><ul><li>固定大小线程池创建时核心和最大线程数都设置成指定的线程数，这样线程池中就只会使用固定大小的线程数。</li><li>队列使用无界队列LinkedBlockingQueue。</li><li>Single线程池就是线程数设置为1 的固定线程池。</li><li>Cached线程池的核心线程数设置为0，最大线程数是Integer.MAX_VALUE，主要是通过把缓冲队列设置成SynchronousQueue，这样只要没有空闲线程就会新建。</li><li>Scheduled 线程池与前几种不同的是使用了 DelayedWorkQueue，这是一种按延迟时间获取任务的优先级队列。</li></ul><h4 id="3-执行流程"><a href="#3-执行流程" class="headerlink" title="3. 执行流程"></a>3. 执行流程</h4><p> <img src="/images/threadpoolprocess.png" srcset="/img/loading.gif" alt></p><p> 注意队列的判断与最大线程数判断的顺序</p><h2 id="四、-JUC-工具类"><a href="#四、-JUC-工具类" class="headerlink" title="四、 JUC 工具类"></a>四、 JUC 工具类</h2><p><img src="/images/juc1.png" srcset="/img/loading.gif" alt><br><img src="/images/juc2.png" srcset="/img/loading.gif" alt><br><img src="/images/juc3.png" srcset="/img/loading.gif" alt></p><p>CopyOnWriteArrayList，COW 通过写入数据时进行 copy 修改，然后更新引用的方式，来消除并行读写中的锁使用，比较适合读多写少，数据量比较小，但是并发非常高的场景。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ol><li><p>synchronized实现同步原理是对象头中的monitor 同步机制，对同步方法和代码块有不同的操作流程，原理都是通过 C++封装的objectmonitor 机制。</p></li><li><p>线程同步互斥原理，每个进程中访问临界资源的那段代码称为临界区，临界资源是一次仅允许一个进程使用的共享资源。重量级锁、轻量级锁、自旋锁、偏向锁、重入锁、读写锁。重量锁会触发用户态到内核态的转换，性能查。</p></li><li><p>JUC 应用 Reentrantlock，ConcurrentHashMap、LongAdder 等实现方式。 AtomicStampedReference 和 AtomicMarkableReference 用于解决前面提到的 ABA 问题，分别基于时间戳和标记位来解决问题。 <strong>Semaphore 是计数信号量，可以用做流量控制。可控制共享资源的访问数量。</strong></p></li><li><p>ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。Entry采用 WeakReference ，保存不同的ThreadLocal变量。</p></li><li><p>程池的原理、使用场景、常用配置，例如大量短期任务的场景适合使用 Cached 线程池；系统资源比较紧张时，可以选择固定线程池。另外注意慎用无界队列，可能会有 OOM 的风险。</p></li><li><p>线程的同步与异步、阻塞与非阻塞，同步和异步的区别在于任务是否是同一个线程执行，阻塞与非阻塞的区别在于异步执行任务时，线程是会阻塞等待结果，还是会继续执行后续逻辑。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 语言特性</title>
    <link href="/2020/03/25/Java-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
    <url>/2020/03/25/Java-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/java.png" srcset="/img/loading.gif" alt></p><h2 id="1-Java-1-8-新特性"><a href="#1-Java-1-8-新特性" class="headerlink" title="1. Java 1.8 新特性"></a>1. Java 1.8 新特性</h2><ul><li><p>Lambda 表达式 编写更加简洁，可执行默认重写的runnable方法。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(()-&gt;&#123;System.out.println(<span class="hljs-string">"2"</span>);&#125;)</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span></code></pre></div></li><li><p>Stream 流式处理的 API。例如把集合转换成流式数据，进行类sql语句的执行方式。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-built_in">Random</span> <span class="hljs-built_in">random</span> = new <span class="hljs-built_in">Random</span>()<span class="hljs-comment">;</span>        <span class="hljs-built_in">random</span>.ints().limit(<span class="hljs-number">10</span>).forEach(System.out::println)<span class="hljs-comment">;</span></code></pre></div></li><li><p>方法引用，进一步简化Lambda 表达式</p><div class="hljs"><pre><code class="hljs undefined">ClassName::staticMethodName<span class="hljs-built_in">String</span> :: <span class="hljs-function"><span class="hljs-params">valueof</span> =&gt;</span> x-&gt;<span class="hljs-built_in">String</span>.valueOf(x)</code></pre></div></li><li><p>接口提供默认方法，简化简单的抽象。</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>Vehicle &#123;  <span class="hljs-built_in"> default </span>void <span class="hljs-builtin-name">print</span>()&#123;      System.out.println(<span class="hljs-string">"我是一辆车!"</span>);   &#125;&#125;</code></pre></div></li><li><p>Metaspace 替换掉 PremGen，Metaspace 并不在虚拟机中，而是使用本地内存。替换的目的一方面是可以提升对元数据的管理同时提升 GC 效率，另一方面是方便后续 HotSpot 与 JRockit 合并。java7之前，方法区位于永久代(PermGen)，永久代和堆相互隔离。永久代的大小在启动JVM时可以设置一个固定值，不可变；java8中，取消永久代，方法存放于元空间(Metaspace)，元空间仍然与堆不相连，但与堆共享物理内存，逻辑上可认为在堆中<br>Native memory：本地内存，也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。</p></li></ul><p>为什么移除永久代？</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>永久代大小不容易确定，PermSize指定太小容易造成永久代OOM</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ol><p><strong>从PermGen分离类的元数据信息到Metaspace,由于Metaspace的分配具有和Java Heap相同的地址空间，因此Metaspace和Java Heap可以无缝的管理，而且简化了FullGC的过程，以至将来可以并行的对元数据信息进行垃圾收集，而没有GC暂停。</strong></p><h2 id="2-Java集合"><a href="#2-Java集合" class="headerlink" title="2. Java集合"></a>2. Java集合</h2><ul><li>hashMap传送门 -&gt; <a href="http://190coder.cn/2020/03/23/Java-HashMap/" target="_blank" rel="noopener">http://190coder.cn/2020/03/23/Java-HashMap/</a></li><li>TreeMap   是一个有序的key-value集合，它是通过红黑树实现的。 该映射根据其键的自然顺序(字母排序)进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li></ul><h2 id="3-动态代理与反射"><a href="#3-动态代理与反射" class="headerlink" title="3. 动态代理与反射"></a>3. 动态代理与反射</h2><p>Mybatis 与其实现类的解耦,原本接口和动态类之间是强关联状态,接口不能实例化,实现类必须实现接口的所有方法,有了动态代理之后,接口与实现类的关系并不是很大,而是用一个方法拦截器转向到自己的通用处理逻辑。甚至不需要实现类就可以完成调用。 Spring AOP 解耦后自然可以实现对原有方法增强的同时又对其代码的零侵入性。而 RPC 调用时会使用到反射机制调用实现类方法。<br><strong>动态代理的实现就是反射机制。</strong></p><h2 id="4-对对象的引用"><a href="#4-对对象的引用" class="headerlink" title="4. 对对象的引用"></a>4. 对对象的引用</h2><p>Java对对象的引用分为强引用、软引用、弱引用、虚引用四种，这些引用在GC时的处理策略不同，强引用不会被GC回收；软引用内存空间不足时会被GC回收；弱引用则在每次GC时被回收；虚引用必须和引用队列联合使用，主要用于跟踪一个对象被垃圾回收的过程。<br><strong>循环引用是否被回收，就看这个循环引用是否挂在根上，A引用B，B引用A，A和Ｂ并没有挂在某个内存元和根上，当他们的生命周期结束的时候，这两个对象都有可能被回收。</strong></p><h2 id="5-Java-异常处理机制"><a href="#5-Java-异常处理机制" class="headerlink" title="5. Java 异常处理机制"></a>5. Java 异常处理机制</h2><p>Java 的异常处理机制就是 try-catch-finally 机制，需要知道异常时在 try catch 中的处理流程；需要了解 Error 和 Exception 的区别。</p><ul><li><p>try/catch/finally块的流程控制：</p><ul><li><p>如果在try块中发生异常那么控制会立刻被传递（跳过try块中的剩下的其他语句）到catch中去。一旦catch块执行完成之后finally块和其后的程序执行</p></li><li><p>如果在代码中没有异常发生，try块中的代码会被完全执行，然后执行控制被传递到（跳过catch块）finally块中</p></li><li><p>如果在catch或者try块中有return语句，在这种情况下，finally也会执行，控制流是：先执行finally然后回到return语句。</p></li></ul></li><li><p>error和exception的区别：</p><ul><li>Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。</li><li>Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。<ul><li>运行时异常（Runtime Exception）：ArithmaticException,IllegalArgumentException，编译能通过，但是一运行就终止了，程序不会处理运行时异常，出现这类异常，程序会终止。</li><li>受检查的异常(Checked Exception )：要么用try。。。catch捕获，要么用throws字句声明抛出，交给它的父类处理，否则编译不会通过。</li></ul></li></ul></li></ul><h2 id="6-注解机制"><a href="#6-注解机制" class="headerlink" title="6. 注解机制"></a>6. 注解机制</h2><p>在编译时由编译器进行处理，注解被编译后的本质就是一个继承Annotation接口的接口，其实就是“public interface Test extends Annotation”，当我们通过AnnotationTest.class.getAnnotation(Test.class)调用时，JDK会通过动态代理生成一个实现了Test接口的对象，并把将RuntimeVisibleAnnotations属性值设置进此对象中，此对象即为Test注解对象，通过它的value()方法就可以获取到注解值。</p><h2 id="7-SPI机制"><a href="#7-SPI机制" class="headerlink" title="7. SPI机制"></a>7. SPI机制</h2><p> SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制。SPI是一种动态替换发现的机制， 比如有个接口，想运行时动态的给它添加实现，你只需要添加一个实现。</p><p> 通过jdk的ServiceLoader 实现，遍历这个创建的ServiceLoader,遍历的过程中,首先会去加载之前在项目中配置的接口资源。调用ServiceLoader中的hasNext()和Next()方法得到该Service的实现类.</p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 常用设计模式</title>
    <link href="/2020/03/24/Java-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/03/24/Java-%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/sjms.png" srcset="/img/loading.gif" alt></p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h2><ul><li><p>静态初始化，饿汉方式。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<span class="hljs-comment">//分别实例化对象 s1，s2</span>Singleton s1 = Singleton.getInstance();Singleton s2 = Singleton.getInstance();System.<span class="hljs-keyword">out</span>.println(s1 == s2);&#125; &#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>&#123;<span class="hljs-comment">//私有的构造函数，保证外类不能实例化本类</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-comment">//自己创建一个类的实例化</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton singleton = <span class="hljs-keyword">new</span> Singleton();<span class="hljs-comment">//创建一个get方法，返回一个实例s</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> singleton;&#125;&#125;</code></pre></div></li><li><p>双重检测，懒汉方式。<strong>保证了变量的可见性（visibility）。被volatile关键字修饰的变量，如果值发生了变更，其他线程立马可见，避免出现脏读的现象</strong></p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;        <span class="hljs-comment">//volatile修饰：当instance被初始化时，多个线程能正确地处理instance变量</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Singleton instance;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//...</span>    &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance) &#123; <span class="hljs-comment">//只有第一次才会执行此if代码块</span>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance) &#123;<span class="hljs-comment">//再次检查</span>                    instance = <span class="hljs-keyword">new</span> Singleton();                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> instance;    &#125; &#125;</code></pre></div><ul><li>单例注册表方式，Spring Bean </li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonRegistry</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonRegistry instance;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map factoryMap = <span class="hljs-keyword">new</span> <span class="hljs-type">HashMap</span>();        <span class="hljs-comment">//私有化构造方法</span>    <span class="hljs-keyword">private</span> SingletonRegistry()&#123;            &#125;        <span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">static</span>  SingletonRegistry getInstance()&#123;        <span class="hljs-keyword">if</span>(instance==<span class="hljs-literal">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> <span class="hljs-type">SingletonRegistry</span>();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;            <span class="hljs-keyword">public</span> synchronized BeanFactroy getBeanFactory(<span class="hljs-keyword">String</span> factoryName)&#123;        BeanFactroy f=<span class="hljs-literal">null</span>;        <span class="hljs-comment">//在注册表中查找看是否有这个BeanFactory的实例</span>        Object o = factoryMap.<span class="hljs-keyword">get</span>(factoryName);                <span class="hljs-keyword">if</span>(o!=<span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">return</span> (BeanFactroy)o;        &#125;            <span class="hljs-keyword">try</span> &#123;        f= (BeanFactroy)Class.forName(factoryName).<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>();                        <span class="hljs-comment">//将Bean工厂注册到注册表</span>            factoryMap.put(factoryName,f);                                &#125;        <span class="hljs-keyword">catch</span> (Exception ex) &#123;            ex.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> f;            &#125;    &#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactroy</span></span>&#123;    &#125;<span class="hljs-comment">/*一个单例类，通过Map持有BeanFactory的对象聚集。SingletngRegistry本身只有一个实例 但是 *它可以持有任意多个BeanFactory的实例 */</span></code></pre></div><p>知识盲点：<strong>new Instance() 弱类型，通过Class.forName()提前加载类才能使用，低效率，只能调用无参构造。 new: 强类型。相对高效。能调用任何public构造。</strong></p><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h2><p>Spring Bean通过Class.forName().newInstance();创建所有类并存到hashMap。</p><h2 id="3-代理模式"><a href="#3-代理模式" class="headerlink" title="3. 代理模式"></a>3. 代理模式</h2><p>利用java反射机制，动态的生成了一个代理类，直接调用代理方法即可。AOP 就是动态代理机制。</p><h2 id="4-责任链模式"><a href="#4-责任链模式" class="headerlink" title="4.责任链模式"></a>4.责任链模式</h2><p>类似与请假审批流程。正常就顺序执行if else 判断即可。但是类庞大，所有方法都集中在一个类，违反了 “单一职责原则”，测试和维护难度大。如果增加额外需求，也违反了 “开闭原则”。（扩展时代码尽不改变源代码，无需重新测试、审查。）使用场景是多个对象处理同一个请求。过滤器一般都使用责任链模式。</p><h2 id="5-适配器模式"><a href="#5-适配器模式" class="headerlink" title="5. 适配器模式"></a>5. 适配器模式</h2><p>类似转接头，如slf4j 桥接到其他日志框架。<br>类适配器例子 对象适配器同理</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.company;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Convert_110v</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PowerPort220V</span></span>&#123;    <span class="hljs-comment">//原有插头只能输出220V</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Output_220v</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"220"</span>);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter220V</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PowerPort220V</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;        <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Convert_110v</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">this</span>.Output_220v();    &#125;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdapterPattern</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;        Target mAdapter220V = <span class="hljs-keyword">new</span> Adapter220V();         mAdapter220V.Convert_110v();    &#125;&#125;</code></pre></div><h2 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6. 观察者模式"></a>6. 观察者模式</h2><p>类似 Spring 事件驱动，由一个事件生产者通过事件广播器创造线程任务推送给多个监听者。</p><h2 id="7-构造者模式"><a href="#7-构造者模式" class="headerlink" title="7. 构造者模式"></a>7. 构造者模式</h2><p> 构造者模式，适用于一个对象有很多复杂的属性，需要根据不同情况创建不同的具体对象。</p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java ThreadPoolExecutor</title>
    <link href="/2020/03/24/Java-ThreadPoolExecutor/"/>
    <url>/2020/03/24/Java-ThreadPoolExecutor/</url>
    
    <content type="html"><![CDATA[<p>线程池为了避险频繁的创建和销毁带来性能损耗，建立的一种池化技术。</p><h2 id="1-Executors-返回线程池对象弊端："><a href="#1-Executors-返回线程池对象弊端：" class="headerlink" title="1. Executors 返回线程池对象弊端："></a>1. Executors 返回线程池对象弊端：</h2><ul><li><p>FixedThreadPool 和 SingleThreadPool 可能会堆积大量请求。导致OOM。</p></li><li><p>CachedThreadPool 和 ScheduledThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></li></ul><h2 id="2-ThreadPoolExecutor-核心参数"><a href="#2-ThreadPoolExecutor-核心参数" class="headerlink" title="2. ThreadPoolExecutor 核心参数"></a>2. ThreadPoolExecutor 核心参数</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,                          <span class="hljs-keyword">int</span> maximumPoolSize,                          <span class="hljs-keyword">long</span> keepAliveTime,                          TimeUnit unit,                          BlockingQueue&lt;Runnable&gt; workQueue,                          ThreadFactory threadFactory,                          RejectedExecutionHandler <span class="hljs-keyword">handler</span>)</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        <span class="hljs-comment">// maximumPoolSize 必须大于 0，且必须大于 corePoolSize</span>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || <span class="hljs-keyword">handler</span> == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-keyword">null</span> ?            <span class="hljs-keyword">null</span> :            AccessController.getContext();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">handler</span> = <span class="hljs-keyword">handler</span>;&#125;</code></pre></div><ul><li>corePoolSize 线程池常驻核心线程数，如果为0，销毁线程池，如果有值，及时没有任务也能保证线程池的线程数量等于此值。不可过大过小，浪费资源或频繁创建销毁。</li><li>maximunPoolSize 表示线程池任务最多时候，最大可以创建的线程数。</li><li>keepAliveTime 线程存活时间，当线程池空闲时并且超过了此时间，多余的线程就会销毁，直到线程池中的线程数量销毁的等于 corePoolSize 为止。</li><li>unit 存活单位时间。</li><li>workQueue 线程池任务列表。</li><li>threadFactory 表示线程的创建工厂。</li><li>RejectedExecutionHandler 表示指定线程池的拒绝策略，限流保护。</li></ul><h2 id="3-ThreadPool工作流程"><a href="#3-ThreadPool工作流程" class="headerlink" title="3. ThreadPool工作流程"></a>3. ThreadPool工作流程</h2><p><img src="/images/threadpool.png" srcset="/img/loading.gif" alt></p><h2 id="4-ThreadPoolExecutor-的执行方法"><a href="#4-ThreadPoolExecutor-的执行方法" class="headerlink" title="4. ThreadPoolExecutor 的执行方法"></a>4. ThreadPoolExecutor 的执行方法</h2><p>submit() 配合 Futrue 接收返回值 execute() 没有返回值。</p><h2 id="5-拒绝策略"><a href="#5-拒绝策略" class="headerlink" title="5.拒绝策略"></a>5.拒绝策略</h2><p>Java自带的拒绝策略有4种：</p><ul><li>AbortPolicy，终止策略，线程池会抛出异常并终止执行，它是默认的拒绝策略；</li><li>CallerRunsPolicy，把任务交给当前线程来执行；</li><li>DiscardPolicy，忽略此任务（最新的任务）；</li><li>DiscardOldestPolicy，忽略最早的任务（最先加入队列的任务）。</li></ul><div class="hljs"><pre><code class="hljs undefined">ThreadPoolExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>,                TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">2</span>),                <span class="hljs-keyword">new</span> ThreadPoolExecutor.AbortPolicy());        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;            executor.execute<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;                <span class="hljs-keyword">try</span> &#123;                    Thread.sleep(<span class="hljs-number">1</span>);                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(Thread.currentThread().getName());            &#125;)</span>;        &#125;</span></code></pre></div><p>队列最多允许2个等待任务，因此当到第6个任务时候 会报错。<strong>这里的2个等待任务是针对线程池等待队列，不是每个线程2个等待队列，所以是2+3 =5。测试时候不设置休眠会导致执行过快，没有等待队列出现，因此不会报错。</strong></p><h2 id="6-自定义拒绝策略"><a href="#6-自定义拒绝策略" class="headerlink" title="6. 自定义拒绝策略"></a>6. 自定义拒绝策略</h2><div class="hljs"><pre><code class="hljs undefined">ThreadPoolExecutor executor = new ThreadPoolExecutor(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>,        TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">2</span>),        new RejectedExecutionHandler() &#123;  // 添加自定义拒绝策略            @Override            public void rejectedExecution(<span class="hljs-name">Runnable</span> r, ThreadPoolExecutor executor) &#123;                // 业务处理方法                System.out.println(<span class="hljs-string">"执行自定义拒绝策略"</span>)<span class="hljs-comment">;</span>            &#125;        &#125;)<span class="hljs-comment">;</span>for (<span class="hljs-name">int</span> i = <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 6; i++) &#123;</span>    executor.execute(() -&gt; &#123;        System.out.println(<span class="hljs-name">Thread</span>.currentThread().getName())<span class="hljs-comment">;</span>    &#125;)<span class="hljs-comment">;</span>&#125;</code></pre></div><h2 id="7-线程池扩展"><a href="#7-线程池扩展" class="headerlink" title="7. 线程池扩展"></a>7. 线程池扩展</h2><p>ThreadPoolExecutor的扩展主要是通过重写它的beforeExecute()和afterExecute()方法实现的，我们可以在扩展方法中添加日志或者实现数据统计，比如统计线程的执行时间，如下代码所示：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolExtend</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        <span class="hljs-comment">// 线程池扩展调用</span>        MyThreadPoolExecutor executor = <span class="hljs-keyword">new</span> MyThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>,                TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingQueue());        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;            executor.execute(() -&gt; &#123;                Thread.currentThread().getName();            &#125;);        &#125;    &#125;   <span class="hljs-comment">/**     * 线程池扩展     */</span>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ThreadPoolExecutor</span> </span>&#123;        <span class="hljs-comment">// 保存线程执行开始时间</span>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Long&gt; localTime = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime,                            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;    <span class="hljs-keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);&#125;        <span class="hljs-comment">/**         * 开始执行之前         * <span class="hljs-doctag">@param</span> t 线程         * <span class="hljs-doctag">@param</span> r 任务         */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> </span>&#123;            Long sTime = System.nanoTime(); <span class="hljs-comment">// 开始时间 (单位：纳秒)</span>            localTime.set(sTime);            System.out.println(String.format(<span class="hljs-string">"%s | before | time=%s"</span>,                    t.getName(), sTime));            <span class="hljs-keyword">super</span>.beforeExecute(t, r);        &#125;        <span class="hljs-comment">/**         * 执行完成之后         * <span class="hljs-doctag">@param</span> r 任务         * <span class="hljs-doctag">@param</span> t 抛出的异常         */</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> </span>&#123;            Long eTime = System.nanoTime(); <span class="hljs-comment">// 结束时间 (单位：纳秒)</span>            Long totalTime = eTime - localTime.get(); <span class="hljs-comment">// 执行总时间</span>            System.out.println(String.format(<span class="hljs-string">"%s | after | time=%s | 耗时：%s 毫秒"</span>,                    Thread.currentThread().getName(), eTime, (totalTime / <span class="hljs-number">1000000.0</span>)));            <span class="hljs-keyword">super</span>.afterExecute(r, t);        &#125;    &#125;&#125;</code></pre></div><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>线程池用ThreadPoolExecutor 创建，通过拒绝策略，参数设定，继承实现扩展，可以更加优雅，明确运行规则，规避资源耗尽风险。</p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java HashMap 总结</title>
    <link href="/2020/03/23/Java-HashMap/"/>
    <url>/2020/03/23/Java-HashMap/</url>
    
    <content type="html"><![CDATA[<p>在JDK1.7中HashMap是以数组加链表的形式组成的，JDK1.8之后新增了红黑树的组成结构，当链表大于8并且容量大于64时，链表结构会转换成红黑树结构，它的组成结构如下：</p><p><img src="/images/hashmap.png" srcset="/img/loading.gif" alt></p><p>JDK1.8后 之所以添加红黑树，因为一旦列表过长，会严重影响HashMap的性能，而红黑树具有快速增删改查特点，有效解决链表过长的问题。</p><h1 id="HashMap-源码分析"><a href="#HashMap-源码分析" class="headerlink" title="HashMap 源码分析"></a>HashMap 源码分析</h1><p>HashMap 源码中包含了以下几个属性：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">// HashMap 初始化长度</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>; <span class="hljs-comment">// aka 16</span><span class="hljs-comment">// HashMap 最大长度</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>; <span class="hljs-comment">// 1073741824</span><span class="hljs-comment">// 默认的加载因子 (扩容因子)</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<span class="hljs-comment">// 当链表长度大于此值且容量大于 64 时</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<span class="hljs-comment">// 转换链表的临界值，当元素小于此值时，会将红黑树结构转换成链表结构</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<span class="hljs-comment">// 最小树容量</span><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY =</code></pre></div><h2 id="1-加载因子"><a href="#1-加载因子" class="headerlink" title="1. 加载因子"></a>1. 加载因子</h2><ul><li>加载因子也叫扩容因子或负载因子，例如加载因子是0.5，初始容量是16， 那么当元素到达8 时候就会扩容。</li><li>为什么是0.75？ 出于性能和容量平衡。<ul><li>当加载因子比较大时候，扩容发生的频率比较低，但是发生hash冲突的概率会比较高，导致数据结构变复杂，对元素操作时间增加，效率降低。</li><li>当加载因子比较小时候，扩容发生频率高，更占用空间，元素存储比较稀疏，冲突减少，性能增加。</li></ul></li></ul><p>所以综合取0.5 、1.0 中间0.75。</p><h2 id="2-HashMap-源码中三个重要方法，查找、新增、数据扩容。"><a href="#2-HashMap-源码中三个重要方法，查找、新增、数据扩容。" class="headerlink" title="2. HashMap 源码中三个重要方法，查找、新增、数据扩容。"></a>2. HashMap 源码中三个重要方法，查找、新增、数据扩容。</h2><ul><li>查找源码如下：</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;    Node&lt;K,V&gt; e;    <span class="hljs-comment">// 对 key 进行哈希操作</span>    <span class="hljs-keyword">return</span> (e = getNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>)) == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : e.value;&#125;<span class="hljs-keyword">final</span> Node&lt;K,V&gt; getNode(<span class="hljs-built_in">int</span> hash, <span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="hljs-built_in">int</span> n; K k;    <span class="hljs-comment">// 非空判断</span>    <span class="hljs-keyword">if</span> ((tab = table) != <span class="hljs-keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;        (first = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 判断第一个元素是否是要查询的元素</span>        <span class="hljs-keyword">if</span> (first.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span>            ((k = first.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))            <span class="hljs-keyword">return</span> first;        <span class="hljs-comment">// 下一个节点非空判断</span>        <span class="hljs-keyword">if</span> ((e = first.next) != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// 如果第一节点是树结构，则使用 getTreeNode 直接获取相应的数据</span>            <span class="hljs-keyword">if</span> (first <span class="hljs-keyword">instanceof</span> TreeNode)                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, <span class="hljs-built_in">key</span>);            do &#123; <span class="hljs-comment">// 非树结构，循环节点判断</span>                <span class="hljs-comment">// hash 相等并且 key 相同，则返回此节点</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))                    <span class="hljs-keyword">return</span> e;            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-keyword">null</span>);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p>以上看出，当hash 冲突，需要判断key相不相同。</p><ul><li>新增源码如下：</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;    <span class="hljs-comment">// 对 key 进行哈希操作</span>    <span class="hljs-keyword">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>);&#125;<span class="hljs-keyword">final</span> V putVal(<span class="hljs-built_in">int</span> hash, K <span class="hljs-built_in">key</span>, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,               <span class="hljs-built_in">boolean</span> evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="hljs-built_in">int</span> n, i;    <span class="hljs-comment">// 哈希表为空则创建表      </span>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-keyword">null</span> || (n = tab.length) == <span class="hljs-number">0</span>)        n = (tab = resize()).length;    <span class="hljs-comment">// 根据 key 的哈希值计算出要插入的数组索引 i    </span>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-keyword">null</span>)        <span class="hljs-comment">// 如果 table[i] 等于 null，则直接插入</span>        tab[i] = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);    <span class="hljs-keyword">else</span> &#123;        Node&lt;K,V&gt; e; K k;        <span class="hljs-comment">// 如果 key 已经存在了，直接覆盖 value</span>        <span class="hljs-keyword">if</span> (p.hash == hash &amp;&amp;            ((k = p.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))            e = p;        <span class="hljs-comment">// 如果 key 不存在，判断是否为红黑树     </span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> TreeNode)            <span class="hljs-comment">// 红黑树直接插入键值对</span>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="hljs-keyword">this</span>, tab, hash, <span class="hljs-built_in">key</span>, value);        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 为链表结构，循环准备插入</span>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;                <span class="hljs-comment">// 下一个元素为空时</span>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-keyword">null</span>) &#123;                    p.next = newNode(hash, <span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);                    <span class="hljs-comment">// 转换为红黑树进行处理</span>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span>                        treeifyBin(tab, hash);                    <span class="hljs-keyword">break</span>;                &#125;                <span class="hljs-comment">//  key 已经存在直接覆盖 value</span>                <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))                    <span class="hljs-keyword">break</span>;                p = e;            &#125;        &#125;        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// existing mapping for key</span>            V oldValue = e.value;            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-keyword">null</span>)                e.value = value;            afterNodeAccess(e);            <span class="hljs-keyword">return</span> oldValue;        &#125;    &#125;    ++modCount;    <span class="hljs-comment">// 超过最大容量，扩容</span>    <span class="hljs-keyword">if</span> (++<span class="hljs-built_in">size</span> &gt; threshold)        resize();    afterNodeInsertion(evict);    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;</code></pre></div><p><img src="/images/hashmapput.png" srcset="/img/loading.gif" alt></p><ul><li>扩容源码如下：</li></ul><div class="hljs"><pre><code class="hljs undefined">final Node&lt;K,V&gt;[] resize() &#123;    <span class="hljs-comment">// 扩容前的数组</span>    Node&lt;K,V&gt;[] oldTab = table;    <span class="hljs-comment">// 扩容前的数组的大小和阈值</span>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;    int oldThr = threshold;    <span class="hljs-comment">// 预定义新数组的大小和阈值</span>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;        <span class="hljs-comment">// 超过最大值就不再扩容了</span>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            <span class="hljs-keyword">return</span> oldTab;        &#125;        <span class="hljs-comment">// 扩大容量为当前容量的两倍，但不能超过 MAXIMUM_CAPACITY</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span>    &#125;    <span class="hljs-comment">// 当前数组没有数据，使用初始化的值</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;    <span class="hljs-keyword">else</span> &#123;               <span class="hljs-comment">// zero initial threshold signifies using defaults</span>        <span class="hljs-comment">// 如果初始化的值为 0，则使用默认的初始化容量</span>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    <span class="hljs-comment">// 如果新的容量等于 0</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);    &#125;    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;     @SuppressWarnings(&#123;<span class="hljs-string">"rawtypes"</span>,<span class="hljs-string">"unchecked"</span>&#125;)    Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];    <span class="hljs-comment">// 开始扩容，将新的容量赋值给 table</span>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;    <span class="hljs-comment">// 原数据不为空，将原数据复制到新 table 中</span>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;        <span class="hljs-comment">// 根据容量循环数组，复制非空元素到新 table</span>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;                oldTab[j] = <span class="hljs-literal">null</span>;                <span class="hljs-comment">// 如果链表只有一个，则进行直接赋值</span>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)                    <span class="hljs-comment">// 红黑树相关的操作</span>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);                <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span>                    <span class="hljs-comment">// 链表复制，JDK 1.8 扩容优化部分</span>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;                    Node&lt;K,V&gt; next;                    <span class="hljs-keyword">do</span> &#123;                        next = e.next;                        <span class="hljs-comment">// 原索引</span>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)                                loHead = e;                            <span class="hljs-keyword">else</span>                                loTail.next = e;                            loTail = e;                        &#125;                        <span class="hljs-comment">// 原索引 + oldCap</span>                        <span class="hljs-keyword">else</span> &#123;                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)                                hiHead = e;                            <span class="hljs-keyword">else</span>                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);                    <span class="hljs-comment">// 将原索引放到哈希桶中</span>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;                        loTail.next = <span class="hljs-literal">null</span>;                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;                    &#125;                    <span class="hljs-comment">// 将原索引 + oldCap 放到哈希桶中</span>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;                        hiTail.next = <span class="hljs-literal">null</span>;                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;&#125;</code></pre></div><p>从以上源码可以看出，JDK1.8在扩容时并没有像JDK1.7那样，重新计算每个元素的哈希值，而是通过高位运算（e.hash&amp;oldCap）来确定元素是否需要移动，比如key1的信息如下：</p><ul><li><p>key1.hash = 10 0000 1010</p></li><li><p>oldCap = 16 0001 0000</p></li></ul><p>使用e.hash&amp;oldCap得到的结果，高一位为0，当结果为0时表示元素在扩容时位置不会发生任何变化，而key2信息如下：</p><ul><li><p>key2.hash = 10 0001 0001</p></li><li><p>oldCap = 16 0001 0000<br>这时候得到的结果，高一位为 1，当结果为 1 时，表示元素在扩容时位置发生了变化，新的下标位置等于原下标位置 + 原数组长度，如下图所示：</p><p><img src="/images/hashmapresize.png" srcset="/img/loading.gif" alt></p><h2 id="3-HashMap-死循环"><a href="#3-HashMap-死循环" class="headerlink" title="3. HashMap 死循环"></a>3. HashMap 死循环</h2><p>以JDK1.7为例，假设HashMap默认大小为2，原本HashMap中有一个元素key(5)，我们再使用两个线程：t1添加元素key(3)，t2添加元素key(7)，当元素key(3) 和 key(7) 都添加到 HashMap 中之后，线程 t1 在执行到 Entry&lt;K,V&gt; next = e.next; 时，交出了 CPU 的使用权。</p></li></ul><p>那么此时线程t1中的e指向了key(3)，而next指向了key(7)；之后线程t2重新rehash之后链表的顺序被反转，链表的位置变成了key(5)→key(7)→key(3)，其中“→”用来表示下一个元素。当t1重新获得执行权之后，先执行newTalbe[i]=e把key(3)的next设置为key(7)，而下次循环时查询到 key(7) 的 next 元素为 key(3)，于是就形成了 key(3) 和 key(7) 的循环引用，因此就导致了死循环的发生，如下图所示：</p><p> <img src="/images/hashmaplock.png" srcset="/img/loading.gif" alt></p><p> 当然发生死循环的原因是 JDK 1.7 链表插入方式为首部倒序插入，这个问题在 JDK 1.8 得到了改善，变成了尾部正序插入。HashMap 本身就是非线程安全的，如果要在多线程下，建议使用 ConcurrentHashMap 替代。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><ul><li>HashMap 底层结构是 数组+链表+红黑树。1.8后 链表长度大于8 并且容量大于64 会转红黑树存储，以提升效率。</li><li>三个重要方法 get()、put()、resize()。 get() 先判断hash 在判断key。put() 先得到下标，hash表空直接扩容，在判断key，判断树还是链表，最后再判断长度是否大于threshold 临界值，在扩容。</li><li>JDK1.7 resize() 多线程会发生死锁，rehash链表顺序被反转。执行到next会循环引用，原因是1.7 是头插法。</li></ul><h2 id="2020-5-20-补充："><a href="#2020-5-20-补充：" class="headerlink" title="2020.5.20 补充："></a>2020.5.20 补充：</h2><p>关于HashMap 初始化：</p><p>《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。 </p><div class="hljs"><pre><code class="hljs undefined">HashMap hm = new HashMap(<span class="hljs-name">int</span>) ((<span class="hljs-name">float</span>) expectedSize / <span class="hljs-number">0.75</span>F + <span class="hljs-number">1.0</span>F)<span class="hljs-comment">;</span></code></pre></div><p>给HashMap设置初始容量可以在一定程度上提升效率。</p><p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。得到这个数字的算法其实是使用了使用无符号右移和按位或运算来提升效率。</p><h4 id="为什么必须是2的幂"><a href="#为什么必须是2的幂" class="headerlink" title="为什么必须是2的幂?"></a>为什么必须是2的幂?</h4><p>因为在扩容和设定初始容量的时候，在 n 为 2次幂的情况下时，(n - 1) &amp; hash ≈ hash % n ,因为2进制的运算速度远远高于取模，所以就使用了这种方式，所以要求为2的幂。</p><h4 id="为什么非要用-n-1-amp-hash？"><a href="#为什么非要用-n-1-amp-hash？" class="headerlink" title="为什么非要用 (n - 1) &amp; hash？"></a>为什么非要用 (n - 1) &amp; hash？</h4><p>因为(n - 1) &amp; hash ≈ hash % n，取模分布长度更加均匀，减少hash冲突。</p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java String 总结</title>
    <link href="/2020/03/23/Java-String/"/>
    <url>/2020/03/23/Java-String/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Spring-是如何实现的"><a href="#1-Spring-是如何实现的" class="headerlink" title="1. Spring 是如何实现的"></a>1. Spring 是如何实现的</h2><p>以主流的 JDK 版本 1.8 来说，String 内部实际存储结构为 char 数组</p><h2 id="2-Spring-有哪些重要的方法"><a href="#2-Spring-有哪些重要的方法" class="headerlink" title="2. Spring 有哪些重要的方法"></a>2. Spring 有哪些重要的方法</h2><ul><li>多构造方法</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">// String 为参数的构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span>(<span class="hljs-params">String original</span>)</span> &#123;    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = original.<span class="hljs-keyword">value</span>;    <span class="hljs-keyword">this</span>.hash = original.hash;&#125;<span class="hljs-comment">// char[] 为参数构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span>(<span class="hljs-params"><span class="hljs-keyword">char</span> <span class="hljs-keyword">value</span>[]</span>)</span> &#123;    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = Arrays.copyOf(<span class="hljs-keyword">value</span>, <span class="hljs-keyword">value</span>.length);&#125;<span class="hljs-comment">// StringBuffer 为参数的构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span>(<span class="hljs-params">StringBuffer buffer</span>)</span> &#123;    synchronized(buffer) &#123;        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = Arrays.copyOf(buffer.getValue(), buffer.length());    &#125;&#125;<span class="hljs-comment">// StringBuilder 为参数的构造方法</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span>(<span class="hljs-params">StringBuilder builder</span>)</span> &#123;    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = Arrays.copyOf(builder.getValue(), builder.length());&#125;</code></pre></div><p>不过  StringBuffer 和 StringBuilder一般为单独使用</p><ul><li><p>equals() 比较两个字符串是否相等。<br>String类型重写了Object中的equals()方法，equals()方法需要传递一个Object类型的参数值，在比较时会先通过instanceof判断是否为String，之后循环比较char数组。返回 boolure。</p></li><li><p>compareTo() 比较两个字符串，返回 int 型。</p></li><li><p>其他重要方法：</p><ul><li>indexOf()：查询字符串首次出现的下标位置</li><li>lastIndexOf()：查询字符串最后出现的下标位置</li><li>contains()：查询字符串中是否包含另一个字符串</li><li>toLowerCase()：把字符串全部转换成小写</li><li>toUpperCase()：把字符串全部转换成大写</li><li>length()：查询字符串的长度</li><li>trim()：去掉字符串首尾空格</li><li>replace() 替换掉字符串中的某些字符</li><li>split()：把字符串分割并返回字符串数组 </li><li>join()：把字符串数组转为字符串</li></ul></li></ul><h2 id="3-和-equals-的区别"><a href="#3-和-equals-的区别" class="headerlink" title="3. == 和 equals 的区别"></a>3. == 和 equals 的区别</h2><p>== 是引用的内存地址的比较，equals是值比较。Object equals 是直接比较引用地址。String 重写了equals 方法，先比较引用地址，然后比较类型是不是String，最后把2个字符串转换成Char 数组对比，循环每一个字符，其中有一个不想等就返回false，否则继续对比。</p><h2 id="4-final修饰的好处"><a href="#4-final修饰的好处" class="headerlink" title="4. final修饰的好处"></a>4. final修饰的好处</h2><ul><li>安全：如果有一些列校验后，如果是可变的，校验后他的内部值又被改变了，可能引起系统崩溃问题。</li><li>效率高：能够缓存结果（常量池）如果是可变的话，则有可能重写拷贝一个新值进行传参，性能空间都有浪费。</li></ul><p><img src="/images/string.png" srcset="/img/loading.gif" alt></p><p>如果 String 是可变的，那当 s1 的值修改之后，s2 的值也跟着改变了，这样就和我们预期的结果不相符了，因此也就没有办法实现字符串常量池的功能了。</p><h2 id="5-String-和-StringBuilder、StringBuffer-的区别"><a href="#5-String-和-StringBuilder、StringBuffer-的区别" class="headerlink" title="5. String 和 StringBuilder、StringBuffer 的区别"></a>5. String 和 StringBuilder、StringBuffer 的区别</h2><ul><li>String 类型不可变，所以拼接字符串性能会很低。</li><li>StringBuffer synchronized 线程安全</li><li>StringBuilder 线程不安全，但效率高。非并发都用StringBuilder。</li></ul><h2 id="6-String-和-JVM"><a href="#6-String-和-JVM" class="headerlink" title="6. String 和 JVM"></a>6. String 和 JVM</h2><p>String常见的创建方式有两种，直接赋值的方式 “String s1 = “Java”;”和“String s2 = newString(“Java”);”的方式，但两者在JVM的存储区域却截不同，在JDK1.8之后，s1先在常量池中找字符串“java”，如果有相同的字符则直接返回常量句柄。s2直接在堆中创建，需要调用intern 方法才能把此字符串保存到常量池中。<br><img src="/images/stringjvm.png" srcset="/img/loading.gif" alt></p><p>DK 1.7 之后把永生代换成的元空间，把字符串常量池从方法区移到了 Java 堆上。</p><p>除此之外编译器还会对 String 字符串做一些优化，例如以下代码：</p><div class="hljs"><pre><code class="hljs undefined">String <span class="hljs-built_in">s1</span> = <span class="hljs-string">"Ja"</span> + <span class="hljs-string">"va"</span><span class="hljs-comment">;</span>String <span class="hljs-built_in">s2</span> = <span class="hljs-string">"Java"</span><span class="hljs-comment">;</span>System.out.println(<span class="hljs-built_in">s1</span> == <span class="hljs-built_in">s2</span>)<span class="hljs-comment">;// true</span></code></pre></div><p>从编译代码看，代码 “Ja”+”va” 被直接编译成了 “Java” ，因此 s1==s2 的结果才是 true，这就是编译器对字符串优化的结果。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>String 构造方法，常用方法，重点是 equals() 、 CompareTo() ,final的好处，string在jvm执行的细节。</p>]]></content>
    
    
    <categories>
      
      <category>Java 基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Sleuth</title>
    <link href="/2020/03/23/Spring-Cloud-Sleuth/"/>
    <url>/2020/03/23/Spring-Cloud-Sleuth/</url>
    
    <content type="html"><![CDATA[<p>通常一个由客户端发起的请求在后端系统中会经过多个不同的微服务调用来协同产生最后的请求结果，在复杂的微服务架构系统中，几乎每一个前端请求都会形成一条复杂的分布式服务调用链路，在每条链路中任何一个依赖服务出现延迟过高或错误的时候都有可能引起请求最后的失败。这时候对于每个请求全链路调用的跟踪就变得越来越重要，使用Spring Cloud Sleuth来为我们的微服务架构增加分布式服务跟踪的能力。</p><h2 id="一、-快速入门"><a href="#一、-快速入门" class="headerlink" title="一、 快速入门"></a>一、 快速入门</h2><ul><li>添加相关依赖<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ul><p>实际上我们已经为trace-1和trace-2实现服务跟踪做好了基础的准备，重启trace-1和trace-2后，再对trace-1的接口发送请求<a href="http://localhost:9101/trace-1。此时，我们可以从它们的控制台输出中，窥探到sleuth的一些端倪。" target="_blank" rel="noopener">http://localhost:9101/trace-1。此时，我们可以从它们的控制台输出中，窥探到sleuth的一些端倪。</a></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-bullet">-</span><span class="hljs-bullet">-</span> <span class="hljs-string">trace-1</span><span class="hljs-string">INFO</span> <span class="hljs-string">[trace-1,f410ab57afd5c145,a9f2118fa2019684,false]</span> <span class="hljs-number">25028</span> <span class="hljs-meta">---</span> <span class="hljs-string">[nio-9101-exec-1]</span> <span class="hljs-string">ication$$EnhancerBySpringCGLIB$$d8228493</span> <span class="hljs-string">:</span> <span class="hljs-string">===&lt;call</span> <span class="hljs-string">trace-1&gt;===</span><span class="hljs-bullet">-</span><span class="hljs-bullet">-</span> <span class="hljs-string">trace-2</span><span class="hljs-string">INFO</span> <span class="hljs-string">[trace-2,f410ab57afd5c145,e9a377dc2268bc29,false]</span> <span class="hljs-number">23112</span> <span class="hljs-meta">---</span> <span class="hljs-string">[nio-9102-exec-1]</span> <span class="hljs-string">ication$$EnhancerBySpringCGLIB$$e6cb4078</span> <span class="hljs-string">:</span> <span class="hljs-string">===&lt;call</span> <span class="hljs-string">trace-2&gt;===</span></code></pre></div><p>从上面的控制台输出内容中，我们可以看到多了一些形如[trace-1,f410ab57afd5c145,a9f2118fa2019684,false]的日志信息，而这些元素正是实现分布式服务跟踪的重要组成部分，它们每个值的含义如下：</p><ul><li>第一个值：trace-1，它记录了应用的名称，也就是application.properties中spring.application.name参数配置的属性。</li><li>第二个值：f410ab57afd5c145，Spring Cloud Sleuth生成的一个ID，称为Trace ID，它用来标识一条请求链路。一条请求链路中包含一个Trace ID，多个Span ID。</li><li>第三个值：a9f2118fa2019684，Spring Cloud Sleuth生成的另外一个ID，称为Span ID，它表示一个基本的工作单元，比如：发送一个HTTP请求。</li><li>第四个值：false，表示是否要将该信息输出到Zipkin等服务中来收集和展示。</li></ul><p>上面四个值中的Trace ID和Span ID是Spring Cloud Sleuth实现分布式服务跟踪的核心。在一次服务请求链路的调用过程中，会保持并传递同一个Trace ID，从而将整个分布于不同微服务进程中的请求跟踪信息串联起来，以上面输出内容为例，trace-1和trace-2同属于一个前端服务请求来源，所以他们的Trace ID是相同的，处于同一条请求链路中。</p><h2 id="二、-跟踪原理"><a href="#二、-跟踪原理" class="headerlink" title="二、 跟踪原理"></a>二、 跟踪原理</h2><p>分布式系统中的服务跟踪在理论上并不复杂，它主要包括下面两个关键点：</p><ul><li>为了实现请求跟踪，当请求发送到分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的跟踪标识，同时在分布式系统内部流转的时候，框架始终保持传递该唯一标识，直到返回给请求方为止，这个唯一标识就是前文中提到的Trace ID。通过Trace ID的记录，我们就能将所有请求过程日志关联起来。</li><li>为了统计各处理单元的时间延迟，当请求达到各个服务组件时，或是处理逻辑到达某个状态时，也通过一个唯一标识来标记它的开始、具体过程以及结束，该标识就是我们前文中提到的Span ID，对于每个Span来说，它必须有开始和结束两个节点，通过记录开始Span和结束Span的时间戳，就能统计出该Span的时间延迟，除了时间戳记录之外，它还可以包含一些其他元数据，比如：事件名称、请求信息等。</li></ul><p>在快速入门示例中，我们轻松实现了日志级别的跟踪信息接入，这完全归功于spring-cloud-starter-sleuth组件的实现。在Spring Boot应用中，通过在工程中引入spring-cloud-starter-sleuth依赖之后， 它会自动的为当前应用构建起各通信通道的跟踪机制，比如：</p><ul><li>通过诸如RabbitMQ、Kafka（或者其他任何Spring Cloud Stream绑定器实现的消息中间件）传递的请求</li><li>通过Zuul代理传递的请求</li><li>通过RestTemplate发起的请求</li></ul><p>在快速入门示例中，由于trace-1对trace-2发起的请求是通过RestTemplate实现的，所以spring-cloud-starter-sleuth组件会对该请求进行处理，在发送到trace-2之前sleuth会为在该请求的Header中增加实现跟踪需要的重要信息，主要有下面这几个（更多关于头信息的定义我们可以通过查看org.springframework.cloud.sleuth.Span的源码获取）：</p><ul><li>X-B3-TraceId：一条请求链路（Trace）的唯一标识，必须值</li><li>X-B3-SpanId：一个工作单元（Span）的唯一标识，必须值</li><li>X-B3-ParentSpanId:：标识当前工作单元所属的上一个工作单元，Root Span（请求链路的第一个工作单元）的该值为空</li><li>X-B3-Sampled：是否被抽样输出的标志，1表示需要被输出，0表示不需要被输出<br>X-Span-Name：工作单元的名称</li></ul><p>对trace-2的实现做一些修改来输出这些头部信息，具体如下：</p><div class="hljs"><pre><code class="hljs undefined">@RequestMapping(value = <span class="hljs-string">"/trace-2"</span>, method = RequestMethod.<span class="hljs-keyword">GET</span>)<span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> trace(HttpServletRequest <span class="hljs-built_in">request</span>) &#123;logger.info(<span class="hljs-string">"===&lt;call trace-2, TraceId=&#123;&#125;, SpanId=&#123;&#125;&gt;==="</span>,<span class="hljs-built_in">request</span>.getHeader(<span class="hljs-string">"X-B3-TraceId"</span>), <span class="hljs-built_in">request</span>.getHeader(<span class="hljs-string">"X-B3-SpanId"</span>));return <span class="hljs-string">"Trace"</span>;&#125;</code></pre></div><p>输出如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-bullet">-</span><span class="hljs-bullet">-</span> <span class="hljs-string">trace-1</span><span class="hljs-string">INFO</span> <span class="hljs-string">[trace-1,a6e9175ffd5d2c88,8524f519b8a9e399,true]</span> <span class="hljs-number">10532</span> <span class="hljs-meta">---</span> <span class="hljs-string">[nio-9101-exec-2]</span> <span class="hljs-string">icationEnhancerBySpringCGLIB27aa9624</span> <span class="hljs-string">:</span> <span class="hljs-string">===&lt;call</span> <span class="hljs-string">trace-1&gt;===</span><span class="hljs-bullet">-</span><span class="hljs-bullet">-</span> <span class="hljs-string">trace-2</span><span class="hljs-string">INFO</span> <span class="hljs-string">[trace-2,a6e9175ffd5d2c88,ce60dcf1e2ed918f,true]</span> <span class="hljs-number">1208</span> <span class="hljs-meta">---</span> <span class="hljs-string">[nio-9102-exec-3]</span> <span class="hljs-string">icationEnhancerBySpringCGLIBa7d84797</span> <span class="hljs-string">:</span> <span class="hljs-string">===&lt;call</span> <span class="hljs-string">trace-2,</span> <span class="hljs-string">TraceId=a6e9175ffd5d2c88,</span> <span class="hljs-string">SpanId=be4949ec115e554e&gt;===</span></code></pre></div><h2 id="三、-与Logstash整合"><a href="#三、-与Logstash整合" class="headerlink" title="三、 与Logstash整合"></a>三、 与Logstash整合</h2><h2 id="四、-与Zipkin整合"><a href="#四、-与Zipkin整合" class="headerlink" title="四、 与Zipkin整合"></a>四、 与Zipkin整合</h2><p><strong>使用Elasticsearch存储跟踪信息</strong><br>如果我们把zipkin-server重启一下就会发现刚刚的存储的跟踪信息全部丢失了，可见其是存储在内存中的，有时候我们需要将所有信息存储下来，这里使用Elasticsearch。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Stream</title>
    <link href="/2020/03/22/Spring-Cloud-Stream/"/>
    <url>/2020/03/22/Spring-Cloud-Stream/</url>
    
    <content type="html"><![CDATA[<p>Spring Cloud Stream是一个用来为微服务应用构建消息驱动能力的框架。它可以基于Spring Boot来创建独立的、可用于生产的Spring应用程序。它通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动的微服务应用。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，并且引入了发布-订阅、消费组以及消息分区这三个核心概念。</p><h2 id="一、快速入门"><a href="#一、快速入门" class="headerlink" title="一、快速入门"></a>一、快速入门</h2><ol><li>添加依赖</li></ol><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>     <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol start="2"><li>创建用于接收来自RabbitMQ消息的消费者SinkReceiver，具体如下：</li></ol><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@EnableBinding</span>(Sink.<span class="hljs-keyword">class</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinkReceiver</span> &#123;</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(SinkReceiver.<span class="hljs-keyword">class</span>);    <span class="hljs-meta">@StreamListener</span>(Sink.INPUT)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> receive(Object payload) &#123;        logger.info(<span class="hljs-string">"Received: "</span> + payload);    &#125;&#125;</code></pre></div><ul><li>创建应用主类，这里同其他Spring Boot一样，没有什么特别之处，具体如下：</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SinkApplication</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;        SpringApplication.run(SinkApplication.<span class="hljs-keyword">class</span>, args);    &#125;&#125;</code></pre></div><h2 id="二、-核心概念"><a href="#二、-核心概念" class="headerlink" title="二、 核心概念"></a>二、 核心概念</h2><p>Spring Cloud Stream构建的应用程序与消息中间件之间是通过绑定器Binder相关联的，绑定器对于应用程序而言起到了隔离作用，它使得不同消息中间件的实现细节对应用程序来说是透明的。所以对于每一个Spring Cloud Stream的应用程序来说，它不需要知晓消息中间件的通信细节，它只需要知道Binder对应用程序提供的概念去实现即可，而这个概念就是在快速入门中我们提到的消息通道：Channel。如下图案例，在应用程序和Binder之间定义了两条输入通道和三条输出通道来传递消息，而绑定器则是作为这些通道和消息中间件之间的桥梁进行通信。<br><img src="/images/binder.png" srcset="/img/loading.gif" alt></p><h4 id="1-绑定器"><a href="#1-绑定器" class="headerlink" title="1. 绑定器"></a>1. 绑定器</h4><p>在没有绑定器这个概念的情况下，我们的Spring Boot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，这使得我们实现的消息交互逻辑就会非常笨重，因为对具体的中间件实现细节有太重的依赖，当中间件有较大的变动升级、或是更换中间件的时候，我们就需要付出非常大的代价来实施。</p><p>通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现。当我们需要升级消息中间件，或是更换其他消息中间件产品时，我们要做的就是更换它们对应的Binder绑定器而不需要修改任何Spring Boot的应用逻辑。这一点在上一章实现消息总线时，从RabbitMQ切换到Kafka的过程中，已经能够让我们体验到这一好处。目前版本的Spring Cloud Stream为主流的消息中间件产品RabbitMQ和Kafka提供了默认的Binder实现，在快速入门的例子中，我们就使用了RabbitMQ的Binder。另外，Spring Cloud Stream还实现了一个专门用于测试的TestSupportBinder，开发者可以直接使用它来对通道的接收内容进行可靠的测试断言。如果要使用除了RabbitMQ和Kafka以外的消息中间件的话，我们也可以通过使用它所提供的扩展API来实现其他中间件的Binder。</p><p>在快速入门示例中，并没有使用application.properties或是application.yml来做任何属性设置。那是因为它也秉承了Spring Boot的设计理念，提供了对RabbitMQ默认的自动化配置。当然，我们也可以通过Spring Boot应用支持的任何方式来修改这些配置，比如：通过应用程序参数、环境变量、application.properties或是application.yml配置文件等。下面就是通过配置文件来对RabbitMQ的连接信息以及input通道的主题进行配置的示例：</p><div class="hljs"><pre><code class="hljs undefined">spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.stream</span><span class="hljs-selector-class">.bindings</span><span class="hljs-selector-class">.input</span><span class="hljs-selector-class">.destination</span>=raw-sensor-dataspring<span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.host</span>=localhostspring<span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.port</span>=<span class="hljs-number">5672</span>spring<span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.username</span>=springcloudspring<span class="hljs-selector-class">.rabbitmq</span><span class="hljs-selector-class">.password</span>=<span class="hljs-number">123456</span></code></pre></div><h4 id="2-发布订阅模式"><a href="#2-发布订阅模式" class="headerlink" title="2. 发布订阅模式"></a>2. 发布订阅模式</h4><p><img src="/images/pc.png" srcset="/img/loading.gif" alt></p><p>相对于点对点队列实现的消息通信来说，Spring Cloud Stream采用的发布-订阅模式可以有效的降低消息生产者与消费者之间的耦合，当我们需要对同一类消息增加一种处理方式时，只需要增加一个应用程序并将输入通道绑定到既有的Topic中就可以实现功能的扩展，而不需要改变原来已经实现的任何内容。</p><h4 id="3-消费组"><a href="#3-消费组" class="headerlink" title="3. 消费组"></a>3. 消费组</h4><p>按照上面我们启动两个应用的例子，虽然它们同属一个应用，但是这个消息出现了被重复消费两次的情况。为了解决这个问题，在Spring Cloud Stream中提供了消费组的概念。</p><p>如果在同一个主题上的应用需要启动多个实例的时候，我们可以通过spring.cloud.stream.bindings.input.group属性为应用指定一个组名，这样这个应用的多个实例在接收到消息的时候，只会有一个成员真正的收到消息并进行处理。如下图所示，我们为Service-A和Service-B分别启动了两个实例，并且根据服务名进行了分组，这样当消息进入主题之后，Group-A和Group-B都会收到消息的副本，但是在两个组中都只会有一个实例对其进行消费。</p><p><img src="/images/group.png" srcset="/img/loading.gif" alt></p><p>默认情况下，当我们没有为应用指定消费组的时候，Spring Cloud Stream会为其分配一个独立的匿名消费组。所以，如果同一主题下所有的应用都没有指定消费组的时候，当有消息被发布之后，所有的应用都会对其进行消费，因为它们各自都属于一个独立的组中。大部分情况下，我们在创建Spring Cloud Stream应用的时候，建议最好为其指定一个消费组，以防止对消息的重复处理，除非该行为需要这样做（比如：刷新所有实例的配置等）。</p><h4 id="4-消息分区"><a href="#4-消息分区" class="headerlink" title="4. 消息分区"></a>4. 消息分区</h4><p>通过引入消费组的概念，我们已经能够在多实例的情况下，保障每个消息只被组内一个实例进行消费。通过上面对消费组参数设置后的实验，我们可以观察到，消费组并无法控制消息具体被哪个实例消费。也就是说，对于同一条消息，它多次到达之后可能是由不同的实例进行消费的。但是对于一些业务场景，就需要对于一些具有相同特征的消息每次都可以被同一个消费实例处理，比如：一些用于监控服务，为了统计某段时间内消息生产者发送的报告内容，监控服务需要在自身内容聚合这些数据，那么消息生产者可以为消息增加一个固有的特征ID来进行分区，使得拥有这些ID的消息每次都能被发送到一个特定的实例上实现累计统计的效果，否则这些数据就会分散到各个不同的节点导致监控结果不一致的情况。而分区概念的引入就是为了解决这样的问题：当生产者将消息数据发送给多个消费者实例时，保证拥有共同特征的消息数据始终是由同一个消费者实例接收和处理。</p><p><strong>Spring Cloud Stream为分区提供了通用的抽象实现，用来在消息中间件的上层实现分区处理，所以它对于消息中间件自身是否实现了消息分区并不关心，这使得Spring Cloud Stream为不具备分区功能的消息中间件也增加了分区功能扩展。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Bus</title>
    <link href="/2020/03/21/Spring-Cloud-Bus/"/>
    <url>/2020/03/21/Spring-Cloud-Bus/</url>
    
    <content type="html"><![CDATA[<p>使用Bus，可以非常容易地搭建器消息总线，同时实现了一些消息总线中的常用功能，比如，配合Config 实现应用配置动态更新。</p><h2 id="一、-消息代理"><a href="#一、-消息代理" class="headerlink" title="一、 消息代理"></a>一、 消息代理</h2><p>消息代理（message broker）是一种消息验证，传输，路由的架构模式。消息代理是一个中间件产品，它的核心是一个消息的路由程序，用来实现接收和分发消息，并根据设定好的消息处理流来转发给正确的应用。<br>常用场景：</p><ul><li>将消息路由到一个或多个目的地。</li><li>消息转化为其他的表现方式。</li><li>执行消息的聚集，消息的分解，并将结果发送到它们的目的地，然后重新组合响应返回给消息用户。</li><li>调用web服务来检索数据。</li><li>响应事件或错误。</li><li>使用发布-订阅模式来提供内容和基于主题的消息路由。</li></ul><p>spring cloud bus仅支持两款中间件产品：rabbitmq和kafka。</p><h2 id="二、-RabbitMQ实现消息总线"><a href="#二、-RabbitMQ实现消息总线" class="headerlink" title="二、 RabbitMQ实现消息总线"></a>二、 RabbitMQ实现消息总线</h2><p>RabbitMQ以AMQP协议实现，所以它可以支持多种操作系统，多种编程语言，几乎可以覆盖所有主流的企业级技术平台。在微服务架构消息中间件的选型中，它是一个非常适合且优秀的选择。因此，在spring cloud bus中包含了对rabbit的自动化默认配置。</p><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><ul><li>Broker：可以理解成消息队列服务器的实体，它是一个中间件应用，负责接收消息生产者的消息，然后将消息发送到消息接收者或者其他的Broker。</li><li>Exchange：消息交换机，是消息第一个到达的地方，消息通过它指定的路由规则，分发到不同的消息队列中去。</li><li>Queue：消息队列，消息通过发发送和路由之后最终到达的地方，到达Queue的消息即进入逻辑上等待消费的状态。每个消息都会被发送到一个或多个队列。</li><li>Binding：绑定，它的作用就是把Exchange和Queue按照路由规则绑定起来，也就是Exchange和Queue之间的虚拟连接。</li><li>Routing Key：路由关键字，Exchange根据这个关键字进行消息投递。</li><li>Virtual host：虚拟主机，它是对Broker的虚拟划分，将消费者，生产者和它们的依赖的AMQP相关结构进行隔离，一般都是为了安全考虑。比如，我们可以在一个Broker中设置多个虚拟主机，对不同用户进行权限的分离。</li><li>Connection：连接，代表生产者，消费者，Broker之间进行通信的物理网络。</li><li>Channel：消息通道，用于连接生产者和消费者的逻辑结构。在客户端的每个连接里，可建立多个Channel，每个Channel代表一个会话任务，通过- Channel可以隔离同一个连接中的不同交互内容。</li><li>Producer：消息生产者，制造消息并发送消息的程序。</li><li>Consumer：消息消费者，接收消息并处理消息的程序。</li></ul><p>消息投递到队列的整个过程大致如下：</p><ol><li>客户端连接到消息队列服务器，打开一个Channel（会话）。</li><li>客户端声明一个Exchange，并设置相关属性。</li><li>客户端声明一个Queue，并设置相关属性。</li><li>客户端使用Routing Key，在Exchange和Queue之间建立好绑定关系。</li><li>客户端投递消息到Exchange。</li><li>Exchange接收到消息后，根据消息的key和已经设置的Binding，进行消息路由，将消息投递到一个或多个Queue里。</li></ol><p>Exchange也有几种类型。</p><ol><li>Direct交互机：完全根据Key进行投递。比如，绑定时设置了Routing Key为abc，那么客户端提交的消息，只有设置了key为Routing Key的才会被投递到队列。</li><li>Topic交互机：对Key进行模式匹配后进行投递，可以使用符号#匹配一个或多个词，符号<em>匹配正好一个词。比如,abc.#匹配abc.def.ghi, abc.</em>只匹配abc.def.</li><li>Fanout交互机：不需要任何Key，它采用广播的模式，一个消息进来时，投递到与该交互机绑定的所有队列。</li></ol><p>Rabbitmq支持消息持久化，也就是将数据写在磁盘上。为了数据安全考虑，大多数情况下都会选择持久化。消息队列持久化包括三个部分：</p><ol><li>Exchange持久化，在声明时指定durable &gt;=1.</li><li>Queue持久化，在声明时指定durable =&gt; 1.</li><li>消息持久化，在投递时指定delivery_mode =&gt; 2(1是非持久化）。</li></ol><p>如果Exchange和Queue都是持久化，那么它们之间的Binding也是持久化的。如果Exchange和Queue两者之间有一个是持久化的，一个是非持久化的，就不允许建立绑定。</p><h4 id="2-安装使用"><a href="#2-安装使用" class="headerlink" title="2. 安装使用"></a>2. 安装使用</h4><h4 id="3-快速入门"><a href="#3-快速入门" class="headerlink" title="3. 快速入门"></a>3. 快速入门</h4><ul><li><p>引入依赖</p><div class="hljs"><pre><code class="hljs undefined">  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.5.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre></div></li><li><p>配置关于RabbitMq的连接和用户信息</p></li></ul><div class="hljs"><pre><code class="hljs undefined">spring:  application:    name: springboot-rabbitmq  rabbitmq:    host:     port: 5672    username:<span class="hljs-built_in"> user</span>    password: 123</code></pre></div><ul><li>创建生产者Sender</li></ul><p>通过注入AmqpTemplate接口的实例来实现消息的发送，AmqpTemplate接口定义了一套针对AMQP协议的基础操作，在spring boot中会根据配置来注入其具体的实现。</p><div class="hljs"><pre><code><pre><code class="hljs undefined"><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sender</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> AmqpTemplate amqpTemplate;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span></span>&#123;        String context = <span class="hljs-string">"hello "</span>+ LocalDateTime.now().toString();        System.out.println(<span class="hljs-string">"Sender: "</span>+context);        <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(<span class="hljs-string">"hello"</span>,context);    &#125;&#125;</code></pre></code></pre></div><ul><li><p>创建消息消费者Receiver。通过@RabbitListener注解定义该类对指定队列的监听，并用@RabbitHandler注解来指定对消息的处理方法（不同的消息格式，@RabbitHandler配置的方法的入参就不用，默认是byte[] 类型）。所以，该消费者实现了对hello队列的消费，消费操作作为输出消息的字符串内容。</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">@Component</span><span class="hljs-variable">@RabbitListener</span>(queues = <span class="hljs-string">"hello"</span>)public class Receiver &#123;        <span class="hljs-variable">@RabbitHandler</span>    public void process(String hello)&#123;        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">"Receiver: "</span>+hello);    &#125;    &#125;</code></pre></div></li><li><p>创建RabbitMQ的配置类RabbitConfig，用来配置队列，交换机，路由等高级信息。这里我们只配置队列，已完成一个基本的生产消费过程。</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">queue</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">"hello"</span>);    &#125;&#125;</code></pre></div></li><li><p>创建启动主类</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMQApplication</span> &#123;</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;        SpringApplication.run(RabbitMQApplication.<span class="hljs-keyword">class</span>,args);    &#125;&#125;</code></pre></div></li><li><p>创建单元测试类，用来调用消息生产</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">@RunWith</span>(SpringJUnit4ClassRunner.class)<span class="hljs-variable">@SpringApplicationConfiguration</span>(classes = RabbitMQApplication.class)public class RabbitMQApplicationTest &#123;        <span class="hljs-variable">@Autowired</span>    private Sender sender;        <span class="hljs-variable">@Test</span>    public void setSender() throws Exception&#123;        <span class="hljs-selector-tag">sender</span><span class="hljs-selector-class">.send</span>();    &#125;&#125;</code></pre></div></li><li><p>启动应用主类</p></li><li><p>查看控制面板，查看连接信息</p></li><li><p>运行单元测试类，发送消息</p></li></ul><h4 id="4-整合spring-cloud-bus"><a href="#4-整合spring-cloud-bus" class="headerlink" title="4. 整合spring cloud bus"></a>4. 整合spring cloud bus</h4><ul><li><p>在提供服务实例加入 依赖</p>  <div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>增加连接信息</p>  <div class="hljs"><pre><code class="hljs undefined">spring: rabbitmq:    host:     port: 5672    username:<span class="hljs-built_in"> user</span>    password: 123</code></pre></div></li><li></li><li><p>启动后，只要访问其中一个配置客户端，另一个也更新了。</p></li></ul><h4 id="5-原理分析"><a href="#5-原理分析" class="headerlink" title="5. 原理分析"></a>5. 原理分析</h4><p><img src="/images/bus.png" srcset="/img/loading.gif" alt></p><p><strong>使用git仓库的web hook进行消息总线的事件自动触发</strong></p><h4 id="6-指定刷新范围"><a href="#6-指定刷新范围" class="headerlink" title="6. 指定刷新范围"></a>6. 指定刷新范围</h4><p>/bus/refresh接口提供了一个destination参数，用于指定具体要刷新的应用程序。</p><div class="hljs"><pre><code class="hljs undefined">curl -X POST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">6061</span><span class="hljs-regexp">/bus/</span>refresh?destination=hello-service:<span class="hljs-number">6061</span>curl -X POST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">6061</span><span class="hljs-regexp">/bus/</span>refresh?destination=hello-service:**</code></pre></div><h4 id="7-架构优化"><a href="#7-架构优化" class="headerlink" title="7. 架构优化"></a>7. 架构优化</h4><p><img src="/images/bus2.png" srcset="/img/loading.gif" alt></p><ul><li><p>config-server-eureka服务，加入amqp依赖：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>yml配置</p></li></ul><div class="hljs"><pre><code class="hljs undefined">spring:   rabbitmq:    host:     port: 5672    username:<span class="hljs-built_in"> user</span>    password: 123</code></pre></div><ul><li><p>修改配置</p></li><li><p>curl 请求 配置服务，所有的服务客户端全部更新</p></li></ul><h2 id="三、-Kafka"><a href="#三、-Kafka" class="headerlink" title="三、 Kafka"></a>三、 Kafka</h2><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>Kafka是一个由LinkedIn开发的分布式消息系统，它于2011年初开源，现在由著名的Apache基金会维护与开发。Kafka使用Scala实现，被用作LinkedIn的活动流和运营数据处理的管道，现在也被诸多互联网企业广泛地用作为数据流管道和消息系统。</p><p>Kafka是基于消息发布/订阅模式实现的消息系统，其主要设计目标如下：</p><ul><li>消息持久化：以时间复杂度为O(1)的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间复杂度的访问性能。</li><li>高吞吐：在廉价的商用机器上也能支持单机每秒100K条以上的吞吐量</li><li>分布式：支持消息分区以及分布式消费，并保证分区内的消息顺序</li><li>跨平台：支持不同技术平台的客户端（如：Java、PHP、Python等）</li><li>实时性：支持实时数据处理和离线数据处理</li><li>伸缩性：支持水平扩展</li></ul><p>Kafka中涉及的一些基本概念：</p><ul><li>Broker：Kafka集群包含一个或多个服务器，这些服务器被称为Broker。</li><li>Topic：逻辑上同Rabbit的Exchange Queue队列相似，每条发布到Kafka集群的消息都必须有一个Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个Broker上，但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li><li>Partition：Partition是物理概念上的分区，为了提供系统吞吐率，在物理上每个Topic会分成一个或多个Partition，每个Partition对应一个文件夹（存储对应分区的消息内容和索引文件）。</li><li>Producer：消息生产者，负责生产消息并发送到Kafka Broker。</li><li>Consumer：消息消费者，向Kafka Broker读取消息并处理的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的组（可为每个Consumer指定属于一个组，若不指定则属于默认组），组可以用来实现一条消息被组内多个成员消费等功能。</li></ul><h4 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h4><p>在对Kafka有了一些基本了解之后，下面我们来尝试构建一个Kafka服务端，并体验一下基于Kafka的消息生产与消费。</p><ul><li><p>安装</p></li><li><p>测试</p><ul><li><p>启动Kafka，执行命令：kafka-server-start config/server.properties，该命令也需要指定Kafka配置文件的正确位置，如上命令中指向了解压目录包含的默认配置。若在测试时，使用外部集中环境的ZooKeeper的话，我们可以在该配置文件中通过zookeeper.connect参数来设置ZooKeeper的地址和端口，它默认会连接本地2181端口的ZooKeeper；如果需要设置多个ZooKeeper节点，可以为这个参数配置多个ZooKeeper地址，并用逗号分割。比如：zookeeper.connect=127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002。</p></li><li><p>创建Topic，执行命令：kafka-topics –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic test，通过该命令，创建一个名为“test”的Topic，该Topic包含一个分区一个Replica。在创建完成后，可以使用kafka-topics –list –zookeeper localhost:2181命令来查看当前的Topic。</p></li><li><p>创建消息生产者，执行命令：kafka-console-producer –broker-list localhost:9092 –topic test。kafka-console-producer命令可以启动Kafka基于命令行的消息生产客户端，启动后可以直接在控制台中输入消息来发送，控制台中的每一行数据都会被视为一条消息来发送。我们可以尝试输入几行消息，由于此时并没有消费者，所以这些输入的消息都会被阻塞在名为test的Topics中，直到有消费者将其消费掉位置。</p></li><li><p>创建消息消费者，执行命令：kafka-console-consumer –zookeeper localhost:2181 –topic test –from-beginning。kafka-console-consumer命令启动的是Kafka基于命令行的消息消费客户端，在启动之后，我们马上可以在控制台中看到输出了之前我们在消息生产客户端中发送的消息。我们可以再次打开之前的消息生产客户端来发送消息，并观察消费者这边对消息的输出来体验Kafka对消息的基础处理。</p></li></ul></li></ul><h4 id="3-整合Spring-Cloud-Bus"><a href="#3-整合Spring-Cloud-Bus" class="headerlink" title="3. 整合Spring Cloud Bus"></a>3. 整合Spring Cloud Bus</h4><ul><li>添加依赖<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li></ul><p><strong>如果我们在启动Kafka时均采用了默认配置，那么我们不需要再做任何其他配置就能在本地实现从RabbitMQ到Kafka的切换。我们可以尝试把刚刚搭建的ZooKeeper、Kafka启动起来，并将修改为spring-cloud-starter-bus-kafka模块的config-server和config-client启动起来。</strong><br>启动应用可看到对应topic 信息</p><ul><li>Kafka配置</li></ul><h2 id="四、深入理解"><a href="#四、深入理解" class="headerlink" title="四、深入理解"></a>四、深入理解</h2><p>Spring Cloud Bus 也采用了Spring 事件驱动模型。事件驱动模型也就是我们常说的观察者，或者发布-订阅模型；</p><h4 id="1-Spring的事件机制"><a href="#1-Spring的事件机制" class="headerlink" title="1. Spring的事件机制"></a>1. Spring的事件机制</h4><p>Spring的事件驱动模型由三部分组成：</p><ul><li>事件：ApplicationEvent，继承自JDK的EventObject，所有事件将继承它，并通过source得到事件源。</li><li>事件发布者：ApplicationEventPublisher及ApplicationEventMulticaster接口，使用这个接口，我们的Service就拥有了发布事件的能力。</li><li>事件订阅者：ApplicationListener，继承自JDK的EventListener，所有监听器将继承它。</li></ul><p>事件机制的实现需要三个部分,事件源,事件,事件监听器,在上面介绍的ApplicationEvent就相当于事件,ApplicationListener相当于事件监听器,这里的事件源说的就是applicaitonContext. ApplicationEventMulticaster 属于事件广播器,它的作用是把Applicationcontext发布的Event广播给所有的监听器.</p><ul><li><p>通过ApplicationEvent抽象类和ApplicationListener接口,可以实现ApplicationContext事件处理</p></li><li><p>监听器在处理Event时,通常会进行判断传入的Event是不是自己所想要处理的,使用instanceof关键字</p></li><li><p>ApplicationEventMulticaster事件广播器实现了监听器的注册,一般不需要我们实现,只需要显示的调用applicationcontext.publisherEvent方法即可</p></li></ul><h4 id="2-demo"><a href="#2-demo" class="headerlink" title="2. demo"></a>2. demo</h4><ul><li><p>发布者</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.zjn.cloud.eurekaserver;<span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationEvent;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPubisher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextAware</span> </span>&#123;    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;        <span class="hljs-keyword">this</span>.applicationContext=applicationContext;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(ApplicationEvent event)</span></span>&#123;        System.out.println(<span class="hljs-string">"into My Publisher's method"</span>);        applicationContext.publishEvent(event);    &#125;&#125;</code></pre></div></li><li><p>监听者</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.zjn.cloud.eurekaserver;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationEvent;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationListener;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyListener</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;        <span class="hljs-keyword">if</span>(event <span class="hljs-keyword">instanceof</span> MyEvent)&#123;            System.out.println(<span class="hljs-string">"into My Listener"</span>);            MyEvent myEvent=(MyEvent)event;            myEvent.print();        &#125;    &#125;&#125;</code></pre></div><ul><li><p>事件</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.zjn.cloud.eurekaserver;<span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-type">ApplicationEvent</span>;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ApplicationEvent</span> </span>&#123;    public <span class="hljs-type">MyEvent</span>(<span class="hljs-type">Object</span> source) &#123;        <span class="hljs-keyword">super</span>(source);        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">"my Event"</span>);    &#125;    public void print()&#123;        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">"hello spring event[MyEvent]"</span>);    &#125;&#125;</code></pre></div></li><li><p>测试类</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.zjn.cloud.eurekaserver;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTest</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;        ApplicationContext context = SpringApplication.run(EurekaServerApplication.class, args);<span class="hljs-comment">//        MyPubisher myPubisher = context.getBean(MyPubisher.class);</span>        MyPubisher myPubisher = <span class="hljs-keyword">new</span> <span class="hljs-type">MyPubisher</span>();        myPubisher.setApplicationContext(context);        myPubisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-type">MyEvent</span>(<span class="hljs-string">"1"</span>));    &#125;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Config</title>
    <link href="/2020/03/20/Spring-Cloud-Config/"/>
    <url>/2020/03/20/Spring-Cloud-Config/</url>
    
    <content type="html"><![CDATA[<p>默认采用Git来储存配置信息，所以使用Spring Cloud Config 构建服务配置就天然支持版本管理。</p><h2 id="一、-快速入门"><a href="#一、-快速入门" class="headerlink" title="一、 快速入门"></a>一、 快速入门</h2><ol><li>服务端配置</li></ol><ul><li><p>在pom.xml中添加相关依赖</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>在启动类上添加@EnableConfigServer注解来启用配置中心功能</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">@EnableConfigServer</span><span class="hljs-variable">@EnableDiscoveryClient</span><span class="hljs-variable">@SpringBootApplication</span>public class ConfigServerApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(ConfigServerApplication.class, args);    &#125;&#125;</code></pre></div><ul><li>在application.yml中进行配置</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">server:</span><span class="hljs-attr">port:</span> <span class="hljs-number">8901</span><span class="hljs-attr">spring:</span><span class="hljs-attr">application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">config-server</span><span class="hljs-attr">cloud:</span><span class="hljs-attr">    config:</span><span class="hljs-attr">    server:</span><span class="hljs-attr">        git:</span> <span class="hljs-comment">#配置存储配置信息的Git仓库</span><span class="hljs-attr">        uri:</span> <span class="hljs-attr">https://gitee.com/macrozheng/springcloud-config.git</span><span class="hljs-attr">        username:</span> <span class="hljs-string">macro</span><span class="hljs-attr">        password:</span> <span class="hljs-number">123456</span><span class="hljs-attr">        clone-on-start:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#开启启动时直接从git获取配置</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">client:</span><span class="hljs-attr">    service-url:</span><span class="hljs-attr">    defaultZone:</span> <span class="hljs-attr">http://localhost:8001/eureka/</span></code></pre></div><ol start="2"><li>配置规则详解</li></ol><p>配置完开启服务 可通过url 配置文件路由规则进行访问。例：<a href="http://localhost:8901/master/config-dev.yml" target="_blank" rel="noopener">http://localhost:8901/master/config-dev.yml</a></p><ol start="3"><li>客户端配置</li></ol><ul><li>在pom.xml中添加相关依赖</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ul><li>在yml中进行配置</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">9001</span><span class="hljs-attr">spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">config-client</span><span class="hljs-attr">  cloud:</span><span class="hljs-attr">    config:</span> <span class="hljs-comment">#Config客户端配置</span><span class="hljs-attr">      profile:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#启用配置后缀名称</span><span class="hljs-attr">      label:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#分支名称</span><span class="hljs-attr">      uri:</span> <span class="hljs-attr">http://localhost:8901</span> <span class="hljs-comment">#配置中心地址</span><span class="hljs-attr">      name:</span> <span class="hljs-string">config</span> <span class="hljs-comment">#配置文件名称</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">  client:</span><span class="hljs-attr">    service-url:</span><span class="hljs-attr">      defaultZone:</span> <span class="hljs-attr">http://localhost:8001/eureka/</span></code></pre></div><ul><li>添加ConfigClientController类用于获取配置<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigClientController</span> </span>&#123;    <span class="hljs-meta">@Value(<span class="hljs-meta-string">"<span class="hljs-subst">$&#123;config.info&#125;</span>"</span>)</span>    <span class="hljs-keyword">private</span> String configInfo;    <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/configInfo"</span>)</span>    <span class="hljs-keyword">public</span> String getConfigInfo() &#123;        <span class="hljs-keyword">return</span> configInfo;    &#125;&#125;</code></pre></div></li></ul><p>也可以通过env.getProperty 去获取。</p><h2 id="二、服务端详解"><a href="#二、服务端详解" class="headerlink" title="二、服务端详解"></a>二、服务端详解</h2><h4 id="1-Git-配置仓库"><a href="#1-Git-配置仓库" class="headerlink" title="1. Git 配置仓库"></a>1. Git 配置仓库</h4><p>可以指定账户密码访问网络地址，也可以通过file：// 前缀来设定本地文件地址。</p><p><strong>占位符配置URI</strong></p><p><strong>配置多个仓库</strong></p><p>有多个仓库，Config Server 会直接克隆第一个仓库的配置库，其他配置只有引用时候才会克隆到本地。</p><p><strong>子目录存储</strong></p><h4 id="2-Svn-配置仓库"><a href="#2-Svn-配置仓库" class="headerlink" title="2. Svn 配置仓库"></a>2. Svn 配置仓库</h4><h4 id="3-本地仓库"><a href="#3-本地仓库" class="headerlink" title="3. 本地仓库"></a>3. 本地仓库</h4><h4 id="4-本地文件系统"><a href="#4-本地文件系统" class="headerlink" title="4. 本地文件系统"></a>4. 本地文件系统</h4><p>指定文件路径进行配置</p><h4 id="5-健康检测"><a href="#5-健康检测" class="headerlink" title="5. 健康检测"></a>5. 健康检测</h4><p>spring-boot-actuator 模块的/health 进行健康检测，可以关闭。</p><h4 id="6-属性覆盖"><a href="#6-属性覆盖" class="headerlink" title="6. 属性覆盖"></a>6. 属性覆盖</h4><div class="hljs"><pre><code class="hljs undefined">spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.overrides</span><span class="hljs-selector-class">.name</span>=zjnspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.overrides</span><span class="hljs-selector-class">.from</span>=tj</code></pre></div><p>通过以上属性配置，不会被客户端修改，可以配置一些共同属性或是默认属性。</p><h4 id="7-安全保护"><a href="#7-安全保护" class="headerlink" title="7. 安全保护"></a>7. 安全保护</h4><p>增加spring-security的依赖进行安全保护。</p><div class="hljs"><pre><code class="hljs undefined">security<span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.name</span> =usersecurity<span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.passward</span> =<span class="hljs-number">123</span></code></pre></div><p>客户端不配置名字和密码将会返回401</p><div class="hljs"><pre><code class="hljs undefined">spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.ussername</span> =userspring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.passward</span> =<span class="hljs-number">123</span></code></pre></div><h4 id="8-加密解密"><a href="#8-加密解密" class="headerlink" title="8.加密解密"></a>8.加密解密</h4><h4 id="9-高可用配置"><a href="#9-高可用配置" class="headerlink" title="9.高可用配置"></a>9.高可用配置</h4><ul><li><p>传统模式：配置都指向git。读取Config 地址</p></li><li><p>服务模式：纳入Erueka的服务治理体系，把配置当成服务，通过配置中心获取配置信息。实现了高可用和自维护。</p></li></ul><h2 id="三、客户端详解"><a href="#三、客户端详解" class="headerlink" title="三、客户端详解"></a>三、客户端详解</h2><h4 id="1-URI-指定配置中心"><a href="#1-URI-指定配置中心" class="headerlink" title="1. URI 指定配置中心"></a>1. URI 指定配置中心</h4><h4 id="2-服务化配置中心"><a href="#2-服务化配置中心" class="headerlink" title="2. 服务化配置中心"></a>2. 服务化配置中心</h4><ul><li><p>服务端配置</p></li><li><p>客户端配置</p></li></ul><h4 id="3-失败快速响应与重试"><a href="#3-失败快速响应与重试" class="headerlink" title="3. 失败快速响应与重试"></a>3. 失败快速响应与重试</h4><p><code>spring.cloud.config.failFast =true</code><br>但是如果因为网络波动导致启动失败代价高，所以Config客户端提供了自动重试功能。添加 spring-retry依赖和 starter-aop，不需要做其他配置。</p><h4 id="4-获取远程配置"><a href="#4-获取远程配置" class="headerlink" title="4. 获取远程配置"></a>4. 获取远程配置</h4><p>{application} {profile} {label} 读取 对应yml 文件的变量值</p><h4 id="5-动态刷新配置"><a href="#5-动态刷新配置" class="headerlink" title="5. 动态刷新配置"></a>5. 动态刷新配置</h4><p>增加 actuator 依赖， 包含了/refresh 实现，通过POST 请求发送到 /refresh 地址，再次访问可以看到配置刷新。</p><p>但是 系统壮大后，维护刷新清单也是非常大的负担，Spring Cloud Bus 来实现消息总线方式进行配置变更通知，并完成批量配置更新。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Zuul</title>
    <link href="/2020/03/19/Spring-Cloud-Zuul/"/>
    <url>/2020/03/19/Spring-Cloud-Zuul/</url>
    
    <content type="html"><![CDATA[<p>Spring Cloud Zuul 是Spring Cloud Netflix 子项目的核心组件之一，为了解决减轻维护路由规则和服务实例的而诞生的。可以作为微服务架构中的API网关使用，支持动态路由与过滤功能。</p><h2 id="一、快速入门"><a href="#一、快速入门" class="headerlink" title="一、快速入门"></a>一、快速入门</h2><ol><li>构建网关</li></ol><ul><li><p>添加依赖</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>在application.yml中进行配置</p></li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">8801</span><span class="hljs-attr">spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">zuul-proxy</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">  client:</span><span class="hljs-attr">    register-with-eureka:</span> <span class="hljs-literal">true</span><span class="hljs-attr">    fetch-registry:</span> <span class="hljs-literal">true</span><span class="hljs-attr">    service-url:</span><span class="hljs-attr">      defaultZone:</span> <span class="hljs-attr">http://localhost:8001/eureka/</span></code></pre></div><ul><li>在启动类上添加@EnableZuulProxy注解来启用Zuul的API网关功能</li></ul><ol start="2"><li>请求路由</li></ol><ul><li>传统路由方式<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">zuul:</span><span class="hljs-symbol">  routes:</span>      api-a-url:<span class="hljs-symbol">      path:</span> <span class="hljs-meta-keyword">/api-a-url/</span>**<span class="hljs-symbol">    url:</span><span class="hljs-symbol">      url:</span> http:<span class="hljs-comment">//localhost:8080/</span></code></pre></div></li></ul><p>所有规则满足/api-a-url/ 都会打到<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 。<br><strong>其中api-a-url 为路由名称，可自定义，一组path、url映射关系路由名要相同。</strong></p><ul><li>面向服务的路由</li></ul><p>与Erueka 相结合，将自己注册成服务，实现path映射，再从服务中挑选实例进行请求转发的完全路由机制。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">zuul:</span><span class="hljs-symbol">  routes:</span>      api-a-url:<span class="hljs-symbol">      path:</span> <span class="hljs-meta-keyword">/api-a-url/</span>**<span class="hljs-symbol">    url:</span><span class="hljs-symbol">      serviceId:</span> feign-consumer</code></pre></div><ol start="3"><li>请求过滤</li></ol><p>对服务提供者增加访问权限，继承ZuulFilter 重写如下4个方法，实现过滤器：</p><ul><li>filterType：过滤器类型，决定过滤器在哪个生命周期执行，默认pre，代表请求前执行。</li><li>filterOrder：执行顺序，一个请求村爱多个过滤器，需要该方法返回值，0最大。</li><li>shouldFilter： 是否执行该过滤器，默认true；</li><li>run：具体过滤逻辑</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@Component</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PreLogFilter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ZuulFilter</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-type">LOGGER</span> = <span class="hljs-type">LoggerFactory</span>.getLogger(<span class="hljs-keyword">this</span>.getClass());    <span class="hljs-comment">/**     * 过滤器类型，有pre、routing、post、error四种。     */</span>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">String</span> filterType() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"pre"</span>;    &#125;    <span class="hljs-comment">/**     * 过滤器执行顺序，数值越小优先级越高。     */</span>    <span class="hljs-meta">@Override</span>    public int filterOrder() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-comment">/**     * 是否进行过滤，返回true会执行过滤。     */</span>    <span class="hljs-meta">@Override</span>    public boolean shouldFilter() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;    &#125;    <span class="hljs-comment">/**     * 自定义的过滤器逻辑，当shouldFilter()返回true时会执行。     */</span>    <span class="hljs-meta">@Override</span>    public <span class="hljs-type">Object</span> run() <span class="hljs-keyword">throws</span> <span class="hljs-type">ZuulException</span> &#123;        <span class="hljs-type">RequestContext</span> requestContext = <span class="hljs-type">RequestContext</span>.getCurrentContext();        <span class="hljs-type">HttpServletRequest</span> request = requestContext.getRequest();        <span class="hljs-type">String</span> host = request.getRemoteHost();        <span class="hljs-type">String</span> method = request.getMethod();        <span class="hljs-type">String</span> uri = request.getRequestURI();        <span class="hljs-type">LOGGER</span>.info(<span class="hljs-string">"Remote host:&#123;&#125;,method:&#123;&#125;,uri:&#123;&#125;"</span>, host, method, uri);        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;&#125;</code></pre></div><p>最后在主方法加入如下代码</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable">@EnableZuulProxy</span><span class="hljs-variable">@SpringBootApplication</span>public class ApiGatewayApplication &#123;    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(ApiGatewayApplication.class, args);    &#125;        <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">PreLogFilter</span> <span class="hljs-selector-tag">preLogFilter</span>() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">PreLogFilter</span>();    &#125;&#125;</code></pre></div><p>到这里，快速入门示例完成了。通过对Spring Cloud Zuul 两个核心功能介绍，总结如下：</p><ul><li>系统统一入口，屏蔽内部微服务细节</li><li>与服务治理框架结合，实现自动化服务实例维护以及负载均衡的路由规则转发。</li><li>实现接口权限和微服务业务解耦。</li><li>通过网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证微服务无状态性。降低测试难度，让服务本身关注业务处理。</li></ul><h2 id="二、路由详解"><a href="#二、路由详解" class="headerlink" title="二、路由详解"></a>二、路由详解</h2><h4 id="1-传统路由配置"><a href="#1-传统路由配置" class="headerlink" title="1. 传统路由配置"></a>1. 传统路由配置</h4><ul><li>单实例配置</li><li>多实例配置：（需要实现负载均衡策略 Ribbon）</li></ul><h4 id="2-服务路由配置"><a href="#2-服务路由配置" class="headerlink" title="2. 服务路由配置"></a>2. 服务路由配置</h4><p>结合Eureka 面向服务路由，可以把API网关看作Eureka服务治理的普通微服务。将自己注册到服务中心，也会从中心获取所有实例。</p><h4 id="3-服务路由默认规则"><a href="#3-服务路由默认规则" class="headerlink" title="3. 服务路由默认规则"></a>3. 服务路由默认规则</h4><p>默认 serviceId 配置，Eureka 上的服务会被Zuul 自动的创建映射关系来进行路由，会使得一些我们不希望对外开放的服务也可能被外部访问到。这时可以使用<div class="hljs"><pre><code class="hljs zuul.ignored-services">#### 4. 自定义路由映射规则对于兼容不同客户端，一般使用开闭原则进行设计开发。增加@Bean 书写正则匹配类PatternServiceRouteMapper ，没有匹配则使用默认路由映射规则。即采用完整服务名作为前缀表达式。#### 5.路径匹配根据历史配置文件中路由规则依次加入，规则由LinkedHashMap 保存，通过线性遍历匹配。#### 6. 路由前缀```zuul.prefix=/api</code></pre></div></p><p><strong>在 Brixton.SR7 和 Camden.SR3 版本配置前缀并设置包含前缀路由规则会有bug</strong></p><h4 id="7-本地跳转"><a href="#7-本地跳转" class="headerlink" title="7. 本地跳转"></a>7. 本地跳转</h4><div class="hljs"><pre><code class="hljs zuul.routes.api-b.url">#### 8. Cookie 与头信息默认，Zuul在请求路由时，会过滤掉HTTP请求头信息中的一些敏感信息，防止他们被产地到下游的外部服务器。默认敏感头信息通过```zuul.sensitiveHeaders```参数定义，包括Cookie、Set-Cookie、Authorization是不会传递的。不推荐使用```zuul.sensitiveHeaders =```全局覆盖默认值，破坏了默认设置的用意，以下有两种方法：</code></pre></div><p>// 一、对指定路由开启自定义敏感头<br>zuul.routes.<router>.customSensitiveHeaders =true</router></p><div class="hljs"><pre><code class="hljs undefined"></code></pre></div><p>// 二、将指定路由敏感头设置为空<br>zuul.routes.<router>.sensitiveHeaders =true</router></p><div class="hljs"><pre><code class="hljs undefined">范围更小，不引起其他服务泄露。**重定向问题**增加```zuul.addHostHeader=<span class="hljs-literal">true</span>``` 配置，以标识最初的服务请求地址。防止暴露具体的web应用实例地址。#### <span class="hljs-number">9</span>.Hystrix 和 Ribbon 支持使用 serviceId 组合进行配置，可以保证API网关的健壮和稳定，也能够使用Ribbon和Hystrix。在使用Zuul 路由转发超时，只要超时时间小于Hystrix 会触发重试。通过</code></pre></div><p>zuul.retrybale=false<br>zuul.routes.<route>.retryable =fales</route></p><div class="hljs"><pre><code>关闭重试。## 三、过滤器详解#### 1. 过滤器#### 2. 核心过滤器- pre 过滤器- route 过滤器- post 过滤器![](/images/filter.png)#### 3.异常处理**errorFilter**用到error类型的过滤器，在请求周期饿pre、route、post 阶段有异常都会进入error阶段，创建error类来捕获，这些信息就可以被SendErrorFilter 捕获并组织成消息返回客户端。**不足与优化****禁用过滤器**## 四、 动态加载从git 配置 config 让 api 路由规则 动态加载。过滤器也是同理。API的网关服务的动态过滤器功能可以帮助我们增强API网关的持续服务能力。另外动态过滤器无法直接注入容器使用。</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Feign</title>
    <link href="/2020/03/19/Spring-Cloud-Feign/"/>
    <url>/2020/03/19/Spring-Cloud-Feign/</url>
    
    <content type="html"><![CDATA[<p>Feign是声明式的服务调用工具，我们只需创建一个接口并用注解的方式来配置它，就可以实现对某个服务接口的调用，简化了直接使用RestTemplate来调用服务接口的开发量。Feign具备可插拔的注解支持，同时支持Feign注解、JAX-RS注解及SpringMvc注解。当使用Feign时，Spring Cloud集成了Ribbon和Eureka以提供负载均衡的服务调用及基于Hystrix的服务容错保护功能。</p><h2 id="一、-快速入门"><a href="#一、-快速入门" class="headerlink" title="一、 快速入门"></a>一、 快速入门</h2><ol><li><p>在pom.xml中添加相关依赖</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div></li><li><p>在启动类上添加@EnableFeignClients注解来启用Feign的客户端功能</p></li><li><p>定义 HelloServer接口，通过@FeignClient注解实现了一个Feign客户端，其中的value为user-service表示这是对user-service服务的接口调用客户端。然后使用Spring MVC 的注解 来绑定具体该服务提供的Rest接口。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@FeignClient(value = <span class="hljs-meta-string">"hello-service"</span>)</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;         <span class="hljs-meta">@GetMapping(<span class="hljs-meta-string">"/hello"</span>)</span>    String hello();&#125;</code></pre></div></li></ol><p><strong>服务名不区分大小写。</strong></p><ol start="4"><li>添加HelloController调用HelloService实现服务调用。</li></ol><div class="hljs"><pre><code class="hljs undefined"> <span class="hljs-variable">@RestController</span><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)public class HelloController &#123;    <span class="hljs-variable">@Autowired</span>    private HelloService helloService;    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">"/feign-comsumer"</span>)    public String helloConsumer() &#123;        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">helloService</span><span class="hljs-selector-class">.hello</span>();    &#125;&#125;</code></pre></div><ol start="5"><li>在application.yml中进行配置</li></ol><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">server:</span><span class="hljs-attr">  port:</span> <span class="hljs-number">9001</span><span class="hljs-attr">spring:</span><span class="hljs-attr">  application:</span><span class="hljs-attr">    name:</span> <span class="hljs-string">feign-service</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">  client:</span><span class="hljs-attr">    register-with-eureka:</span> <span class="hljs-literal">true</span><span class="hljs-attr">    fetch-registry:</span> <span class="hljs-literal">true</span><span class="hljs-attr">    service-url:</span><span class="hljs-attr">      defaultZone:</span> <span class="hljs-attr">http://localhost:8001/eureka/</span></code></pre></div><h2 id="二、-参数绑定"><a href="#二、-参数绑定" class="headerlink" title="二、 参数绑定"></a>二、 参数绑定</h2><div class="hljs"><pre><code class="hljs undefined"> <span class="hljs-variable">@FeignClient</span>(value = <span class="hljs-string">"hello-service"</span>)public interface UserService &#123;         <span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">"/hello"</span>)    String hello(<span class="hljs-variable">@RequestParam</span> String name);&#125;</code></pre></div><h2 id="三、-继承特性"><a href="#三、-继承特性" class="headerlink" title="三、 继承特性"></a>三、 继承特性</h2><p>通过继承可以将注解的接口 传递过来，不需要重复注解。<br> 缺点就是建立依赖，接口一变就对项目造成影响，所以尽可能在开发评审严格遵守开闭原则。</p><h2 id="四、-Ribbon-配置"><a href="#四、-Ribbon-配置" class="headerlink" title="四、 Ribbon 配置"></a>四、 Ribbon 配置</h2><h2 id="五、-Hystrix-配置"><a href="#五、-Hystrix-配置" class="headerlink" title="五、 Hystrix 配置"></a>五、 Hystrix 配置</h2><p>开启Hystrix功能</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">feign:</span><span class="hljs-attr">  hystrix:</span><span class="hljs-attr">    enabled:</span> <span class="hljs-literal">true</span> <span class="hljs-comment">#在Feign中开启Hystrix</span></code></pre></div><p>接口绑定@FeginClient 实现服务降级业务处理</p><h2 id="六、-其他配置"><a href="#六、-其他配置" class="headerlink" title="六、 其他配置"></a>六、 其他配置</h2><p>请求压缩 ，支持对请求与响应进行GZIP 压缩，以减少性能损耗。</p><h2 id="七、-日志配置"><a href="#七、-日志配置" class="headerlink" title="七、 日志配置"></a>七、 日志配置</h2><ol><li><p>yml 配置</p><div class="hljs"><pre><code class="hljs undefined">logging:  level:    com<span class="hljs-selector-class">.macro</span><span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.service</span><span class="hljs-selector-class">.UserService</span>: debug</code></pre></div></li><li><p>由于默认配置是 NONE。所以在应用主类中直接加入 Logger.Level 的Bean 创建也可以实现配置类。</p></li></ol><div class="hljs"><pre><code class="hljs undefined"> <span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;    <span class="hljs-meta">@Bean</span>    Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> Logger.Level.FULL;    &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Hystrix</title>
    <link href="/2020/03/19/Spring-Cloud-Hystrix/"/>
    <url>/2020/03/19/Spring-Cloud-Hystrix/</url>
    
    <content type="html"><![CDATA[<p>类似熔断保险丝，当服务发生故障，向调用方返回一个错误响应，而不是长时间等待。</p><h2 id="一、-快速入门"><a href="#一、-快速入门" class="headerlink" title="一、 快速入门"></a>一、 快速入门</h2><ol><li>在 ribbon-consumer 引入</li></ol><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre></div><ol start="2"><li>主类 添加 @EnableCircuitBreaker</li></ol><p><strong>也可以使用 @SpringCloudApplication 该注解包含服务发现以及断路器。</strong></p><ol start="3"><li><p>在Service中添加调用方法与服务降级方法，方法上需要添加@HystrixCommand注解</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@HystrixCommand(fallbackMethod = <span class="hljs-meta-string">"getDefaultUser"</span>)</span><span class="hljs-keyword">public</span> CommonResult getUser(<span class="hljs-built_in">Long</span> id) &#123;    <span class="hljs-keyword">return</span> restTemplate.getForObject(userServiceUrl + <span class="hljs-string">"/user/&#123;1&#125;"</span>, CommonResult.<span class="hljs-keyword">class</span>, id);&#125;<span class="hljs-keyword">public</span> CommonResult getDefaultUser(<span class="hljs-meta">@PathVariable</span> <span class="hljs-built_in">Long</span> id) &#123;    User defaultUser = new User(-<span class="hljs-number">1L</span>, <span class="hljs-string">"defaultUser"</span>, <span class="hljs-string">"123456"</span>);    <span class="hljs-keyword">return</span> new CommonResult&lt;&gt;(defaultUser);&#125;</code></pre></div></li><li><p>模拟服务提供方故障，触发熔断请求，则会 fallbackMethod。</p></li></ol><h2 id="二、-原理分析"><a href="#二、-原理分析" class="headerlink" title="二、 原理分析"></a>二、 原理分析</h2><ol><li>创建HystrixCommand 或 HystrixObservableCommand对象</li><li>命令模式</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Ribbon</title>
    <link href="/2020/03/17/Spring-Cloud-Ribbon/"/>
    <url>/2020/03/17/Spring-Cloud-Ribbon/</url>
    
    <content type="html"><![CDATA[<p>Spring Cloud Ribbon 是一个基于HTTP和TCP的客户端负载均衡工具，基于Netflix Ribbon 实现。 它只是一个工具类框架，不像服务注册中心、配置中心、API网关独立部署。因为微服务间的调用，API网关的请求转发等内容,都通过Ribbon 实现。包括Feign。</p><h2 id="一、-客户端负载均衡"><a href="#一、-客户端负载均衡" class="headerlink" title="一、 客户端负载均衡"></a>一、 客户端负载均衡</h2><p>不论是硬件负载均衡设备还是软件负载均衡模块都会维护一个服务可用清单，通过心跳模式来检测剔除故障的服务端节点以保障清单中都是可以正常访问的服务端节点。当客户端发送请求到负载均和的设备时候，该设备会按某种算法（线性轮询，按权重负载、按流量负载等），从清单中取出地址，进行转发。</p><p>通过Spring Cloud Ribbon 自动化配置整合，在微服务客户端使用负载均衡调用非常简单：</p><ul><li>服务提供者启动多个实例注册到一个注册中心，或者多个相关联的。</li><li>消费者直接调用被@LoadBalanced修饰过的RsetTemplate 来实现面向服务的接口调用。</li></ul><h2 id="二、-RsetTemplate详解"><a href="#二、-RsetTemplate详解" class="headerlink" title="二、 RsetTemplate详解"></a>二、 RsetTemplate详解</h2><p>RsetTemplate会使Ribbon自动化配置，同时通过@LoadBalanced实现负载均衡。</p><h4 id="1-GET-请求"><a href="#1-GET-请求" class="headerlink" title="1. GET 请求"></a>1. GET 请求</h4><ul><li><p>getForEntity 返回的是ResponseEntity,该对象是Spring 对HTTP请求响应的封装，储存了HTTP重要元素，如状态码，headers和body对象。有三种重载方法。</p></li><li><p>getForObject 对getForEntity进一步封装，将body进行对象转换。</p></li></ul><h4 id="2-POST请求"><a href="#2-POST请求" class="headerlink" title="2. POST请求"></a>2. POST请求</h4><ul><li>postForEntity 比 getForEntity 多个第二个参数 Object request 可以是 HttpEntity 也可以是普通对象。</li><li>postForObject 与 getForObject 相似</li></ul><h4 id="3-PUT请求"><a href="#3-PUT请求" class="headerlink" title="3. PUT请求"></a>3. PUT请求</h4><p>为void 类型，没返回参数，其他与post 一致。</p><h4 id="4-DELETE请求"><a href="#4-DELETE请求" class="headerlink" title="4. DELETE请求"></a>4. DELETE请求</h4><p>无request 参数，直接参数绑定 url 删除。</p><h2 id="三、-源码分析"><a href="#三、-源码分析" class="headerlink" title="三、 源码分析"></a>三、 源码分析</h2><p>整个流程如下：</p><p>通过LoadBalancerInterceptor 拦截器对RestTemplate的请求进行拦截，并利用Spring Cloud 的负载均衡器 LoadBalancerClient 将以逻辑服务名为host的URI转换称为具体的服务实例地址。用ribbon实现负载均衡器的时候，实际使用Ribbon定义的ILoadBalancer 接口的实现，BaseLoadBalancer类实现理基础的负载均衡，DynamicServerListLoadBalancer 和 ZoneAwareLoadBalancer 在负载均衡的策略上做了一些扩展功能。而RibbonClientConfiguration 配置类 默认采用ZoneAwareLoadBalancer 里面 chooseServer 获取了负载均衡策略分配到服务实例对象后，使用该对象调回通过LoadBalancerInterceptor拦截器的apply 像具体实例发起请求。</p><p>流程图如下：</p><p><img src="/images/ribbon_flow.png" srcset="/img/loading.gif" alt></p><h4 id="1-负载均衡器"><a href="#1-负载均衡器" class="headerlink" title="1. 负载均衡器"></a>1. 负载均衡器</h4><p><strong>AbstractLoadBalancer</strong></p><p> 是 ILoadBalancer 接口的抽象实现。里面定义了服务分组枚举类：</p><ul><li>All ： 所有服务实例</li><li>STATUS_UP ：正常实例</li><li>STATUS_NOT_UP ：不正常实例</li></ul><p><strong>BaseLoadBalancer</strong><br>是AbstractLoadBalancer基础实现类</p><p><strong>DynamicServerListLoadBalancer</strong></p><p>继承于 BaseLoadBalancer，对负载均衡扩展，实现了服务实例清单汇总动态更新的能力;还有对服务清单过滤功能。<br>ServerList<br>因为负载均衡需要实现服务的动态更新，所以Ribbon与Eureka 整合后从 Eureka Server 获取服务实例清单。<br>ServerListupdater<br>然后以定时任务的方式进行服务列表的更新。<br>ServerListFilter</p><p><strong>ZoneAwareLoadBalancer</strong></p><p>继承DynamicServerListLoadBalancer 对其扩展，所以依然会使用BaseLoadBalancer里的RoundRobinRule规则，以线性轮询的方式调用服务实例，该算法没有区域概念，所以会把所有的实例视为一个Zone来看待，这样周期性的跨区域访问会产生更高的延迟，所以多区域会有一定性能问题。<br>ZoneAwareLoadBalancer 就是解决这样的问题。</p><p>setServerListForZones 设置每一个Zone 对应一个ZoneStats，储存每个Zone 的一些状态和同级信息。创建一个ConcurrentHashMap()类型的balancers对象，储存每个Zone 对应的负载均衡器。当Zone区域个数大于1 时候才会执行这里的选择策略 ，否侧还是父类的实现。</p><h4 id="2-负载均衡策略"><a href="#2-负载均衡策略" class="headerlink" title="2. 负载均衡策略"></a>2. 负载均衡策略</h4><p><strong>RandomRule</strong></p><p>随机选取，如果出现死循环获取不到，有可能存在并发bug</p><p><strong>RoundRobinRule</strong></p><p>和 RandomRule 类似，增加了计数，如果选择不到server 超过10次，就会结束尝试，打印警告。</p><p><strong>RetryRule</strong></p><p>顾名思义，具备重试机制，内部定义了RoundRobinRule ，如果取不到就设置尝试结束的时间为阈值。</p><p><strong>WeightedResponseTimeRule</strong></p><p>是 RandomRule的扩展，增加根据实例运行情况计算权重，并根据权重来挑选实例，达到更优分配效果。实现有3个核心内容：</p><ul><li><p>定时任务 ：通过定时任务计算权重，默认30秒一次</p></li><li><p>权重计算</p><ul><li><p>根据LoadBalancerStats 记录的统计信息，累加所有实例的平均响应时间，得到总平均响应时间totalResponseTime，该值会用于后续计算。</p></li><li><p>为实例逐一计算权重，规则是 weightSoFar + totalResponseTime - 实例的平均响应时间，weightSoFar初始为0，每次累加到此，供下一次计算使用。</p><p>权重区间越大，被选中概率越大。</p></li></ul></li><li><p>实例选择</p><ul><li>生成 [0,最大权重值] 的随机数</li><li>遍历权重列表，比较随机数，去选择区间。</li></ul></li></ul><p><strong>ClientConfigEnabledRoundRobinRule</strong></p><p>类似RoundRobinRule，比RoundRobinRule 高级。</p><p><strong>BestAvailableRule</strong></p><p>继承ClientConfigEnabledRoundRobinRule，会过滤掉故障实例，并找出并发请求数最小的一个，该策略选出最空闲的实例。localBalancerStats 为空时候，该策略是无法执行的。所以采用父级轮询。</p><p><strong>PredicateBaseRule</strong></p><p>先过滤清单，再轮询选择。</p><p><strong>AvaliabilityFilteringRule</strong></p><p>继承PredicateBaseRule，过滤实例两项内容：</p><ul><li>是否故障，即断路器是否生效已断开。</li><li>实例并发大于阈值。</li></ul><p>只要有一个满足apply就返回false。</p><p>除了实现上面的过滤方法外，对choose策略也改进优化，所以父类只是一个备选。优化策略为：先过滤选择，不满足选择下一个，当这个过程重复了10次还是没有符合的要求实例，就采用父类实现方案。<br><strong>通过线性抽样的方式直接尝试寻找可用且空闲的实例，优化了父类每次都要遍历所有实例的开销。</strong></p><p><strong>ZoneAvoidanceRule</strong></p><p>也是PredicateBaseRule 具体实现类，使用组合过滤条件，定义了一个主过滤条件，以及一组次过滤条件列表，次条件列表用List存储。可按顺序执行。</p><h2 id="三、配置详解"><a href="#三、配置详解" class="headerlink" title="三、配置详解"></a>三、配置详解</h2><h4 id="1-自动化配置"><a href="#1-自动化配置" class="headerlink" title="1. 自动化配置"></a>1. 自动化配置</h4><p>自动化默认配置解决选择策略的痛点。</p><h4 id="2-参数配置"><a href="#2-参数配置" class="headerlink" title="2. 参数配置"></a>2. 参数配置</h4><p>ribbon.ConnectTimeOut=250<br>如果没有服务治理的框架，需要指定具体的实例清单。</p><h4 id="3-与Eureka-结合"><a href="#3-与Eureka-结合" class="headerlink" title="3. 与Eureka 结合"></a>3. 与Eureka 结合</h4><p>Spring Cloud 的应用同时引入 Spring Cloud Ribbon 和 Spring Cloud Eureka 依赖时，会触发Eureka 中实现的对Ribbon 的自动化配置。与Eureka结合，我们的配置更加简单。Eureka会维护实例清单。此外，由于Spring Cloud Ribbon 默认实现了区域亲和策略，我们可以通过Erueka 实例元数据配置不同区域。以作为跨区域的容错机制。通过 ribbon.erueka.enabled =false 来金融erueka 和ribbon 结合。</p><h4 id="4-重试机制"><a href="#4-重试机制" class="headerlink" title="4. 重试机制"></a>4. 重试机制</h4><p>Eureka 强调 CAP 中的 AP， <strong>CAP定理（C- 数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个）；</strong> 即可用性和容错性。 ZooKeeper是个CP，这就是Eureka与ZooKeeper最大的区别。牺牲一致性，换取容错性，宁愿接收故障实例，也不愿意丢下健康实例。 例如，服务中心发生故障断开时候，所有服务实例无法维持续约心跳，强调AP的服务会把所有服务剔除，而Eureka 在15分钟内超过85%的客户端节点都没有正常的心跳触发保护机制，注册中心会保护所有节点，实现服务间进行互相调用。保证正常服务消费。</p><p>由于Eureka 在可用性和一致性的取舍，引起服务调用故障，我们为了增强这类问题的容错，增加重试机制，Spring Cloud 整合了Spring Retry 来增强 RestTemplate 重试能力。</p><p><code>spring.cloud.loadbalancer.retry.enabled</code>开启重试机制，默认关闭。<br>配置相关参数后，遇到故障实例会重试，（次数由MaxAutoRetries配置），还不行，换个实例访问，再不行在换，（次数由MaxAutoRetriesNextServer配置）再不行 返回失败信息。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud 简介 &amp; Spring Boot 快速理解使用</title>
    <link href="/2020/03/17/Spring-Cloud-%E7%AE%80%E4%BB%8B-Spring-Boot-%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/03/17/Spring-Cloud-%E7%AE%80%E4%BB%8B-Spring-Boot-%E5%BF%AB%E9%80%9F%E7%90%86%E8%A7%A3%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>（引用 Spring Cloud 微服务实战）</p><h1 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h1><h2 id="1-什么是微服务架构"><a href="#1-什么是微服务架构" class="headerlink" title="1. 什么是微服务架构"></a>1. 什么是微服务架构</h2><p>微服务是架构上的一种风格，服务之间通过HTTP的 RESTfu API 进行通信。 被拆分的小型服务都围绕着系统中的耦合高的业务进行构建。每个服务独立维护数据存储、业务、自动化测试以及独立部署。有了轻量级通讯协议，可以使用不同语言编写。</p><h4 id="1-1-与单体应用的区别"><a href="#1-1-与单体应用的区别" class="headerlink" title="1.1 与单体应用的区别"></a>1.1 与单体应用的区别</h4><p>由于业务的扩展，单体应用变的臃肿。由于单体应用部署在一个进程，修改一处，牵扯所有应用。由此微服务诞生了。</p><h4 id="1-2-实施微服务"><a href="#1-2-实施微服务" class="headerlink" title="1.2 实施微服务"></a>1.2 实施微服务</h4><ol><li>微服务带来的问题</li></ol><ul><li>运维需要更多自动化</li><li>接口需要一致性</li><li>分布式更加复杂 如：网络延迟、分布式事务、异步消息等。</li></ul><ol start="2"><li><p>服务组件化，由于服务拆分，只需更换服务地址就能升级PC计算能力。</p></li><li><p>按业务拆分团队，团队边界变的更加清晰。</p></li><li><p>以做产品的态度去对待业务，而不是项目</p></li></ol><h5 id="智能端点与哑管道"><a href="#智能端点与哑管道" class="headerlink" title="智能端点与哑管道"></a>智能端点与哑管道</h5><p>单体应用直接通过函数调用交互协作，微服务使用RPC调用，导致微服务之间产生繁琐的通信，使得系统表现更糟糕，所以我们要更粗粒度的通信协议。通常以2种服务讨论方式：</p><ul><li>HTTP 的RESTful API 或轻量级的消息发送协议。</li><li>通过在在轻量的消息总线上传递消息，如 RabbitMQ 等一些提供可靠异步交换中间件。</li></ul><h5 id="去中心化治理"><a href="#去中心化治理" class="headerlink" title="去中心化治理"></a>去中心化治理</h5><p>每一个技术平台都有短板，针对不用的业务选择不同的技术平台，不要杀鸡用牛刀。<strong>不是每个问题都是钉子，不是每个解决方案都是锤子</strong></p><h5 id="去中心化管理数据"><a href="#去中心化管理数据" class="headerlink" title="去中心化管理数据"></a>去中心化管理数据</h5><p>强调 “无事务”调用，分布式事务本身难度就非常大，若过程出现错误，通过补偿机制来进行处理，使得错误数据来达到最终一致性。</p><h5 id="基础设施自动化"><a href="#基础设施自动化" class="headerlink" title="基础设施自动化"></a>基础设施自动化</h5><p>自动化部署，自动化测试。要不然多个容器配置 发布上线，会是噩梦。</p><h5 id="容错设计"><a href="#容错设计" class="headerlink" title="容错设计"></a>容错设计</h5><p>A 调用 B ，B 调用 C，有一个故障，就会故障蔓延。 要快速通过每个容器的事实监控和日志去找到问题所在。如：服务状态、吞吐量、网络延迟等</p><h5 id="演进式设计"><a href="#演进式设计" class="headerlink" title="演进式设计"></a>演进式设计</h5><p>设计微服务，成本很大，初期经验不足可以先讲单体应用经常变动或者时间效应高的拆分微服务处理。将稳定不变的东西去形成一个核心的服务存储与整个架构之中。</p><h2 id="2-为什选择Spring-Cloud"><a href="#2-为什选择Spring-Cloud" class="headerlink" title="2 为什选择Spring Cloud"></a>2 为什选择Spring Cloud</h2><p>业内贡献出的微服务解决方案为了弥补各自公司拆分后的问题而诞生的。而使用Spring Cloud 是一个整合，综合性解决框架。况且有Spring 强大背景，和社区活跃度，是一个标准解决方案。</p><h4 id="2-1-Spring-Cloud-简介"><a href="#2-1-Spring-Cloud-简介" class="headerlink" title="2.1 Spring Cloud 简介"></a>2.1 Spring Cloud 简介</h4><p>它涉及 配置管理、服务治理、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。</p><p>包含如下子项目：</p><ul><li><p>Spring Cloud Config： 配置管理工具 ，支持使用Git 存储配置内容。</p></li><li><p>Spring Cloud Netflix： 核心组件</p><ul><li>Eureka ：服务治理组件，包含服务注册中心、服务注册与服务发现机制的实现。</li><li>Hystrix ：容错管理组件，实现断路器模式，帮助服务依赖出现的延迟和为故障提供的强大容错能力。</li><li>Ribbon ：负载均衡的服务调用组件。</li></ul></li></ul><p>剩下还有很多组件，上网查阅。</p><h4 id="2-2-Spring-Cloud-版本-问题"><a href="#2-2-Spring-Cloud-版本-问题" class="headerlink" title="2.2 Spring Cloud 版本 问题"></a>2.2 Spring Cloud 版本 问题</h4><p>防止混淆，版本通过命名方式，例如 Brixtion.SR5 就是 Brixtion的第5个Release 版本。</p><p><strong>由于Cloud 更新较快，故查阅资料要尽量查阅最新，以免出坑。</strong></p><h1 id="二、微服务构建-Sping-Boot"><a href="#二、微服务构建-Sping-Boot" class="headerlink" title="二、微服务构建 Sping Boot"></a>二、微服务构建 Sping Boot</h1><p>Sping Boot 是 Cloud 构建的基础框架，并且还有自动化配置、快速开发、轻松部署等优势。非常适合做微服务开发框架。</p><h2 id="1-Spring-Boot-简介"><a href="#1-Spring-Boot-简介" class="headerlink" title="1. Spring Boot 简介"></a>1. Spring Boot 简介</h2><p>Spring 框架繁琐，每次新构建都需要复制粘贴差不多的配置文件这种枯燥无谓的事。Spirng Boot 的出现就可以有效改善这类问题， Spring Boot 的宗旨并非重写Spring 或代替Spring 而是希望通过涉及大量自动化配置来简化Spring 原有的样板化配置，使得开发着快速构建项目。</p><p>除此之外，Spring Boot 还通过一系列Starter POMs 定义，简化pom.xml 维护错综复杂的依赖关系，使得依赖更加简单。</p><p>如今容器化大行其道，Spring Boot 除了融入Docker，自身支持其嵌入 Tomcat、Jetty 等容器。运行直接java -jar 运行启用标准Web应用。</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2. 快速入门"></a>2. 快速入门</h2><p>在项目依赖配置中，包含2项：</p><ul><li>spring-boot-starter-web ： 全栈Web 开发模块，包含嵌入式Tomcat、SpringMVC。</li><li>spring-boot-starter-test ：包含 JUnit、Hancrest、Mockito。</li></ul><p>需要访问数据库 加上 spring-boot-starter-jdbc 或者 更好用的spring-boot-starter-jpa ，这样通过Starter POMs 定义的依赖包，使得功能模块变的非常轻巧，易于理解使用。</p><p>构建build 引入了 Spring Boot 的 Maven插件， 通过 mvn spring-boot:run 命令快速启动。</p><h4 id="2-1-实现RESTful-API"><a href="#2-1-实现RESTful-API" class="headerlink" title="2.1 实现RESTful API"></a>2.1 实现RESTful API</h4><p>增加@RestController 注解可以将类设置为Controller 并返回RESTful 规范的json。</p><h4 id="2-2-单元测试"><a href="#2-2-单元测试" class="headerlink" title="2.2 单元测试"></a>2.2 单元测试</h4><p>直接上代码，注解 描述请看注释</p><p><strong>注意 @Test @Before 都需要统一包前缀，否则 before 失效</strong></p><div class="hljs"><pre><code class="hljs undefined">package com.zjn.cloud.eurekaclient;<span class="hljs-keyword">import</span> org.junit.Before;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<span class="hljs-keyword">import</span> org.springframework.http.MediaType;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<span class="hljs-keyword">import</span> org.springframework.test.context.web.WebAppConfiguration;<span class="hljs-keyword">import</span> org.springframework.test.web.servlet.MockMvc;<span class="hljs-keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;<span class="hljs-keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;<span class="hljs-keyword">import</span> static org.hamcrest.Matchers.equalTo;<span class="hljs-keyword">import</span> static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;<span class="hljs-keyword">import</span> static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;@<span class="hljs-type">RunWith</span>(<span class="hljs-type">SpringRunner</span>.<span class="hljs-keyword">class</span>) <span class="hljs-comment">// 引入 spring 对 JUnit4 的支持</span>@<span class="hljs-type">WebAppConfiguration</span> <span class="hljs-comment">// 开启Web应用配置，用于模拟ServletContext</span>@<span class="hljs-type">SpringBootTest</span> <span class="hljs-comment">//模拟Spring Boot 启动类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EurekaClientApplicationTests</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-type">MockMvc</span> mvc; <span class="hljs-comment">// 模拟对Controller 发起请求，perform 执行请求 accept接收数据类型 andExpect 判断接口返回期望值</span>    @<span class="hljs-type">Before</span>    <span class="hljs-keyword">public</span> void  setup()&#123;        mvc = <span class="hljs-type">MockMvcBuilders</span>.standaloneSetup(new <span class="hljs-type">HelloController</span>()).build();    &#125;    @<span class="hljs-type">Test</span>    <span class="hljs-keyword">public</span> void testHello() <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span>&#123;        mvc.perform(<span class="hljs-type">MockMvcRequestBuilders</span>.<span class="hljs-keyword">get</span>(<span class="hljs-string">"/hello"</span>).accept(<span class="hljs-type">MediaType</span>.<span class="hljs-type">APPLICATION_JSON</span>))                .andExpect(status().isOk())                .andExpect(content().string(equalTo(<span class="hljs-string">"hello"</span>)));    &#125; &#125;</code></pre></div><h2 id="3-配置详解"><a href="#3-配置详解" class="headerlink" title="3 配置详解"></a>3 配置详解</h2><h4 id="3-1-配置文件"><a href="#3-1-配置文件" class="headerlink" title="3.1 配置文件"></a>3.1 配置文件</h4><p>yml</p><h4 id="3-2-自定义参数"><a href="#3-2-自定义参数" class="headerlink" title="3.2 自定义参数"></a>3.2 自定义参数</h4><p>在 yml 中设置 @value 注解 取出</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@Value(<span class="hljs-meta-string">"<span class="hljs-subst">$&#123;book.name&#125;</span>"</span>)</span></code></pre></div><h4 id="3-3-参数引用"><a href="#3-3-参数引用" class="headerlink" title="3.3 参数引用"></a>3.3 参数引用</h4><p>配置文件中 使用 <div class="hljs"><pre><code class="hljs book.desc">#### 3.4 使用随机数```$&#123;random.value&#125;</code></pre></div></p><div class="hljs"><pre><code class="hljs $&#123;random.int&#125;```">#### 3.5 命令行参数java -jar xxx.jar --server.port=8000#### 3.6多环境配置</code></pre></div><p>application-dev.yml<br>application-test.yml<br>application-prod.yml</p><div class="hljs"><pre><code class="hljs undefined">通过 ```java -jar xxx.jar --server.<span class="hljs-attribute">port</span>=8000 --spring.profiles.<span class="hljs-attribute">active</span>=dev``` 选择开发环境<span class="hljs-comment">#### 3.7 加载顺序</span>Spring Boot 数据文件加载顺序 （不熟悉会造成安全隐患）1. 命令行参数2. SPRING_APPLICATION_JSON 中的属性。 它是以Json 格式配置在系统环境变量中设置的内容3. Java:comp/env 重的JNDI属性4. Java 系统属性 ```System.getProperties()``` 获得5. 操作系统环境变量6. 通过random.* 配置的随机属性7. 当前应用jar包外配置内容 例如 application-prod.yml 配置文件8. 当前应用jar包内的配置文件  application-prod.yml9. 当前应用jar包外配置内容 例如 application.yml 配置文件10. 当前应用jar包内的配置文件  application.yml11. @Configuration 注解修改的类中，通过@PropertySource 注解定义的属性12. 应用默认属性，使用SpringApplication.setDefaultProperties 定义的内容。优先级由低到高常用 第7 和 第9 项，这样 工程在配置变的非常干净，只需在本地放置开发的配置即可。<span class="hljs-comment">## 4. 监控与管理</span>spring-boot-starter-actuatorboot-starter-actuator提供一系列 用于监控的端点。 同时，Spring Cloud 在实现各个微服务组件的时候，进一步做了不少扩展。如 整合 Eureka 会为 <span class="hljs-built_in">/health </span>端点增加相关的信息 ，为API 网关提供了/routes 端点开返回路由信息。<span class="hljs-comment">#### 4.1 初识 actuator</span></code></pre></div> <dependency>            <groupid>org.springframework.boot</groupid>            <artifactid>spring-boot-starter-actuator</artifactid></dependency>```actuator 相关监控端口很多，不举例了，可上网查阅。<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5. 小结"></a>5. 小结</h2><p>主要写了Spring Boot 的配置原理以及监控管理做了一些介绍。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第二十一章</title>
    <link href="/2020/03/03/Thinking-in-Java-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <url>/2020/03/03/Thinking-in-Java-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第二十一章-并发"><a href="#第二十一章-并发" class="headerlink" title="第二十一章 并发"></a>第二十一章 并发</h1><p>目前为止，你学到的都是顺序编程知识，即程序重的所有事物在任意时刻都只能执行一个步骤。</p><h2 id="21-1-并发的多面性"><a href="#21-1-并发的多面性" class="headerlink" title="21.1 并发的多面性"></a>21.1 并发的多面性</h2><p>用并发解决问题大体上分为：“速度”和“设计可管理性”两种。</p><h4 id="21-1-1-更快的执行"><a href="#21-1-1-更快的执行" class="headerlink" title="21.1.1 更快的执行"></a>21.1.1 更快的执行</h4><p>多处理器可以将大量用户的需求分不到多个CPU中，但是并发通常是提高运行在单处理器上的程序。在<strong>单处理器上运行的并发程序开销确实应该比大部分顺序执行开销大</strong>。因为增加了上下文切换的代价。<strong>如果没有阻塞，那么在单处理机器上使用并发就没有任何意义。</strong><br>在单处理系统中的性能提高的常见示例是事件驱动编程。通过创建单独的执行线程来响应用户的输入，即使这个线程在大多数时间里都是阻塞的，但是程序可以保证具有一定程度的可响应性。<br>java 不支持多任务，Java 添加多线程机制。</p><h4 id="21-1-2-改进代码设计"><a href="#21-1-2-改进代码设计" class="headerlink" title="21.1.2 改进代码设计"></a>21.1.2 改进代码设计</h4><ul><li>在Java中，通常要假定你不会获得足够的线程，从而使得可以为大型仿真中的每个元素都提供一个线程。</li><li>解决这个问题的典型方式是使用协作多线程。Java的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。</li><li>协作式系统的优势：上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。</li></ul><h2 id="21-2-基本的线程机制"><a href="#21-2-基本的线程机制" class="headerlink" title="21.2 基本的线程机制"></a>21.2 基本的线程机制</h2><p>使用线程机制是一种建立透明的、可扩展的程序方法，如果程序运行太慢，为机器添加cpu。多任务和多线程往往是多处理器系统的最合理方式。</p><h4 id="21-2-1-定义任务"><a href="#21-2-1-定义任务" class="headerlink" title="21.2.1 定义任务"></a>21.2.1 定义任务</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> Thread;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiftOff</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> CountDown = <span class="hljs-number">10</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> taskCount = <span class="hljs-number">0</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id = taskCount++;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LiftOff</span><span class="hljs-params">()</span></span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LiftOff</span><span class="hljs-params">(<span class="hljs-keyword">int</span> countDown)</span> </span>&#123;        CountDown = countDown;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">status</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"#"</span> + id + <span class="hljs-string">"("</span> + (CountDown &gt; <span class="hljs-number">0</span> ? CountDown : <span class="hljs-string">"off"</span>) + <span class="hljs-string">"), "</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">while</span> (CountDown-- &gt;<span class="hljs-number">0</span>)&#123;            System.out.println(status());            Thread.yield();<span class="hljs-comment">// 线程调度器，一个线程转移到另一个线程</span>        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> Thread;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainThread</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;        LiftOff liftOff = <span class="hljs-keyword">new</span> <span class="hljs-type">LiftOff</span>();        liftOff.run();    &#125;&#125;</code></pre></div><h4 id="21-2-2-Thread-类"><a href="#21-2-2-Thread-类" class="headerlink" title="21.2.2 Thread 类"></a>21.2.2 Thread 类</h4><p>Thread构造器只需要一个Runnable对象。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Thread</span>(<span class="hljs-keyword">new</span> LiftOff())<span class="hljs-comment">;</span><span class="hljs-keyword">thread</span>.start()<span class="hljs-comment">;</span></code></pre></div><p><strong>main()方法也是一个线程，所以main()和LiftOff()是同时执行的。</strong><br>线程调度机制是非确定性的，不可以依赖线程的代码，尽可能的保守使用线程。<br>线程虽然没有捕获对象的引用，但是注册了自己，所以start()之后仍然不会被垃圾回收。<br><strong>thread的run方法还在执行时候不管这个thread对象处在什么状态下，thread对象都不会被回收，因为Thread的run()方法的局部变量this保持了对线程对象Thread的引用.</strong><br>所以start()仅仅是线程的开始。</p><h4 id="21-2-3-使用Executor"><a href="#21-2-3-使用Executor" class="headerlink" title="21.2.3 使用Executor"></a>21.2.3 使用Executor</h4><p>Java SE5的java.util.concurrent中的执行器（Executor）将为你管理Thread对象，从而简化了并发编程。 （线程池）</p><div class="hljs"><pre><code class="hljs undefined">ExecutorService exec = Executors.<span class="hljs-keyword">new</span><span class="hljs-type">FixedThreadPool</span>(<span class="hljs-number">10</span>);<span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;    exec.execute(<span class="hljs-keyword">new</span> <span class="hljs-type">LiftOff</span>());&#125;exec.shutdown();</code></pre></div><ul><li>FixedThreadPool使用了固定的线程集来执行所提交的任务。</li><li>CachedThreadPool在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。</li><li>SingleThreadExecutor 顺序执行 只会创建一个线程执行 单例线程。</li></ul><h4 id="21-2-4-从任务中产生返回值"><a href="#21-2-4-从任务中产生返回值" class="headerlink" title="21.2.4 从任务中产生返回值"></a>21.2.4 从任务中产生返回值</h4><p>实现Callable接口 可从任务中产生返回值，submit()会产生Future对象，用Future 对象接收返回参数。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> Thread;<span class="hljs-keyword">import</span> java.util.concurrent.Callable;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TaskWithResult</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TaskWithResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"asd"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"result of TaskWithResult"</span> + id;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> Thread;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<span class="hljs-keyword">import</span> java.util.concurrent.Executors;<span class="hljs-keyword">import</span> java.util.concurrent.Future;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallableDemo</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;        ExecutorService executorService = Executors.<span class="hljs-keyword">new</span><span class="hljs-type">CachedThreadPool</span>();        ArrayList&lt;Future&lt;<span class="hljs-keyword">String</span>&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();        Future s = executorService.submit(<span class="hljs-keyword">new</span> <span class="hljs-type">TaskWithResult</span>(<span class="hljs-number">2</span>));        <span class="hljs-keyword">try</span> &#123;            System.out.println(s.<span class="hljs-keyword">get</span>());        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;            e.printStackTrace();        &#125;        s.isCancelled();<span class="hljs-comment">//        for (int i = 0; i &lt; 10; i++) &#123;</span><span class="hljs-comment">//            futures.add(executorService.submit(new TaskWithResult(i)));</span><span class="hljs-comment">//        &#125;</span><span class="hljs-comment">//</span><span class="hljs-comment">//        for (Future&lt;String&gt; fs: futures)&#123;</span><span class="hljs-comment">//            try &#123;</span><span class="hljs-comment">//                System.out.println(fs.get());</span><span class="hljs-comment">//            &#125; catch (InterruptedException e)&#123;</span><span class="hljs-comment">//                System.out.println(e);</span><span class="hljs-comment">//            &#125; catch (ExecutionException e) &#123;</span><span class="hljs-comment">//                e.printStackTrace();</span><span class="hljs-comment">//            &#125; finally &#123;</span><span class="hljs-comment">//                executorService.shutdown();</span><span class="hljs-comment">//            &#125;</span><span class="hljs-comment">//        &#125;</span>    &#125;&#125;</code></pre></div><p><strong>execute提交的方式只能提交一个Runnable的对象，且该方法的返回值是void，也即是提交后如果线程运行后，和主线程就脱离了关系了。 submit 接收 Callable 接口的实现类，可用get()接收返回结果</strong></p><h4 id="21-2-5-休眠"><a href="#21-2-5-休眠" class="headerlink" title="21.2.5 休眠"></a>21.2.5 休眠</h4><p>Thread.sleep(1000);</p><h4 id="21-2-6-优先级"><a href="#21-2-6-优先级" class="headerlink" title="21.2.6 优先级"></a>21.2.6 优先级</h4><p>绝大时间里，都应该以默认优先级运行。试图操作通常是一种错误。<br>Thread.currentThread().setPriority(Thread.MAX_PRIORITY);<br><strong>优先级在run()开头设置，不要在构造器里设定，因为Executor 还没有开始执行任务</strong><br>只有执行了100000次开销相当大的浮点运算，包括double类型的加法与除法。没有这些运算，看不到优先级的效果。</p><h4 id="21-2-7-让步"><a href="#21-2-7-让步" class="headerlink" title="21.2.7 让步"></a>21.2.7 让步</h4><p>如果知道已完成了在run()方法所需的工作，就可以给线程调度一个暗示，告诉它做的差不多了，可以让别的线程使用cpu，这个暗示用yield()方法，不过不能保证他会被采纳。当调用yield时，你也是在建议有相同优先级的其他线程可运行。<br>（yield并不意味着退出和暂停，只是，告诉线程调度如果有人需要，可以先拿去，我过会再执行，没人需要，我继续执行）调用yield的时候锁并没有被释放。对于任何重要的控制或在调整应用时，都不恩那个依赖于yield。实际上，yield经常被误用。</p><ul><li><strong>解读：不要用yield控制程序，它只是调度线程让步。</strong></li></ul><h4 id="21-2-8-后台程序"><a href="#21-2-8-后台程序" class="headerlink" title="21.2.8 后台程序"></a>21.2.8 后台程序</h4><p>必须在线程启动之前start()前调用setDaemon()方法，才能把它设置为后台线程。<br>当最后一个非后台线程终止时，后台线程会“突然”停止。<br>isDaemon()来确定线程是否是一个后台线程。如果是 ，它创建的任何线程就是一个后台线程。</p><ul><li><strong>守护线程不能单独存活在JVM，即当程序中用户线程全部结束后JVM会立即杀死所有守护线程，守护线程中存在finally代码块，那么当所有的非守护线程中止时，守护线程被kill掉，其finally代码块是不会执行的。(除非main（）还在)，所以一般不要使用后台线程，因为你不能优雅的关闭它，非后台的Executor 通常是一种更好的方式。</strong></li></ul><h4 id="21-2-9-编码的变体"><a href="#21-2-9-编码的变体" class="headerlink" title="21.2.9 编码的变体"></a>21.2.9 编码的变体</h4><p>可直接继承Thread类，但是没办法继承其他类，所以最灵活的还是实现Runnable。</p><h4 id="21-2-10-术语"><a href="#21-2-10-术语" class="headerlink" title="21.2.10 术语"></a>21.2.10 术语</h4><p>描述要执行的工作时使用术语 “任务”，只有引用到驱动任务的具体机制时候，才使用“线程”。<br>实现Runnable只是定义一个“任务”，继承Thread 也是 继承出一个任务。在Java中，Thread类自身不执行任何操作，他只是驱动赋予他的任务。<strong>Thread类并没有任何控制权，并且在隔离高的执行器（在执行器里创建任和管理）更加明显。</strong></p><h4 id="21-2-11-加入一个线程"><a href="#21-2-11-加入一个线程" class="headerlink" title="21.2.11 加入一个线程"></a>21.2.11 加入一个线程</h4><ul><li>join() 定义在Thread.java中。</li><li>join() 的作用：让“主线程”等待“子线程”结束之后才能继续运行。</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">// 主线程</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    public void run() &#123;        <span class="hljs-type">Son</span> s = <span class="hljs-keyword">new</span> <span class="hljs-type">Son</span>();        s.start();        s.join();        ...    &#125;&#125;<span class="hljs-comment">// 子线程</span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    public void run() &#123;        ...    &#125;&#125;</code></pre></div><p>在调用s.join()之后，Father主线程会一直等待，直到“子线程s”运行完毕；在“子线程s”运行完毕之后，Father主线程才能接着运行。 这也就是我们所说的“join()的作用，是让主线程会等待子线程结束之后才能继续运行”！</p><p><strong>wait()的作用是让“当前线程”等待</strong>，而这里的“当前线程”是指当前在CPU上运行的线程。所以，虽然是调用子线程的wait()方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</p><p>join()源码中 isAlive()检查此线程是否存活。</p><p>以上引用 <a href="https://www.cnblogs.com/skywang12345/p/3479275.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3479275.html</a></p><p>对join()方法的调用可以被中断，做法是在调用线程上调用interrupt()方法。<br><strong>注：谁加入 谁调用interrupt</strong></p><h4 id="21-2-12-创建有响应的用户界面"><a href="#21-2-12-创建有响应的用户界面" class="headerlink" title="21.2.12 创建有响应的用户界面"></a>21.2.12 创建有响应的用户界面</h4><p>使用线程的动机之一就是建立有响应的用户界面. 利用设置守护进程 setDaemon() 可以在等待用户输入的同时，后台操作浮点运算。 </p><h4 id="21-2-13-线程组"><a href="#21-2-13-线程组" class="headerlink" title="21.2.13 线程组"></a>21.2.13 线程组</h4><p>线程组持有一个线程集合。 ThreadGroup（最好把线程组堪称一次不成功的尝试，直接忽略！<br>！！）</p><h4 id="21-2-14-捕获异常"><a href="#21-2-14-捕获异常" class="headerlink" title="21.2.14 捕获异常"></a>21.2.14 捕获异常</h4><p>当单线程的程序发生一个未捕获的异常时我们可以采用try….catch进行异常的捕获，但是在多线程环境中，线程抛出的异常是不能用try….catch捕获的。<br>Thread.UncaughtExceptionHandler是Java SE5中的接口，允许在每个Thread对象上附着一个异常处理器。</p><p>使用示例：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.exception; <span class="hljs-keyword">import</span> java.lang.Thread.UncaughtExceptionHandler; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WitchCaughtThread</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Task());thread.setUncaughtExceptionHandler(<span class="hljs-keyword">new</span> ExceptionHandler());thread.start();&#125;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UncaughtExceptionHandler</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span></span>&#123;System.out.println(<span class="hljs-string">"==Exception: "</span>+e.getMessage());&#125;&#125;</code></pre></div><h2 id="21-3-共享受限资源"><a href="#21-3-共享受限资源" class="headerlink" title="21.3 共享受限资源"></a>21.3 共享受限资源</h2><h4 id="21-3-1-不正确地访问资源"><a href="#21-3-1-不正确地访问资源" class="headerlink" title="21.3.1 不正确地访问资源"></a>21.3.1 不正确地访问资源</h4><p>java 递增也不是原子性的，自身也需要多个步骤，因此不保护任务，单一递增也不是安全的。</p><h4 id="21-3-2-解决共享资源竞争"><a href="#21-3-2-解决共享资源竞争" class="headerlink" title="21.3.2 解决共享资源竞争"></a>21.3.2 解决共享资源竞争</h4><p>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。</p><p>在使用并发时，将域设置为private是非常重要的。</p><p>使用显式的Lock对象</p><p>Lock对象必须被显式地创建、锁定和释放。</p><p>有了显式的Lock对象，就可以使用finnally子句将系统维护在正确的状态。</p><p><strong>Lock相比于synchronized具有更细粒度的控制力，以及处理异常，比如遍历列表中的节点的加锁机制（锁耦合），必须在当前节点解锁后捕获下一个锁。</strong></p><h4 id="21-3-3-原子性与易变性"><a href="#21-3-3-原子性与易变性" class="headerlink" title="21.3.3 原子性与易变性"></a>21.3.3 原子性与易变性</h4><p>原子操作是不能被线程调度机制中端的操作；一旦操作开始，那么它一定可以再发生的“上下文切换”之前（切换到其它线程执行）执行完毕。</p><p><strong>但是还是一种过于简化的机制，实际上也可能不安全，因为在多处理器上 还有可视性问题，例如一个任务作出修改，对其他任务也可能是不可视的，（修改只是暂时性存储本地处理器的缓存中），如果没有同步机制，那么修改时的可视将无法确定。</strong></p><p>如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为volatile。使用volatile而不是synchronized的唯一安全情况是类中只有一个可变的域。</p><p><strong>对基本类型的读取和赋值以及递增操作不是安全的原子性操作。反编译后将看到很多指令，get put 等等。</strong></p><h4 id="21-3-4-原子类"><a href="#21-3-4-原子类" class="headerlink" title="21.3.4 原子类"></a>21.3.4 原子类</h4><p>Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才使用它们。如果涉及多个Atomic对象，可能就应该考虑放弃使用Atomic，通常依赖于锁要更安全一点。（要么是synchronized关键字，要么是显示的Lock对象）</p><h4 id="21-3-5-临界区"><a href="#21-3-5-临界区" class="headerlink" title="21.3.5 临界区"></a>21.3.5 临界区</h4><p>同步控制块 例如：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-title">synchronized</span><span class="hljs-params">(syncObject)</span></span> &#123;    <span class="hljs-comment">// 临界区</span>&#125;</code></pre></div><h4 id="21-3-6-在其它对象上同步"><a href="#21-3-6-在其它对象上同步" class="headerlink" title="21.3.6  在其它对象上同步"></a>21.3.6  在其它对象上同步</h4><div class="hljs"><pre><code class="hljs undefined">package synchronize;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DualSynch</span> &#123;    Object o = <span class="hljs-keyword">new</span> Object();    <span class="hljs-function"><span class="hljs-keyword">public</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"f()"</span>);            Thread.<span class="hljs-keyword">yield</span>();        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>&#123;        synchronized (o)&#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"g()"</span>);                Thread.<span class="hljs-keyword">yield</span>();            &#125;        &#125;    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> synchronize;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynObject</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        DualSynch dualSynch = <span class="hljs-keyword">new</span> DualSynch();        <span class="hljs-keyword">new</span> Thread()&#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                dualSynch.f();            &#125;        &#125;.start();        dualSynch.g();    &#125;&#125;</code></pre></div><p>一个简答的例子验证了   synchronized 锁的内容。如果在this上同步，临界区的效果就会直接缩小在同步的范围内。两个任务可以同时进入同一个对象，只要这个对象上的方法是在不同的锁上同步的即可。<br><strong>synchronized代码块本质上完成的是代码片段的自动上锁和解锁，以确保关键代码片段在多线程中的互斥访问。synchronized既可以加在一段代码上，也可以加在方法上。</strong><br>（幼儿园解析）<br>synchronized 有三种形式 ：</p><ol><li><p>静态方法上的锁</p><p> 静态方法是属于“类”，不属于某个实例，是所有对象实例所共享的方法。也就是说如果在静态方法上加入synchronized，那么它获取的就是这个类的锁，<strong>锁住的就是这个类。</strong></p></li><li><p>实例方法（普通方法）上的锁</p><p> 实例方法并不是类所独有的，每个对象实例独立拥有它，它并不被对象实例所共享。这也比较能推出，在实例方法上加入synchronized，那么它获取的就是这个类的锁，<strong>锁住的就是这个对象实例。</strong></p></li><li><p>方法中使用同步代码块</p><ul><li>synchronized(this){…} this关键字所代表的意思是该对象实例，换句话说，这种用法synchronized锁住的仍然是对象实例，他和public synchronized void demo(){}可以说仅仅是做了语法上的改变。</li><li>private Object obj = new Object();    synchronized(obj){…}</li><li>synchronized(Demo.class){…}<br>这种形式等同于抢占获取类锁.收效甚微</li></ul></li></ol><p>以上引用：<a href="https://juejin.im/post/5d0c8101e51d455a694f954a" target="_blank" rel="noopener">https://juejin.im/post/5d0c8101e51d455a694f954a</a></p><h4 id="21-3-7-线程本地存储"><a href="#21-3-7-线程本地存储" class="headerlink" title="21.3.7 线程本地存储"></a>21.3.7 线程本地存储</h4><p>防止共享资源发生冲突的第二种方式就是根除对变量的共享。-&gt; java.lang.ThreadLocal 实现。</p><p>ThreadLocal 通常当作静态域存储，创建ThreadLocal时，只能通过get() set() 访问对象的内容。</p><p>原理解读：ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储</p><p>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象。</p><p><strong>所以简单说底层就是往Map存值，一个key 就是一个线程，就不会造成资源冲突了。</strong></p><h2 id="21-4-终结任务"><a href="#21-4-终结任务" class="headerlink" title="21.4 终结任务"></a>21.4 终结任务</h2><h4 id="21-4-1-装饰性花园"><a href="#21-4-1-装饰性花园" class="headerlink" title="21.4.1 装饰性花园"></a>21.4.1 装饰性花园</h4><p>本小节用了一大段代码说明了 多线程从统计学角度说失败的概率很小，导致很容易掉进坑里。所以要验证 要常用yield()，去增加失败率。可以用awaitTermination()方法来判断线程池中是否有继续运行的线程。</p><p>####21.4.2 在阻塞时终结</p><p>线程状态</p><ol><li>新建（new）</li><li>就绪（runnable）只要调度器把时间片分给线程就会执行。</li><li>阻塞（blocked）某个条件会阻止运行。当进入阻塞，调度器不会分配时间给线程，直到恢复就绪状态。</li><li>死亡（dead）结束或中断。</li></ol><p>进入阻塞状态</p><ol><li>通过调用sleep(milliseconds)使任务进入休眠状态。</li><li>调用wait()使线程挂起。直到线程得到了notify()或notifyAll()消息。</li><li>任务在等待某个输入/输出完成。（synchronized）</li><li>试图在某个对象上调用其同步控制方法，但对象锁不可用，因为另一个任务已经获得了这个锁。</li></ol><p>####21.4.3 中断</p><p>Thread interrupt()方法中止阻塞重的线程会抛出 InterruptedException() 异常。</p><p>concurrent类库避免对Thread对象的直接操作，转而通过Executor 执行所有操作。如果在Executor上调用shutdownNow()，它将发送一个interrupt()调用给它启动的所有线程。</p><p>使用Executor，那么通过调用submit()而不是execute()来启动任务，就可以持有该任务的上下文。submit()将返回一个泛型Future&lt;?&gt;，其中有一个未修饰的参数，因为你永远都不会在其上调用get()——持有这种Future的关键在于你可以在其上调用cancel()，并因此可以使用它来中断某个特定任务。如果你将true传递给cancel()，那么它就会拥有在该线程上调用interrupt()以停止这个线程的权限。因此，cancel()是一种中断由Executor启动的单个线程的方式。</p><p><strong>shutdown() 内部正在跑的任务和队列里等待的任务，会执行完。shutdownNow() 尝试将正在跑的任务interrupt中断.忽略队列里等待的任务,返回未执行的任务列表。</strong></p><p>不能中断正在试图获取synchronized锁或者试图执行I/O操作的线程。有一个不太好的解决方案：关闭任务在其上发生阻塞的底层资源。<br>例如 xx.close(); 关闭流资源。<br>（扩展基础）synchronized 释放 条件有4个：<br>    1. 当前线程的同步方法、代码块执行结束的时候释放。<br>    2. 当前线程在同步方法、同步代码块中遇到break 、 return 终于该代码块或者方法的时候释放。<br>    3. 出现未处理的error或者exception导致异常结束的时候释放<br>    4. 程序执行了 同步对象 wait 方法 ，当前线程暂停，释放锁</p><p>各种nio类提供了更人性化的I/O中断，被阻塞的nio通道会自动地响应中断。-&gt; SocketChannel.close();</p><p><strong>被互斥的阻塞</strong></p><p>一个任务能够调用在同一个对象中的其他的synchronized方法，因为这个任务已经持有锁了。</p><p>Java SE5并发类库添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力。</p><h4 id="21-4-4-检查中断"><a href="#21-4-4-检查中断" class="headerlink" title="21.4.4 检查中断"></a>21.4.4 检查中断</h4><p>Thread.interrupted()检查中断状态，不仅可以告诉你interrupt()是否被调用过，也可以清除中断状态。</p><p>try-finally子句使得无论run()循环如何退出，清理都会发生.</p><h2 id="21-5-线程之间的协作"><a href="#21-5-线程之间的协作" class="headerlink" title="21.5 线程之间的协作"></a>21.5 线程之间的协作</h2><p>当一个任务在方法里遇到了对wait()的调用的时候，线程的执行被挂起，<strong>对象上的锁被释放</strong>。<br>wait()、notify()和notifyAll()是基类Object的一部分。实际上，只能在同步控制方法或同步控制块里调用wait()、notify()和notifyAll()。</p><p><strong>错失的信号</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">thread1:</span><span class="hljs-keyword">synchronized</span>(sharedMonitor)&#123;      someCondition = <span class="hljs-literal">false</span>;      sharedMonitor.notify();&#125;<span class="hljs-symbol"> thread2:</span><span class="hljs-keyword">while</span>(someCondition)&#123;<span class="hljs-comment">//point 1</span><span class="hljs-keyword">synchronized</span>(sharedMonitor)&#123;sharedMonitor.wait();&#125;&#125;</code></pre></div><p>先执行thread2，当进入while循环 执行thread1 会出现无限期等待。所以要把thread2代码块都同步。防止在在someCondition变量上产生竞争条件。</p><h4 id="21-5-2-notify-与notifyAll"><a href="#21-5-2-notify-与notifyAll" class="headerlink" title="21.5.2 notify()与notifyAll()"></a>21.5.2 notify()与notifyAll()</h4><p>在技术上，可能会有多个任务在单个Car对象上处于wait（）状态，notifyAll()更加安全。蛋实际上只会有一个任务处于wait(),因此用notify()替代notifyAll()。</p><p><strong>当前的线程不是此对象监视器的所有者。也就是要在当前线程锁定对象，才能用锁定的对象此行这些方法，需要用到synchronized ，锁定什么对象就用什么对象来执行  notify(), notifyAll(),wait(), wait(long), wait(long, int)操作，否则就会报IllegalMonitorStateException异常。</strong></p><p><strong>替代notifyAll() 将唤醒正在等待的所有任务是不严谨的，只是对当前线程锁定对象，等待这个锁的任务才会被唤醒。</strong></p><p>使用notify()，就必须保证被唤醒的是恰当的任务。</p><h4 id="21-5-3-生产者与消费者"><a href="#21-5-3-生产者与消费者" class="headerlink" title="21.5.3 生产者与消费者"></a>21.5.3 生产者与消费者</h4><p>生产者-消费者实现中，应使用先进先出队列来存储被生产和消费的对象。</p><p><strong>使用显式的Lock和Condition对象</strong></p><p>需要条件判断。而单个Lock将产生一个Condition对象，这个对象被用来管理任务间的通信。其他仍需要额外的表示处理状态信息。所以一个类中多个条件锁等待，需要用Condition()。</p><h4 id="21-5-4-生产者-消费者队列"><a href="#21-5-4-生产者-消费者队列" class="headerlink" title="21.5.4 生产者-消费者队列"></a>21.5.4 生产者-消费者队列</h4><p>wait() notifyAll() 以一种非常低级的方式解决了任务互操作问题，即每次交互时候都握手。多数情况下，可以使用更高级抽象级别，同步队列-&gt;(BlockingQueue，其内部是同步的）和系统的设计隐式地管理了任何时刻都只有一个任务在操作。<strong>但是遇到多消费者按顺序消费的需求用实现类LinkedBlockingQueue仍然需要外部加同步，它只是保证不会超消费，并不能保证多线程抢占顺序，还可以使用实现类SynchronousQueue。</strong></p><h4 id="21-5-5-任务间使用管道进行输入-输出"><a href="#21-5-5-任务间使用管道进行输入-输出" class="headerlink" title="21.5.5 任务间使用管道进行输入/输出"></a>21.5.5 任务间使用管道进行输入/输出</h4><p>PipedWriter/PipedReader 管道流通信核心是,Writer和Reader公用一块缓冲区,缓冲区在Reader中申请,由Writer调用和它绑定的Reader的Receive方法进行写. （BlockingQueue 使用起来会更加好。）</p><h2 id="21-6-死锁"><a href="#21-6-死锁" class="headerlink" title="21.6 死锁"></a>21.6 死锁</h2><p>任务之间相互等待的连续循环，没有哪个线程能继续。被称之为死锁。最可怕的是看起来工作良好，但是具有死锁危险。（很难重现的方式发生。）</p><p>死锁的条件：</p><ul><li>互斥条件</li><li>至少有一个任务必须持有一个资源且正在等待获取一个当前被别的任务持有的资源</li><li>资源不能被任务抢占，任务必须把资源释放当做普通事件</li><li>必须有循环等待</li></ul><p>破除一条就会解除，最容易的方法就是破坏第四个条件。</p><h2 id="21-7-新类库中的构件"><a href="#21-7-新类库中的构件" class="headerlink" title="21.7 新类库中的构件"></a>21.7 新类库中的构件</h2><h4 id="21-7-1-CountDownLatch"><a href="#21-7-1-CountDownLatch" class="headerlink" title="21.7.1 CountDownLatch"></a>21.7.1 CountDownLatch</h4><p>闭锁。被用来同步一个或多个任务，强制它们等待由其它任务执行的一组操作完成。<br>countDown 计数达到0, await() 调用会被阻塞。</p><h4 id="21-7-1-CyclicBarrier"><a href="#21-7-1-CyclicBarrier" class="headerlink" title="21.7.1 CyclicBarrier"></a>21.7.1 CyclicBarrier</h4><p>栅栏。CyclicBarrier用于等待其他线程运行到栅栏位置。与CountDownLatch 相似，CountDownLatch是只触发一次的事件，而CyclicBarrier可以多次重用。</p><h4 id="21-7-3-DelayQueue"><a href="#21-7-3-DelayQueue" class="headerlink" title="21.7.3 DelayQueue"></a>21.7.3 DelayQueue</h4><p>延时队列。无届的BlockingQueue，放置的对象实现了Delay接口对象，其中的对象只能在其到期时才能从队列取走。</p><h4 id="21-7-4-PriorityBlockingQueue"><a href="#21-7-4-PriorityBlockingQueue" class="headerlink" title="21.7.4 PriorityBlockingQueue"></a>21.7.4 PriorityBlockingQueue</h4><p>优先级队列PriorityBlockingQueue必须是实现Comparable接口，队列通过这个接口的compare方法确定对象的priority。当前和其他对象比较，如果compare方法返回负数，那么在队列里面的优先级就比较高。</p><h4 id="21-7-5-使用ScheduleExecutor的温室控制器"><a href="#21-7-5-使用ScheduleExecutor的温室控制器" class="headerlink" title="21.7.5 使用ScheduleExecutor的温室控制器"></a>21.7.5 使用ScheduleExecutor的温室控制器</h4><p>ScheduledThreadPoolExecutor 能解决在预定时间运行的任务。（线程池）</p><h4 id="21-7-6-Semaphore"><a href="#21-7-6-Semaphore" class="headerlink" title="21.7.6 Semaphore"></a>21.7.6 Semaphore</h4><p>正常的锁只能允许一个任务访问同一个资源。Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。 </p><h4 id="21-7-7-Exchanger"><a href="#21-7-7-Exchanger" class="headerlink" title="21.7.7 Exchanger"></a>21.7.7 Exchanger</h4><p>应用场景是：一个任务在创建对象，这些对象的生产代价很高昂，而另一个任务在消费这些对象。通过这种方式，可以有更多的对象在被创建的同时被消费。<strong>创建完直接给其他线程处理消费，无需等待线程去选择执行。</strong></p><h2 id="21-8-仿真"><a href="#21-8-仿真" class="headerlink" title="21.8 仿真"></a>21.8 仿真</h2><p>个人理解：多线程可以模拟出真实应用场景的并发需求。</p><h2 id="21-9-性能调优"><a href="#21-9-性能调优" class="headerlink" title="21.9 性能调优"></a>21.9 性能调优</h2><p>用单线程测试 synchronized 要比 Lock 快很多,但是并没有意义。有可能会执行特殊优化，并且固定次数，可能会被编译器识别提前计算。所以要在多线程环境下测试。</p><h4 id="21-9-1-比较各类互斥技术"><a href="#21-9-1-比较各类互斥技术" class="headerlink" title="21.9.1 比较各类互斥技术"></a>21.9.1 比较各类互斥技术</h4><p>Lock通常会比使用synchronized要高效许多并且稳定。</p><p><strong>1.6后synchronized优化为锁升级，效率相近。</strong></p><h4 id="21-9-2-免锁容器"><a href="#21-9-2-免锁容器" class="headerlink" title="21.9.2 免锁容器"></a>21.9.2 免锁容器</h4><p>对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。</p><p>CopyOnWriteArrayList/CopyOnWriteSet/ConcurrentHashMap 都可称为免锁容器</p><p><strong>只有set使用synchronized，原理是在容器数据结构复制出一个单独的副本，修改结束后与主数据交换。使新读操作可以看到这个修改。容器只有部分内容而不是整个内容可以被复制和修改。</strong></p><p>源码如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">public</span> boolean <span class="hljs-keyword">add</span>(E e) &#123;        synchronized (<span class="hljs-keyword">lock</span>) &#123;            Object[] <span class="hljs-built_in">es</span> = getArray()<span class="hljs-comment">;</span>            <span class="hljs-keyword">int</span> len = <span class="hljs-built_in">es</span>.length<span class="hljs-comment">;</span>            <span class="hljs-built_in">es</span> = Arrays.copyOf(<span class="hljs-built_in">es</span>, len + <span class="hljs-number">1</span>)<span class="hljs-comment">;</span>            <span class="hljs-built_in">es</span>[len] = e<span class="hljs-comment">;</span>            setArray(<span class="hljs-built_in">es</span>)<span class="hljs-comment">;</span>            return true<span class="hljs-comment">;</span>        &#125;    &#125;</code></pre></div><p>等到修改结束，读操作才能看到。</p><p><strong>乐观锁</strong></p><p>synchronized ArrayList 无论读写数量多少，性能都大致相同的慢。CopyOnWriteArrayList对写少的情况喜爱回异常的快，并且在多写情况下虽然慢但也要比 整个列表加锁性能要好的多。</p><p>*<em>比较各种Map实现  *</em></p><p>ConcurrentHashMap 比synchronized HashMap 性能要好很多，因为使用分段锁，每次只锁一个Entry的key值。</p><h4 id="21-9-3-乐观加锁"><a href="#21-9-3-乐观加锁" class="headerlink" title="21.9.3 乐观加锁"></a>21.9.3 乐观加锁</h4><p>Atomic对象的compareAndSet() 比较并交换 不需要互斥锁，性能更高，但是比较失败 需要重续操作，比较消耗性能<br>someone.compareAndSet(false,true)可以理解为：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span>(<span class="hljs-attr">someone</span> == <span class="hljs-literal">false</span>)&#123;    <span class="hljs-attr">someone=true</span>&#125;</code></pre></div><h4 id="21-9-4-ReadWriteLock"><a href="#21-9-4-ReadWriteLock" class="headerlink" title="21.9.4 ReadWriteLock"></a>21.9.4 ReadWriteLock</h4><p>对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。</p><h2 id="21-10-活动对象"><a href="#21-10-活动对象" class="headerlink" title="21.10 活动对象"></a>21.10 活动对象</h2><p>活动对象的特征：</p><ul><li>基于消息机制：<br>对活动对象的请求和可能的参数都被转化为消息，这些消息被转发给活动对象实际实现并排队等待处理。处理结果以future对象返还给提出请求的对象。</li></ul><ul><li><p>异步调用：<br>对活动对象的请求被异步执行，实际由活动对象的工作线程处理请求，故不会阻塞调用者。仅当请求未完成执行时，调用者试图获取处理结果时会被阻塞。</p></li><li><p>线程安全：<br>活动对象天生是线程安全的。因为他顺序地从请求队列摘取消息进行处理，并且始终在一个单独的线程中执行，由于不存在资源竞争，所以也不用担心同步、死锁等问题。同步仍旧会发生，但它通过将方法调用排队，使得任何时刻都只能发生一个调用，从而将同步控制在消息的级别上发生。<br>每个Future对象 在维护着它自己的工作器线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻只运行一个。</p></li></ul><p>应用场景：<br>适合于按某一特定顺序执行而又互不影响的调用者执行状况的情景。</p><h2 id="21-11-总结"><a href="#21-11-总结" class="headerlink" title="21.11 总结"></a>21.11 总结</h2><p> 线程提供轻量级执行上下文切换（大约100条指令。）<br> 进程是重量的（大约1000条。）<br> 线程缺点：</p><ol><li><p>等待共享资源性能降低</p></li><li><p>需要处理线程的额外CPU花费。</p></li><li><p>糟糕的程序设计导致不必要饿复杂度。</p></li><li><p>有可能产生一些病态行为，如饿死、竞争、死锁、活锁（多个运行各自任务的线程使得整体无法完成。）</p></li><li><p>不同平台导致不一致性。</p><p>多线程共享资源，要确保不会同时读取或改变资源，明知的使用加锁机制。要对锁有透彻的理解，否则会引入潜在的死锁。</p><p>如果线程问题变得大而复杂，就要使用erlang语言。专门用于线程机制的函数型语言。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第二十章</title>
    <link href="/2020/03/01/Thinking-in-Java-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/"/>
    <url>/2020/03/01/Thinking-in-Java-%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第二十章-注解"><a href="#第二十章-注解" class="headerlink" title="第二十章 注解"></a>第二十章 注解</h1><p>注解（元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便地使用这些数据。</p><ul><li>@Override，表示当前的方法定义将覆盖超类中的方法。</li><li>@Deprecated（废弃的），如果程序员使用了注解为它的元素，那么编译器会发出警告信息。</li><li>@SuppressWarnings，关闭不当的编译器警告信息。</li></ul><h2 id="20-1-基本语法"><a href="#20-1-基本语法" class="headerlink" title="20.1 基本语法"></a>20.1 基本语法</h2><p>注解的方法与其他方法没有区别，例如public、static、void 从语法的角度来看，注解的使用方式几乎与修饰符的使用一模一样。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testExecute</span><span class="hljs-params">()</span></span>;</code></pre></div><h4 id="20-1-1-定义注解"><a href="#20-1-1-定义注解" class="headerlink" title="20.1.1 定义注解"></a>20.1.1 定义注解</h4><p>与其他任何Java接口一样，注解也将会编译成class文件。</p><h4 id="20-1-2-元注解"><a href="#20-1-2-元注解" class="headerlink" title="20.1.2 元注解"></a>20.1.2 元注解</h4><p>元注解专职负责注解其他的注解：</p><table><thead><tr><th>元注解</th><th>描述</th></tr></thead><tbody><tr><td><code><a href="https://github.com/Target" title="@Target" class="at-link" target="_blank">@Target</a></code></td><td>表示该注解可以用于什么地方。可能的<code>ElementType</code>包括：<br><code>CONSTRUCTOR</code>: 构造器的声明<br><code>FIELD</code>: 域声明（包括<code>enum</code>实例）<br><code>LOCAL_VARIABLE</code>: 局部变量声明<br><code>METHOD</code>: 方法声明<br><code>PACKAGE</code>: 包声明 <br><code>PARAMETER</code>: 参数声明 <br><code>TYPE</code>: 类、接口（）包括注解类型) 或<code>enum</code>声明</td></tr><tr><td><code><a href="https://github.com/Retention" title="@Retention" class="at-link" target="_blank">@Retention</a></code></td><td>表示需要在什么级别保存该注解信息。可选的<code>RetentionPolicy</code>参数包括：<br><code>SOURCE</code>: 注解将被编译器丢弃<br><code>CLASS</code>: 注解在<code>class</code>文件中可用，但会被虚拟机丢弃。<br><code>RUNTIME</code>: 虚拟机将在运行期也保留注解，因此可以通过反射机制读取注解的信息。</td></tr><tr><td><code><a href="https://github.com/Documented" title="@Documented" class="at-link" target="_blank">@Documented</a></code></td><td>将此注解包含在Javadoc中。</td></tr><tr><td><code><a href="https://github.com/Inherited" title="@Inherited" class="at-link" target="_blank">@Inherited</a></code></td><td>允许子类继承父类的注解。</td></tr></tbody></table><h2 id="20-2-编写注解处理器"><a href="#20-2-编写注解处理器" class="headerlink" title="20.2 编写注解处理器"></a>20.2 编写注解处理器</h2><h4 id="20-2-1-注解元素"><a href="#20-2-1-注解元素" class="headerlink" title="20.2.1 注解元素"></a>20.2.1 注解元素</h4><p>注解元素可用的类型：</p><ol><li>所有基本数据类型（int, float, boolean 等）</li><li>String</li><li>Class</li><li>enum</li><li>Annotation</li><li>以上类型的数组</li></ol><p>使用其他类型编译器就会报错，也不允许使用任何包装类型。<br>注解也可以作为元素的类型，也就是说注解可以嵌套。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Annotation &#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> trackUseCases(List&lt;Integer&gt; useCases, <span class="hljs-keyword">Class</span>&lt;?&gt; cl) &#123;        <span class="hljs-keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;            UseCase uc = m.getAnnotation(UseCase.<span class="hljs-keyword">class</span>);            <span class="hljs-keyword">if</span> (uc != <span class="hljs-keyword">null</span>) &#123;                System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Found Use Case:"</span> + uc.id() + <span class="hljs-string">" "</span> + uc.<span class="hljs-keyword">description</span>());                useCases.remove(<span class="hljs-keyword">new</span> Integer(uc.id()));            &#125;        &#125;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i : useCases) &#123;            System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Warning: Missing use case-"</span> + i);        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;        List&lt;Integer&gt; useCases = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();        Collections.addAll(useCases, <span class="hljs-number">47</span>, <span class="hljs-number">48</span>, <span class="hljs-number">49</span>, <span class="hljs-number">50</span>);        trackUseCases(useCases, PasswordUtils.<span class="hljs-keyword">class</span>);      PasswordUtils util=<span class="hljs-keyword">new</span> PasswordUtils();        <span class="hljs-keyword">try</span> &#123;            Method m=util.getClass().getMethod(<span class="hljs-string">"validatePassword"</span>, String.<span class="hljs-keyword">class</span>);            <span class="hljs-keyword">if</span>(!((<span class="hljs-keyword">boolean</span>)m.invoke(util, <span class="hljs-string">"test"</span>)))&#123;                UseCase uc=m.getAnnotation(UseCase.<span class="hljs-keyword">class</span>);                System.out.<span class="hljs-keyword">println</span>(uc.<span class="hljs-keyword">description</span>());            &#125;        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span class="hljs-keyword">class</span> PasswordUtils &#123;    @UseCase(id = <span class="hljs-number">47</span>, <span class="hljs-keyword">description</span> = <span class="hljs-string">"Passwords must contain at least one numeric"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> validatePassword(String password) &#123;        <span class="hljs-keyword">return</span> (password.matches(<span class="hljs-string">"\\w*\\d\\w*"</span>));    &#125;    @UseCase(id = <span class="hljs-number">48</span>)    <span class="hljs-keyword">public</span> String encryptPassword(String password) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringBuilder(password).<span class="hljs-keyword">reverse</span>().toString();    &#125;    @UseCase(id = <span class="hljs-number">49</span>, <span class="hljs-keyword">description</span> = <span class="hljs-string">"New passwords can’t equal previously used ones"</span>)    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> checkForNewPassword(List&lt;String&gt; prevPasswords,            String password) &#123;        <span class="hljs-keyword">return</span> !prevPasswords.contains(password);    &#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.lang.<span class="hljs-keyword">annotation</span>.*;<span class="hljs-keyword">import</span> java.lang.<span class="hljs-keyword">annotation</span>.Target;<span class="hljs-meta">@Target(ElementType.METHOD)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> UseCase &#123;    <span class="hljs-keyword">public</span> int id() <span class="hljs-keyword">default</span> -<span class="hljs-number">1</span>;    <span class="hljs-keyword">public</span> String description() <span class="hljs-keyword">default</span> <span class="hljs-string">"default description"</span>;&#125;</code></pre></div><h4 id="20-2-2-默认值限制"><a href="#20-2-2-默认值限制" class="headerlink" title="20.2.2 默认值限制"></a>20.2.2 默认值限制</h4><p>元素必须要么具有默认值，要么使用注解时提供的值。</p><p>对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值，都不能以null作为其值。</p><p>注解快捷方式：如果注解元素声明为value()，则在使用注解时如果只声明value，可以只写值，不必写名值对。例如可写为@Test(10)</p><h4 id="20-2-3-生成外部文件"><a href="#20-2-3-生成外部文件" class="headerlink" title="20.2.3 生成外部文件"></a>20.2.3 生成外部文件</h4><p>变通之道<br>同时使用两个注解类型来注解一个域。 </p><h4 id="20-2-4-注解不支持继承"><a href="#20-2-4-注解不支持继承" class="headerlink" title="20.2.4 注解不支持继承"></a>20.2.4 注解不支持继承</h4><p>不能使用extends来继承某个@interface。算是遗憾，可以嵌套解决。</p><h4 id="20-2-5-实现处理器"><a href="#20-2-5-实现处理器" class="headerlink" title="20.2.5 实现处理器"></a>20.2.5 实现处理器</h4><p>在编译时通过注解获取相关数据，然后处理操作。</p><h2 id="20-3-使用apt处理注解"><a href="#20-3-使用apt处理注解" class="headerlink" title="20.3 使用apt处理注解"></a>20.3 使用apt处理注解</h2><p>自定义的每个注解都需要自己的处理器，而apt工具能很容易地将多个注解处理器组合在一起。<br>（java提供了一个名为AbstractProcessor.java的抽象类，我们只要继承该类，就实现自己的注解处理器，来处理自定义的注解，书中是自己实现了一个apt）</p><h2 id="20-4-将观察者模式用于apt"><a href="#20-4-将观察者模式用于apt" class="headerlink" title="20.4 将观察者模式用于apt"></a>20.4 将观察者模式用于apt</h2><p>用观察者模式 一对多处理多个注解。</p><h2 id="20-5-基于注解的单元测试"><a href="#20-5-基于注解的单元测试" class="headerlink" title="20.5 基于注解的单元测试"></a>20.5 基于注解的单元测试</h2><p>有了注解，可以直接在要验证的类里面编写测试,方便快捷。</p><h4 id="20-5-1-将-Unit用于泛型"><a href="#20-5-1-将-Unit用于泛型" class="headerlink" title="20.5.1 将@Unit用于泛型"></a>20.5.1 将@Unit用于泛型</h4><p>测试类继承自泛型，来测试堆栈里的数据和类型。唯一缺点是继承让我们无法访问private方法，要么修改他的访问权限修饰符。要么就在类中添加@TestProperty 由他来调用方法。例如：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ex8</span> </span>&#123;<span class="hljs-keyword">private</span> String methodOne() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">"methodOne"</span>; &#125;<span class="hljs-meta">@TestProperty</span> <span class="hljs-keyword">protected</span> String methodOneCall() &#123;         <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.methodOne(); &#125; &#125;</code></pre></div><h4 id="20-5-2-不需要任何套件"><a href="#20-5-2-不需要任何套件" class="headerlink" title="20.5.2 不需要任何套件"></a>20.5.2 不需要任何套件</h4><p>@Uint 只是简单的搜索类文件，检查是否具有恰当的注解，然后运行@Test方法。<br>在@JUnit中，程序员必须告诉测试工具你打算测试什么，这就要求用套件来组织测试，以便JUnit能够找到它们，并运行包含的测试。</p><h5 id="20-5-3-实现-Unit"><a href="#20-5-3-实现-Unit" class="headerlink" title="20.5.3 实现@Unit"></a>20.5.3 实现@Unit</h5><h5 id="20-5-4-移除测试代码"><a href="#20-5-4-移除测试代码" class="headerlink" title="20.5.4 移除测试代码"></a>20.5.4 移除测试代码</h5><p>开源Javassist工具库。</p><h2 id="20-6-总结"><a href="#20-6-总结" class="headerlink" title="20.6 总结"></a>20.6 总结</h2><p>注解是Java引入的一项非常受欢迎的补充，从而似的程序员为代码加入元数据，不会导致代码杂乱。而Javadoc 中的@deprecated被@Deprecated注解取代的事实也说明，与注释文字相比，注解更适合买哦书类的相关信息。<br>有了apt工具可以简化构建过程，Javassist能操作字节码的工具。<br>不过现在的framework一定会将注解包含在其提供的工具集内，注解会将Java编程体验提升。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十九章</title>
    <link href="/2020/02/28/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0/"/>
    <url>/2020/02/28/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十九章-枚举类型"><a href="#第十九章-枚举类型" class="headerlink" title="第十九章 枚举类型"></a>第十九章 枚举类型</h1><p>关键字enmu可以将一组具名（就是具体的意思，翻译某些地方还是挺烂的）的值的有限集合创建为一种新的类型，而这些具体的值可以作为常规的程序组建使用。这是一种非常有用的功能。</p><h2 id="19-1-基本enum特性"><a href="#19-1-基本enum特性" class="headerlink" title="19.1 基本enum特性"></a>19.1 基本enum特性</h2><p>常用枚举方法： （可以用==来比较enum实例）</p><div class="hljs"><pre><code class="hljs undefined">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;</span>    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Shrubbery</span> &#123;<span class="hljs-title">ONE</span>,<span class="hljs-title">TWo</span>,<span class="hljs-title">Three</span>&#125;</span>    public static void main(String[] args) &#123;        <span class="hljs-keyword">for</span>(Shrubbery s : Shrubbery.values())&#123;            System.<span class="hljs-keyword">out</span>.println(s.ordinal());            System.<span class="hljs-keyword">out</span>.println(s.getDeclaringClass());            System.<span class="hljs-keyword">out</span>.println(s.name());            System.<span class="hljs-keyword">out</span>.println(s == Shrubbery.ONE);            System.<span class="hljs-keyword">out</span>.println(s.equals(Shrubbery.ONE));            System.<span class="hljs-keyword">out</span>.println(s.compareTo(Shrubbery.ONE));            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"--------"</span>);        &#125;    &#125;&#125;</code></pre></div><p>还可以用import static 导入枚举类</p><h2 id="19-2-向enum中添加新方法"><a href="#19-2-向enum中添加新方法" class="headerlink" title="19.2 向enum中添加新方法"></a>19.2 向enum中添加新方法</h2><p> enum中的构造器与方法和普通的类没有区别，因为除了少许限制（不能继承自一个enum）外，enum就是一个普通的类。一旦enum的定义结束，编译器就不允许我们再使用其构造器创建任何实例。</p><p>覆盖enum的方法<br>枚举类也可以重写toString()方法，给我们提供了另一种方式来为枚举实例生成不同的字符串描述信息。</p><h2 id="19-3-switch语句中的enum"><a href="#19-3-switch语句中的enum" class="headerlink" title="19.3 switch语句中的enum"></a>19.3 switch语句中的enum</h2><p>Java SE7中switch支持字符串。</p><h2 id="19-4-values-的神秘之处"><a href="#19-4-values-的神秘之处" class="headerlink" title="19.4 values()的神秘之处"></a>19.4 values()的神秘之处</h2><p>Enum接口并没有values()方法。<br>values()是由编译器添加的static方法。（反编译后可查看）<br>Class中有一个getEnumConstants()方法，所以即便Enum接口中没有values()方法，我们仍然可以通过Class对象取得所有enum实例。</p><h2 id="19-5-实现，而非继承"><a href="#19-5-实现，而非继承" class="headerlink" title="19.5 实现，而非继承"></a>19.5 实现，而非继承</h2><p>enum 类都继承Java.lang.Enum类。而且 不能再继承其它类。但是可以实现一个或者多个接口。<br>enum CartoonCharacter implements Generator<cartooncharacter>{}</cartooncharacter></p><h2 id="19-6-随机选取"><a href="#19-6-随机选取" class="headerlink" title="19.6 随机选取"></a>19.6 随机选取</h2><p>使用泛型 random 对 枚举 随机选取。（具体看书中代码） 。</p><h2 id="19-7-使用接口组织枚举"><a href="#19-7-使用接口组织枚举" class="headerlink" title="19.7 使用接口组织枚举"></a>19.7 使用接口组织枚举</h2><div class="hljs"><pre><code class="hljs undefined">Interface Food&#123;    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Apptizer</span> <span class="hljs-title">implements</span> <span class="hljs-title">Food</span>&#123;</span>        SALAD, SOUP    &#125;    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MainCourse</span> <span class="hljs-title">implements</span> <span class="hljs-title">Food</span>&#123;</span>        LASAGEN, BURRITO    &#125;    &#125;</code></pre></div><p>由于枚举只能实现接口不能继承，所以遍历枚举需要如上这么写，向上转型 成 Food。</p><h2 id="19-8-使用EnumSet替代标志"><a href="#19-8-使用EnumSet替代标志" class="headerlink" title="19.8 使用EnumSet替代标志"></a>19.8 使用EnumSet替代标志</h2><p>EnumSet的设计充分考虑到了速度因素，因为它必须与非常高效的bit标志相竞争。<br>它说明一个二进制位（bit）是否存在时，具有更好的表达能力，并且无需担心性能。<br>EnumSet的基础是long（64个元素）。<br><em>注：EnumSet只是存 状态 0 代表无 1 代表有，真正的信息还是存在枚举里。</em></p><h2 id="19-9-使用EnumMap"><a href="#19-9-使用EnumMap" class="headerlink" title="19.9 使用EnumMap"></a>19.9 使用EnumMap</h2><p>EnumMap 底层由数组模式实现，因此实现速度很快，（<strong>这里解释下为什么如果是枚举EnumMap快于hashmap。 1: 不需要计算hashCode()。 2: 只会申请指定枚举的空间大小，没有额外的空间浪费。</strong>）<br>使用命令模式 实现下：</p><div class="hljs"><pre><code class="hljs undefined">import java.util.EnumMap;import java.util.*;<span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> &#123; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>)</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnumMapTest</span> &#123;    <span class="hljs-keyword">enum</span> AlarmPoints &#123;KITCHEN,BATHROOM,UTILITY&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        EnumMap&lt;AlarmPoints,Command&gt; em = <span class="hljs-keyword">new</span> EnumMap&lt;&gt;(AlarmPoints.class);        em.put(AlarmPoints.KITCHEN, <span class="hljs-keyword">new</span> Command()  &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>)</span> &#123;                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Kitchen fire!"</span>); &#125;        &#125;);        em.put(AlarmPoints.BATHROOM, <span class="hljs-keyword">new</span> Command() &#123;            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span>(<span class="hljs-params"></span>)</span> &#123; System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Bathroom alert!"</span>); &#125;        &#125;);        <span class="hljs-keyword">for</span>(                Map.Entry&lt;AlarmPoints,Command&gt; e : em.entrySet()) &#123;                System.<span class="hljs-keyword">out</span>.println(e.getKey() + <span class="hljs-string">": "</span>);                e.getValue().action();        &#125;        <span class="hljs-keyword">try</span> &#123; <span class="hljs-comment">// If there’s no value for a particular key:</span>            em.<span class="hljs-keyword">get</span>(AlarmPoints.UTILITY).action();        &#125; <span class="hljs-keyword">catch</span>(Exception e) &#123;            System.<span class="hljs-keyword">out</span>.println(e);        &#125;    &#125;&#125;</code></pre></div><p>与常量相关的方法相比，EnumMap允许改变值对象。</p><h2 id="19-10-常量的相关方法"><a href="#19-10-常量的相关方法" class="headerlink" title="19.10 常量的相关方法"></a>19.10 常量的相关方法</h2><p>书中例子为 表驱动法 （解析：从表里面查找信息而不是使用逻辑语句（if…else…switch），当是很简单的情况时，用逻辑语句很简单，但如果逻辑很复杂，再使用逻辑语句就很麻烦了。）</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.text.DateFormat;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> ConstantSpecificMethod &#123;    DATE_TIME &#123;        <span class="hljs-function">String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> DateFormat.getDateInstance().format(<span class="hljs-keyword">new</span> Date());        &#125;    &#125;,    CLASSPATH &#123;        <span class="hljs-function">String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">return</span> System.<span class="hljs-title">getenv</span><span class="hljs-params">(<span class="hljs-string">"CLASSPATH"</span>)</span></span>;        &#125;    &#125;,    VERSION &#123;        <span class="hljs-function">String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-function"><span class="hljs-keyword">return</span> System.<span class="hljs-title">getProperty</span><span class="hljs-params">(<span class="hljs-string">"java.version"</span>)</span></span>;        &#125;    &#125;;    <span class="hljs-keyword">abstract</span> <span class="hljs-function">String <span class="hljs-title">getInfo</span><span class="hljs-params">()</span></span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">for</span>(ConstantSpecificMethod csm : values())            System.out.println(csm.getInfo());    &#125;&#125;</code></pre></div><p>与使用匿名内部类相比，定义常量相关方法的语法更高效、简洁。<br>虽然enum有些限制，但一般而言，我们还是可以将其看做是类。</p><h4 id="19-10-1-使用enum的职责链"><a href="#19-10-1-使用enum的职责链" class="headerlink" title="19.10.1 使用enum的职责链"></a>19.10.1 使用enum的职责链</h4><p>Enum定义的次序决定了各个解决策略在应用时的次序。（职责链是一种设计模式，类似击鼓传花、部门审批流程。本级处理不了交给上级处理。程序员以多种不同的方式来解决问题，然后将他们链接在一起。当一个请求来临时，她遍历这个链，直到链中的某个解决方法能够处理该请求。搜索 enum 职责链 查看相关代码，书中例子太长了……）</p><h4 id="19-10-2-使用enum的状态机"><a href="#19-10-2-使用enum的状态机" class="headerlink" title="19.10.2 使用enum的状态机"></a>19.10.2 使用enum的状态机</h4><p>状态机可以具有有限个特定的状态，它根据输入，从一个状态转移到下一个状态，不过也可能存在瞬时状态，而一旦任务执行结束，状态机就会立刻离开瞬时状态。每个状态都具有某些可接受的输入，不同的输入会使状态机转移到不同的新状态。由于enum对其实例有严格限制，非常适合用来表现不同的状态和输入。</p><h2 id="19-11-多路分发"><a href="#19-11-多路分发" class="headerlink" title="19.11 多路分发"></a>19.11 多路分发</h2><h4 id="19-11-1-enum-多路分发"><a href="#19-11-1-enum-多路分发" class="headerlink" title="19.11.1 enum 多路分发"></a>19.11.1 enum 多路分发</h4><p> （挺拧巴的 原理就是按照枚举顺序提前定义好顺序，循环去比，不好理解。实操起来也比较麻烦）</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Outcome</span> &#123;</span> WIN, LOSE, DRAW &#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RoShamBo2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Competitor</span>&lt;<span class="hljs-title">RoShamBo2</span>&gt; &#123;</span>    <span class="hljs-comment">// 在此处是按顺序定义好，比如 PAPER vs PAPER = DRAW</span>    ROCK(Outcome.LOSE, Outcome.WIN, Outcome.DRAW),    PAPER(Outcome.DRAW, Outcome.LOSE, Outcome.WIN),    SCISSORS(Outcome.WIN, Outcome.DRAW, Outcome.LOSE);    <span class="hljs-keyword">private</span> Outcome vPAPER, vSCISSORS, vROCK;    RoShamBo2(Outcome paper,Outcome scissors,Outcome rock) &#123;        <span class="hljs-keyword">this</span>.vPAPER = paper;        <span class="hljs-keyword">this</span>.vSCISSORS = scissors;        <span class="hljs-keyword">this</span>.vROCK = rock;    &#125;    <span class="hljs-keyword">public</span> Outcome compete(RoShamBo2 it) &#123;        <span class="hljs-keyword">switch</span>(it) &#123;<span class="hljs-symbol">            default:</span>            <span class="hljs-keyword">case</span> <span class="hljs-string">PAPER:</span> <span class="hljs-keyword">return</span> vPAPER;            <span class="hljs-keyword">case</span> <span class="hljs-string">SCISSORS:</span> <span class="hljs-keyword">return</span> vSCISSORS;            <span class="hljs-keyword">case</span> <span class="hljs-string">ROCK:</span> <span class="hljs-keyword">return</span> vROCK;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> Competitor&lt;T&gt;&gt; <span class="hljs-keyword">void</span> match(T a, T b) &#123;        System.out.println(a + <span class="hljs-string">" vs "</span> + b + <span class="hljs-string">": "</span> + a.compete(b));    &#125;    <span class="hljs-comment">/**     * 随机产生指定数量个场景（对象）进行游戏     * 调用了Enums工具方法Enums.random     * &lt;T extends Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt; 规定传入的参数必须同时是Enum&lt;T&gt;和Competitor&lt;T&gt;类型     * <span class="hljs-doctag">@param</span> rsbClass 用来比赛的对象     * <span class="hljs-doctag">@param</span> size 数量     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> Enum&lt;T&gt; &amp; Competitor&lt;T&gt;&gt;    <span class="hljs-keyword">void</span> play(Class&lt;T&gt; rsbClass, <span class="hljs-keyword">int</span> size) &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;            match(Enums.random(rsbClass), Enums.random(rsbClass));        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] argv) &#123;        play(RoShamBo2.<span class="hljs-keyword">class</span>, <span class="hljs-number">20</span>);    &#125;&#125;</code></pre></div><h4 id="19-11-2-使用常量相关的方法"><a href="#19-11-2-使用常量相关的方法" class="headerlink" title="19.11.2 使用常量相关的方法"></a>19.11.2 使用常量相关的方法</h4><p>常量相关的方法允许我们为每个enum实例提供方法的不同实现，这使得常量相关的方法似乎是实现多路并发的完美解决方案</p><h4 id="19-11-3-使用EnumMap-分发"><a href="#19-11-3-使用EnumMap-分发" class="headerlink" title="19.11.3 使用EnumMap 分发"></a>19.11.3 使用EnumMap 分发</h4><p>实现“真正”的两路分发。</p><h4 id="19-11-3-使用二维数组"><a href="#19-11-3-使用二维数组" class="headerlink" title="19.11.3 使用二维数组"></a>19.11.3 使用二维数组</h4><p>原理都差不多，定义好类似矩阵顺序，去数组中匹配。</p><h2 id="19-12-总结"><a href="#19-12-总结" class="headerlink" title="19.12 总结"></a>19.12 总结</h2><p>枚举本身不复杂， 但是与Java的其他功能结合使用，涉及的功能还是挺细碎繁琐的。尤其是多路分发，需要很好的理解枚举类顺序。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十八章</title>
    <link href="/2020/02/28/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0/"/>
    <url>/2020/02/28/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十八章-Java-I-O系统"><a href="#第十八章-Java-I-O系统" class="headerlink" title="第十八章 Java I/O系统"></a>第十八章 Java I/O系统</h1><h2 id="18-1-File类"><a href="#18-1-File类" class="headerlink" title="18.1 File类"></a>18.1 File类</h2><p>能代表一个特定文件的名称，又能代表一组文件的名称。</p><p>暂先跳过。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十七章</title>
    <link href="/2020/02/23/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/"/>
    <url>/2020/02/23/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十七章-容器深入研究"><a href="#第十七章-容器深入研究" class="headerlink" title="第十七章 容器深入研究"></a>第十七章 容器深入研究</h1><p>Java容器类库成熟 完备 易用。</p><h2 id="17-1-完整的容器分类法"><a href="#17-1-完整的容器分类法" class="headerlink" title="17.1 完整的容器分类法"></a>17.1 完整的容器分类法</h2><p>Java SE5新添加了：</p><ul><li>Queue接口及其实现PriorityQueue及各种风格的BlockingQueue（多线程）；</li><li>ConcurrentMap及其实现的ConcurrentHashMap（多线程）；</li><li>CopyOnWriteArrayList和CopyOnWriteArraySet（多线程）；</li><li>EnumSet和EnumMap（enum）；</li><li>Collection类中的多个便利方法。</li></ul><h2 id="17-2-填充容器"><a href="#17-2-填充容器" class="headerlink" title="17.2 填充容器"></a>17.2 填充容器</h2><p>Collections.nCopies() 所有引用都被设置为指向相同的对象；例： </p><div class="hljs"><pre><code class="hljs undefined">List&lt;StringAddress&gt;  ls = Collections.nCopies(<span class="hljs-number">4</span>, new StringAddress(<span class="hljs-string">"helli"</span>));<span class="hljs-comment">//output ls</span>[StringAddress@<span class="hljs-number">82</span>ba41 Hello,StringAddress@<span class="hljs-number">82</span>ba41 Hello,StringAddress@<span class="hljs-number">82</span>ba41 Hello,StringAddress@<span class="hljs-number">82</span>ba41 Hello]</code></pre></div><p>Collections.fill() 只能替换已经存在的元素，而不能添加新元素。</p><h4 id="17-2-1-一种Generator解决方案"><a href="#17-2-1-一种Generator解决方案" class="headerlink" title="17.2.1 一种Generator解决方案"></a>17.2.1 一种Generator解决方案</h4><p>Collection生成器CollectionData：</p><p><strong>所有collection子类都有一个接受另一个Collection对象的构造器，用来填充数据</strong></p><p>CollectionData体现了适配器模式的设计思想，它能把实现Generator接口的类的对象(包括上一章数组中的各种RandomGenerator)都复制到自身当中</p><p><strong>直接上代码，看完代码在看中文解释会更清晰（tij 的心得，哈哈，上来看简介是真看不懂，再不济可以Google ，只要弄明白他要说的 再回来看解析就会清晰很多）</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.LinkedHashSet;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    T next();&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectionData</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">ArrayList</span></span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final long serialVersionUID = <span class="hljs-number">1</span>L;    <span class="hljs-keyword">public</span> CollectionData(Generator&lt;T&gt; gen, int quantity) &#123;        <span class="hljs-keyword">for</span> (int i = <span class="hljs-number">0</span>; i &lt; quantity; i++)            add(gen.next());    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; CollectionData&lt;T&gt; list(Generator&lt;T&gt; gen, int quantity) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">CollectionData</span>&lt;T&gt;(gen, quantity);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Generator</span></span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span>[] items = &#123; <span class="hljs-string">"Dog"</span>, <span class="hljs-string">"Pig"</span>, <span class="hljs-string">"Cat"</span> &#125;;    <span class="hljs-keyword">private</span> int index;    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> next() &#123;        <span class="hljs-keyword">return</span> items[index++];    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;        Set&lt;<span class="hljs-keyword">String</span>&gt; <span class="hljs-keyword">set</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">LinkedHashSet</span>&lt;<span class="hljs-keyword">String</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">CollectionData</span>&lt;<span class="hljs-keyword">String</span>&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>(), <span class="hljs-number">2</span>));        System.out.println(<span class="hljs-keyword">set</span>); <span class="hljs-comment">// [Dog, Pig, Cat]</span>        <span class="hljs-keyword">set</span>.addAll(CollectionData.list(<span class="hljs-keyword">new</span> <span class="hljs-type">Animal</span>(), <span class="hljs-number">3</span>));        System.out.println(<span class="hljs-keyword">set</span>); <span class="hljs-comment">// [Dog, Pig, Cat]</span>    &#125;&#125;</code></pre></div><h4 id="17-2-12-Map生成器"><a href="#17-2-12-Map生成器" class="headerlink" title="17.2.12 Map生成器"></a>17.2.12 Map生成器</h4><p>思想与2.1 相同</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MapData</span><span class="hljs-params">(Generator&lt;Pair&lt;K,V&gt;&gt; gen,<span class="hljs-keyword">int</span> quantity)</span></span>&#123;    Pair&lt;K,V&gt; p=gen.next();    put(p.key,p.vaule);&#125;</code></pre></div><h4 id="17-2-3-使用Abstract类"><a href="#17-2-3-使用Abstract类" class="headerlink" title="17.2.3 使用Abstract类"></a>17.2.3 使用Abstract类</h4><p><strong>享元模式</strong>使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或整体。</p><p>书中的代码和解析比较不容易理解和啰嗦。用网上一段例子说明<br>典型的享元工厂类的代码如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightFactory</span> </span>&#123;    <span class="hljs-comment">//定义一个HashMap用于存储享元对象，实现享元池</span>    <span class="hljs-keyword">private</span> HashMap flyweights = <span class="hljs-keyword">new</span><span class="hljs-type">HashMap</span>();    <span class="hljs-keyword">public</span> Flyweight getFlyweight(<span class="hljs-keyword">String</span> key)&#123;        <span class="hljs-comment">//如果对象存在，则直接从享元池获取</span>        <span class="hljs-keyword">if</span>(flyweights.containsKey(key))&#123;            <span class="hljs-keyword">return</span>(Flyweight)flyweights.<span class="hljs-keyword">get</span>(key);        &#125;        <span class="hljs-comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span>        <span class="hljs-keyword">else</span> &#123;            Flyweight fw = <span class="hljs-keyword">new</span><span class="hljs-type">ConcreteFlyweight</span>();            flyweights.put(key,fw);            <span class="hljs-keyword">return</span> fw;        &#125;    &#125;&#125;</code></pre></div><p>不存在才创建，存在就get出来。</p><h2 id="17-3-Collection的功能方法"><a href="#17-3-Collection的功能方法" class="headerlink" title="17.3 Collection的功能方法"></a>17.3 Collection的功能方法</h2><p>主要介绍Collection的主要方法，子类可以拿来即用。</p><h2 id="17-4-可选操作"><a href="#17-4-可选操作" class="headerlink" title="17.4 可选操作"></a>17.4 可选操作</h2><p>实现类并不需要为这些方法提供功能定义。简单的说就是 List Map Set 都可以共用 Collection接口的方法，但是 就像 List 不能使用set 一样,虽然编译器不会检查，但是运行会抛出异常。</p><h2 id="17-5-List-的功能方法"><a href="#17-5-List-的功能方法" class="headerlink" title="17.5 List 的功能方法"></a>17.5 List 的功能方法</h2><p>常用list方法 iterator 等等。</p><h2 id="17-6-Set和存储顺序"><a href="#17-6-Set和存储顺序" class="headerlink" title="17.6 Set和存储顺序"></a>17.6 Set和存储顺序</h2><p>良好的编码风格：应该在覆盖equals()方法时，总是同时覆盖hashCode()方法。</p><p>SortedSet</p><ol><li>Comparator comparator() 返回当前Set中使用的Comparator；或者返回null表示以自然方式排序。</li><li>Object first() 返回容器中第一个元素。</li><li>Object last() 返回容器中第末一个元素。</li><li>SortedSet subSet(fromElement, toElement) 生成此Set的子集，范围从fromElement（包含）到toElement（不包含）。</li><li>SortedSet headSet(toElement) 生成此Set的子集，由小于toElement的元素组成。</li><li>SortedSet tailSet(fromElement) 生成此Set的子集，由大于或等于formElement的元素组成。</li></ol><p><strong>SortedSet的意思是按对象比较函数对元素排序，而不是元素插入次序，插入顺序可以用LinkedHashSet保存。</strong><br><a href="https://blog.csdn.net/trbbadboy/article/details/6939598" target="_blank" rel="noopener">https://blog.csdn.net/trbbadboy/article/details/6939598</a><br>贴上简单明了的例子</p><h2 id="17-7-队列"><a href="#17-7-队列" class="headerlink" title="17.7 队列"></a>17.7 队列</h2><ol><li><p>优先级队列 PriorityQueue  <a href="https://www.jianshu.com/p/c577796e537a" target="_blank" rel="noopener">https://www.jianshu.com/p/c577796e537a</a> 这篇文章讲解到位。<br>Queue指先进先出的队列。Java中Queue为一个接口，集成Collection接口，实现可以为LinkedBlockingQueue,LinkedList,PriorityQueue等。<br>普通队列特点，先进先出。插入队列和移出队列的时间复杂度都为O(1)。<br>优先级队列，不同于普通队列，优先级队列默认按照元素的自然顺序排序（也可以重写comparator接口compare方法进行自定义排序）插入。移出队列和普通队列一样，但插入队列的时间复杂度与元素个数N有关，时间复杂度为O（logN）。</p></li><li><p>双向队列 Deque<br> 两端放入元素并提取他们，不是特别常用</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deque</span>&lt;T&gt; &#123;</span>     <span class="hljs-keyword">private</span> LinkedList&lt;T&gt; <span class="hljs-built_in">deque</span> = <span class="hljs-keyword">new</span> LinkedList&lt;T&gt;();     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addFirst</span><span class="hljs-params">(T e)</span> </span>&#123; <span class="hljs-built_in">deque</span>.addFirst(e); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(T e)</span> </span>&#123; <span class="hljs-built_in">deque</span>.addLast(e); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getFirst</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.getFirst(); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getLast</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.getLast(); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.removeFirst(); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">removeLast</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.removeLast(); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.size(); &#125;     <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">deque</span>.toString(); &#125;     <span class="hljs-comment">// And other methods as necessary... </span>&#125;</code></pre></div></li></ol><h2 id="17-8-理解Map"><a href="#17-8-理解Map" class="headerlink" title="17.8 理解Map"></a>17.8 理解Map</h2><p>开始的Map 用get 取值 效率最低 因为要从头轮询equals比较key值 ，只是简单并没有效率。</p><h4 id="17-8-1-性能"><a href="#17-8-1-性能" class="headerlink" title="17.8.1 性能"></a>17.8.1 性能</h4><p>get()线性搜索，效率低下，HsahMap 因此而生。HsahMap使用了散列码，，hashcode() 是 Object中的方法，因此所有的Java对象都能产生散列码。</p><p>Treemap 查询键值对他们会被排序（由Comparable 或者 Comparator决定）。</p><h4 id="17-8-2-SortedMap"><a href="#17-8-2-SortedMap" class="headerlink" title="17.8.2 SortedMap"></a>17.8.2 SortedMap</h4><p>使用SortedMap（TreeMap是其现阶段的唯一实现），可以确保键处于排序状态。</p><ol><li>Comparator comparator() 返回当前Map中使用的Comparator；或者返回null表示以自然方式排序。</li><li>T firstKey() 返回Map中的第一个键。</li><li>T lastKey() 返回Map中的第末一个键。</li><li>SortedMap subMap(fromKey, toKey) 生成此Map的子集，范围从fromKey（包含）到toKey（不包含）的键确定。</li><li>SortedMap headMap(toKey) 生成此Map的子集，由小于toKey的键确定的键值对组成。</li><li>SortedMap tailMap(fromKey) 生成此Map的子集，由大于或等于fromKey的键确定的键值对组成。</li></ol><h4 id="17-8-2-LinkedHashMap"><a href="#17-8-2-LinkedHashMap" class="headerlink" title="17.8.2 LinkedHashMap"></a>17.8.2 LinkedHashMap</h4><p>两个特点：</p><ol><li>为了提高速度，散列化所有元素，，遍历时候又以元素的插入顺序返回键值对，</li><li>可以在构造器里第三个参数设置accessOrder true，在我们访问了一个Entry&lt;K,V&gt;时，我们会调用afterNodeAccess()方法，将我们当前访问的节点放入到链表的末尾，利用这个特性便可以区分谁是最近访问，谁是最近最不常访问元素了。boolean removeEldestEntry(Map.Entry)该方法返回值为true时，会删除最近最不常使用的元素，也就是double-link的头部节点，当插入一个新节点之后removeEldestEntry()方法会被put()、putAll()方法调用，我们可以通过override该方法，来控制删除最旧节点的条件。<br>同redis淘汰策略的 <strong>LRU 算法</strong>。没有访问的放在最前面。对于定期清理节省空间或实现LRU缓存以下案例得以实现。</li></ol><p>简单案例：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Map.Entry;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-comment">/* * 为最近最少使用（LRU）缓存策略设计一个数据结构， * 它应该支持以下操作：获取数据（get）和写入数据（set）。 * 获取数据get(key)：如果缓存中存在key，则获取其数据值（通常是正数），否则返回-1。 * 写入数据set(key, value)：如果key还没有在缓存中，则写入其数据值。 * 当缓存达到上限，它应该在写入新数据之前删除最近最少使用的数据用来腾出空闲位置。  * */</span><span class="hljs-keyword">public</span> class LRUCache&lt;K, V&gt;&#123;    LinkedHashMap&lt;K,V&gt; cache = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> cacheSize;    <span class="hljs-keyword">public</span> LRUCache(<span class="hljs-built_in">int</span> cacheSize)&#123;        <span class="hljs-keyword">this</span>.cacheSize = (<span class="hljs-built_in">int</span>) Math.<span class="hljs-built_in">ceil</span> (cacheSize / <span class="hljs-number">0.75</span>f) + <span class="hljs-number">1</span>;  <span class="hljs-comment">// ceil浮点数向上取整数</span>        cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;K,V&gt;(<span class="hljs-keyword">this</span>.cacheSize,<span class="hljs-number">0.75</span>f,<span class="hljs-keyword">true</span>)&#123;  <span class="hljs-comment">//boolean accessOrder用来控制访问顺序的，默认设置为false，在访问之后，不会将当前访问的元素插入到链表尾部</span>          <span class="hljs-comment">//内部类来重写removeEldestEntry()方法</span>        @Override          <span class="hljs-keyword">protected</span> <span class="hljs-built_in">boolean</span> removeEldestEntry (Map.Entry&lt;K, V&gt; eldest)&#123;              System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"size="</span>+<span class="hljs-built_in">size</span>());              <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() &gt; cacheSize; <span class="hljs-comment">//当前size()大于了cacheSize便删掉头部的元素</span>          &#125;        &#125;;    &#125;        <span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(K <span class="hljs-built_in">key</span>)&#123;   <span class="hljs-comment">//如果使用继承的话就用getE而不是get，防止覆盖了父类的该方法</span>       <span class="hljs-keyword">return</span> (V) cache.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>);    &#125;    <span class="hljs-keyword">public</span> V <span class="hljs-built_in">set</span>(K <span class="hljs-built_in">key</span>,V value)&#123;       <span class="hljs-keyword">return</span> cache.put(<span class="hljs-built_in">key</span>, value);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> getCacheSize() &#123;        <span class="hljs-keyword">return</span> cacheSize;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> setCacheSize(<span class="hljs-built_in">int</span> cacheSize) &#123;        <span class="hljs-keyword">this</span>.cacheSize = cacheSize;    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> printCache()&#123;        <span class="hljs-keyword">for</span>(Iterator it = cache.entrySet().iterator();it.hasNext();)&#123;            Entry&lt;K,V&gt; entry = (Entry&lt;K, V&gt;)it.next();            <span class="hljs-keyword">if</span>(!<span class="hljs-string">""</span>.equals(entry.getValue()))&#123;                System.out.<span class="hljs-built_in">println</span>(entry.getKey() + <span class="hljs-string">"\t"</span> + entry.getValue());             &#125;        &#125;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"------"</span>);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> PrintlnCache()&#123;        Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="hljs-built_in">set</span> = cache.entrySet();        <span class="hljs-keyword">for</span>(Entry&lt;K,V&gt; entry : <span class="hljs-built_in">set</span>)&#123;            K <span class="hljs-built_in">key</span> = entry.getKey();            V value = entry.getValue();            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"key:"</span>+<span class="hljs-built_in">key</span>+<span class="hljs-string">"value:"</span>+value);        &#125;            &#125;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;        LRUCache&lt;<span class="hljs-keyword">String</span>,Integer&gt; lrucache = <span class="hljs-keyword">new</span> LRUCache&lt;<span class="hljs-keyword">String</span>,Integer&gt;(<span class="hljs-number">3</span>);        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">1</span>);        lrucache.printCache();        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"bbb"</span>, <span class="hljs-number">2</span>);        lrucache.printCache();        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"ccc"</span>, <span class="hljs-number">3</span>);        lrucache.printCache();        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"ddd"</span>, <span class="hljs-number">4</span>);        lrucache.printCache();        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"eee"</span>, <span class="hljs-number">5</span>);        lrucache.printCache();        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"这是访问了ddd后的结果"</span>);        lrucache.<span class="hljs-built_in">get</span>(<span class="hljs-string">"ddd"</span>);        lrucache.printCache();        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"fff"</span>, <span class="hljs-number">6</span>);        lrucache.printCache();        lrucache.<span class="hljs-built_in">set</span>(<span class="hljs-string">"aaa"</span>, <span class="hljs-number">7</span>);        lrucache.printCache();    &#125;&#125;</code></pre></div><h2 id="17-9-散列与散列码"><a href="#17-9-散列与散列码" class="headerlink" title="17.9 散列与散列码"></a>17.9 散列与散列码</h2><p>Object的hashCode()默认使用当前对象的地址计算散列码，equals()比较对象的地址。</p><p>覆盖hashCode()的同时覆盖equals()方法，正确的equals()方法的五个条件：</p><ul><li>自反性</li><li>对称性</li><li>传递性</li><li>一致性</li><li>对任何不是null的x，x.equals(null)一定返回false</li></ul><h4 id="17-9-1-理解hashcode-散列码"><a href="#17-9-1-理解hashcode-散列码" class="headerlink" title="17.9.1 理解hashcode()散列码"></a>17.9.1 理解hashcode()散列码</h4><p>hashMap 使用 key 的 hashcode 来保存键值对。</p><h4 id="17-9-2-为速度而散列"><a href="#17-9-2-为速度而散列" class="headerlink" title="17.9.2 为速度而散列"></a>17.9.2 为速度而散列</h4><p>通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在Object中的、且可被覆盖的hashCode()（散列函数）方法生成。</p><p>查询一个值的过程首先是计算散列码，然后使用散列码查询数组。如果能够保证没有冲突（如果值的数量是固定的，那么就有可能），那就有了一个完美的散列函数，但是这种情况是特例。通常，冲突由外部链接处理：数组并不直接保存值，而是保存值的List。</p><p>由于散列表中的“槽位”（slot）通常被称为桶位（bucket），因此我们将表示实际散列表的数组命名为bucket。为使散列分布均匀，桶的数量通常使用质数。</p><p><strong>保证时间复杂度O(1) 是在 没有hash冲突的情况下。</strong></p><hr><p><strong>HashMap源码分析：</strong><br>（引用自网络）</p><p>在这之前，先介绍一下负载因子和容量的属性。大家都知道其实一个HashMap的实际容量就是因子×容量，其默认值是16×0.75=12；这个很重要，对效率很一定影响！当存入HashMap的对象超过这个容量时，HashMap就会重新构造存取表。这就是一个大问题，我后面慢慢介绍，反正，如果你已经知道你大概要存放多少个对象，最好设为该实际容量的能接受的数字。</p><p>两个关键的方法，put和get：</p><p>先有这样一个概念，HashMap是声明了Map，Cloneable, Serializable接口，继承AbstractMap类，里面的Iterator其实主要都是其内部类HashIterator和其他几个iterator类实现，当然还有一个很重要的继承了Map.Entry的Entry内部类。Entry内部类包含了hash、value、key和next这四个属性，很重要。put的源码如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> put(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>, <span class="hljs-keyword">Object</span> value) &#123;    <span class="hljs-keyword">Object</span> k = maskNull(<span class="hljs-built_in">key</span>); <span class="hljs-comment">// 这个就是判断键值是否为空，如果为空，它会返回一个static Object作为键值，这就是为什么HashMap允许空键值的原因。</span>    <span class="hljs-built_in">int</span> hash = hash(k);    <span class="hljs-built_in">int</span> i = indexFor(hash, table.length);    <span class="hljs-comment">// 其中hash就是通过key这个Object的hashCode()进行hash，然后通过indexFor获得在Object table的索引值。</span>    <span class="hljs-comment">// put其实是一个有返回的方法，它会把相同键值的put覆盖掉并返回旧的值。如下方法彻底说明了HashMap的结构，其实就是一个表加上在相应位置的Entry的链表：</span>    <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; eq(k, e.<span class="hljs-built_in">key</span>)) &#123;            <span class="hljs-keyword">Object</span> oldvalue = e.value;            e.value = value; <span class="hljs-comment">// 把新的值赋予给对应键值。</span>            e.recordAccess(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// 空方法，留待实现</span>            <span class="hljs-keyword">return</span> oldvalue; <span class="hljs-comment">// 返回相同键值的对应的旧的值。</span>        &#125;    &#125;    modCount++; <span class="hljs-comment">// 结构性更改的次数</span>    addEntry(hash, k, value, i); <span class="hljs-comment">// 添加新元素，关键所在！</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 没有相同的键值返回</span>&#125;</code></pre></div><p>我们把关键的方法拿出来分析：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">void</span> addEntry(<span class="hljs-built_in">int</span> hash, <span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>, <span class="hljs-keyword">Object</span> value, <span class="hljs-built_in">int</span> bucketIndex) &#123;        table[bucketIndex] = <span class="hljs-keyword">new</span> Entry(hash, <span class="hljs-built_in">key</span>, value, table[bucketIndex]);    <span class="hljs-comment">// 因为hash的算法有可能令不同的键值有相同的hash码并有相同的table索引，它们经过indexfor之后的索引一定为i，这样在new的时候这个Entry的next就会指向这个原本的table[i]，再有下一个也如此，形成一个链表，和put的循环对定e.next获得旧的值。</span>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>++ &gt;= threshold) <span class="hljs-comment">// 这个threshold就是能实际容纳的量</span>        resize(<span class="hljs-number">2</span> * table.length); <span class="hljs-comment">// 超出这个容量就会将Object table重构</span>        <span class="hljs-comment">// 所谓的重构也不神，就是建一个两倍大的table，然后再一个个indexfor进去。注意，这就是效率，如果你能让你的HashMap不需要重构那么多次，效率会大大提高！</span></code></pre></div><p> <strong>所谓的重构也不神，就是建一个两倍大的table，然后再一个个indexfor进去。注意，这就是效率，如果你能让你的HashMap不需要重构那么多次，效率会大大提高！</strong></p><h4 id="17-9-2-覆盖hashCode"><a href="#17-9-2-覆盖hashCode" class="headerlink" title="17.9.2 覆盖hashCode()"></a>17.9.2 覆盖hashCode()</h4><p>无论何时，对同一个对象调用hashCode()都应该生成相同的值。</p><p>要使hashCode()实用，它必须速度快，并且有意义。（即必须基于对象内容生成散列码）。</p><p>那么如何设计一个 hashCode 算法，书中设计了一个算法：</p><ol><li><p>把某个非 0 的常数值，比如 17，保存在一个名为 result 的 int 类型的变量中。</p></li><li><p>对于对象中的每个域，做如下操作：</p><ul><li><p>为该域计算 int 类型的哈希值 c ：</p><ul><li><p>如果该域是 boolean 类型，则计算 (f?1:0)</p></li><li><p>如果该域是 byte、char、short 或者 int 类型，则计算 (int)f</p></li><li><p>如果该域是 long 类型，则计算 (int)(f^(f&gt;&gt;&gt;32))</p></li><li><p>如果该域是 float 类型，则计算 Float.floatToIntBits(f)</p></li><li><p>如果该域是 double 类型，则计算 Double.doubleToLongBits(f)，然后重复第三个步骤。</p></li><li><p>如果该域是一个对象引用，并且该类的 equals 方法通过递归调用 equals 方法来比较这个域，同样为这个域递归的调用 hashCode，如果这个域为 null，则返回0。</p></li><li><p>如果该域是数组，则要把每一个元素当作单独的域来处理，递归的运用上述规则，如果数组域中的每个元素都很重要，那么可以使用 Arrays.hashCode 方法。</p></li></ul></li></ul></li></ol><div class="hljs"><pre><code>* 按照公式 result = 31 * result + c，把上面步骤 2.1 中计算得到的散列码 c 合并到 result 中。**选择值31是因为它是奇数质数。如果是偶数且乘法运算溢出，则信息将丢失，因为乘以2等于移位。使用质数的优势尚不清楚，但这是传统的。31的一个不错的特性是乘法可以用移位和减法来代替，以获得更好的性能：31 * i == (i &lt;&lt; 5) - i。JVM自动执行这种优化。**</code></pre></div><ol start="3"><li>返回 result</li></ol><h2 id="17-10-选择接口的不同实现"><a href="#17-10-选择接口的不同实现" class="headerlink" title="17.10 选择接口的不同实现"></a>17.10 选择接口的不同实现</h2><p>Map、List、Set和Queue</p><h4 id="17-10-1-性能测试框架"><a href="#17-10-1-性能测试框架" class="headerlink" title="17.10.1 性能测试框架"></a>17.10.1 性能测试框架</h4><p>计算所有操作所需的纳秒数。封装好Test 对象 使用。输出各种容器的纳秒数。</p><h4 id="17-10-2-对List-的选择"><a href="#17-10-2-对List-的选择" class="headerlink" title="17.10.2 对List 的选择"></a>17.10.2 对List 的选择</h4><p>将ArrayList作为默认首选，只有需要使用额外的功能，或者当程序的性能因为经常从表中间进行插入和删除操作而变差时，才去选择LinkedList。如果使用的是固定数量的元素，那么既可以使用背后有数组支撑的List，也可以选择真正的数组。</p><h4 id="17-10-3-微基准测试的危险"><a href="#17-10-3-微基准测试的危险" class="headerlink" title="17.10.3  微基准测试的危险"></a>17.10.3  微基准测试的危险</h4><p>剖析器可以把性能分析工作做得更好。Java Profiler</p><h4 id="17-10-4-对Set的选择"><a href="#17-10-4-对Set的选择" class="headerlink" title="17.10.4 对Set的选择"></a>17.10.4 对Set的选择</h4><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是最重要的操作。TreeSet存在的唯一原因是它可以维持元素的排序状态，所以当需要一个排好序的Set时，才应该使用TreeSet。</p><h4 id="17-10-5-对Map的选择"><a href="#17-10-5-对Map的选择" class="headerlink" title="17.10.5 对Map的选择"></a>17.10.5 对Map的选择</h4><p>调整HashMap以提高性能：</p><ul><li>容量：表中的桶位数。</li><li>初始容量：表在创建时所拥有的桶位数。</li><li>尺寸：表中当前存储的项数。</li><li>负载因子：尺寸/容量。（如0.75 是达到3/4再散列）</li></ul><h2 id="17-11-实用方法"><a href="#17-11-实用方法" class="headerlink" title="17.11 实用方法"></a>17.11 实用方法</h2><p>介绍 Collections 详细方法。</p><h4 id="17-11-1-List的排序和查询"><a href="#17-11-1-List的排序和查询" class="headerlink" title="17.11.1 List的排序和查询"></a>17.11.1 List的排序和查询</h4><p>List的排序和查询所使用的方法与对象数组所使用的相应方法有相同的名字和语法，只是用Collections的static方法替换为Arrays的方法而已。</p><h4 id="17-11-2-设定Collection或Map为不可修改"><a href="#17-11-2-设定Collection或Map为不可修改" class="headerlink" title="17.11.2 设定Collection或Map为不可修改"></a>17.11.2 设定Collection或Map为不可修改</h4><p>Collections.unmodifiableCollection() 有时候需要对它进行保护，避免返回结果被人修改。</p><p>Collections.unmodifiableCollection这个可以得到一个集合的镜像，它的返回结果不可直接被改变，否则会提示 :<br>Exception in thread “main” java.lang.UnsupportedOperationException</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CollectionsTest</span> &#123;            @<span class="hljs-function">Test      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;          Collection&lt;String&gt; c = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();                    Collection&lt;String&gt; s = Collections.unmodifiableCollection(c);                    c.<span class="hljs-keyword">add</span>(<span class="hljs-string">"str"</span>);                    System.<span class="hljs-keyword">out</span>.println(s);      &#125;    &#125;</code></pre></div><h4 id="17-11-3-Collection或Map同步控制"><a href="#17-11-3-Collection或Map同步控制" class="headerlink" title="17.11.3 Collection或Map同步控制"></a>17.11.3 Collection或Map同步控制</h4><p>Collections.synchronizedCollection() 采用装饰者模式实现 线程安全几个操作方法。</p><p>快速报错</p><p>获取遍历对象前添加元素 会抛出异常 ConcurrentModificationException，防止多个进程同时修改同一个容器的内容。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">// creating object of List&lt;String&gt;</span>            List&lt;<span class="hljs-keyword">String</span>&gt; vector = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;();            Iterator&lt;<span class="hljs-keyword">String</span>&gt; iterator = vector.iterator();            vector.<span class="hljs-built_in">add</span>(<span class="hljs-string">"A"</span>);            <span class="hljs-keyword">String</span> next = iterator.next();        &#125;        <span class="hljs-keyword">catch</span> (ConcurrentModificationException e) &#123;            System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"Exception thrown : "</span> + e);        &#125;    &#125;</code></pre></div><p>ConcurrentHashMap  CopyOnWriteArrayList  CopyOnWriteArraySet 都是使用了避免 ConcurrentModificationException 的错误。</p><h2 id="17-12-持有引用"><a href="#17-12-持有引用" class="headerlink" title="17.12 持有引用"></a>17.12 持有引用</h2><p>StrongReference SoftReference  WeakReference PhantomReference （后三个使用暂时有些迷糊 继续往后看）<br>WeakHashMap<br>这是一种节约存储空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利。</p><h2 id="17-13-Java-1-0-1-1-的容器"><a href="#17-13-Java-1-0-1-1-的容器" class="headerlink" title="17.13 Java 1.0/1.1 的容器"></a>17.13 Java 1.0/1.1 的容器</h2><ol><li><p>Vector和Enumeration<br> Vector基本可看做ArrayList。<br> Enumeration（枚举）只是接口而不是实现，应尽量使用iterator。</p></li><li><p>Hashtable</p></li><li><p>Stack<br> 继承Vector，而不是用Vector创建Stack。</p></li><li><p>BitSet<br> 高效存储大量“开/关”信息。其效率仅对空间而言，如果需要高效的访问时间，BitSet比本地数组稍慢一点。<br>BitSet的最小容量是long：64位。<br>如果拥有一个可以命名的固定的标志集合，那么EnumSet与BitSet相比，通常是一个更好的选择。</p></li></ol><h2 id="17-14-总结"><a href="#17-14-总结" class="headerlink" title="17.14 总结"></a>17.14 总结</h2><p>java容器对于面向对象来说是最重要的类库。最重要的hashcode 和如何编写 hashcode.</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十六章</title>
    <link href="/2020/02/23/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/"/>
    <url>/2020/02/23/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十六章-数组"><a href="#第十六章-数组" class="headerlink" title="第十六章 数组"></a>第十六章 数组</h1><p>&emsp;&emsp;时隔半年，又看回来了，在有点java基础知识和代码开发经验去面试发现基础细节还是不到位，于是需要继续巩固基础和细节……（任重而道远）</p><p>&emsp;&emsp;数组这章讲的比较少，简单总结一下， 数组尺寸不能该改变。大多时候，更复杂的结构，容器会更加适合。</p><h2 id="16-1-数组为什么特殊"><a href="#16-1-数组为什么特殊" class="headerlink" title="16.1 数组为什么特殊"></a>16.1 数组为什么特殊</h2><p>效率，效率，效率。没有泛型的容器是不可以持有基本类型的。 数组可以。</p><h2 id="16-2-数组是一级对象"><a href="#16-2-数组是一级对象" class="headerlink" title="16.2 数组是一级对象"></a>16.2 数组是一级对象</h2><p>[]语法是访问数组对象的唯一方式，可以隐式创建和显示的创建（new）。</p><h2 id="16-3-返回一个数组"><a href="#16-3-返回一个数组" class="headerlink" title="16.3 返回一个数组"></a>16.3 返回一个数组</h2><p>相比 c/c++可以返回一整个数组，而不用为数组负责。使用完后，垃圾回收器会自动清理。</p><h2 id="16-4-多维数组"><a href="#16-4-多维数组" class="headerlink" title="16.4 多维数组"></a>16.4 多维数组</h2><div class="hljs"><pre><code class="hljs undefined">int[][] a = &#123;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>&#125;&#125;;</code></pre></div><h2 id="16-5-数组与泛型"><a href="#16-5-数组与泛型" class="headerlink" title="16.5 数组与泛型"></a>16.5 数组与泛型</h2><p>数组和泛型不能很好的结合，因为编译器会擦除参数化类型信息，（具体可以查看.class文件）而数组必须知道确切类型，保证类型安全。</p><p>可以参数化数组本身类型 ，但是毫无意义。还可以创建一个非泛型数组，把泛型数据转型放入。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">List</span>&lt;String&gt; <span class="hljs-keyword">ls</span>;<span class="hljs-keyword">List</span>[] <span class="hljs-keyword">la</span> = new <span class="hljs-keyword">List</span>[10];<span class="hljs-keyword">ls</span> = (<span class="hljs-keyword">List</span>&lt;string&gt;[]) <span class="hljs-keyword">la</span>;</code></pre></div><h2 id="16-6-创建测试数据"><a href="#16-6-创建测试数据" class="headerlink" title="16.6 创建测试数据"></a>16.6 创建测试数据</h2><p>Array.fill(); 填充数组。 Generator 数据生成器。</p><h2 id="16-7-Array-实用功能"><a href="#16-7-Array-实用功能" class="headerlink" title="16.7 Array 实用功能"></a>16.7 Array 实用功能</h2><p>Arrays工具类有equals() sort() binarySearch() toString() hashCode() asList()</p><p>复制数组 System.arraycopy() 注⚠️ System.arraycopy() 不会自动包装和自动拆包，两个数组必须有确切类型。</p><p>Arrays重写了 equals() 比较数组。 数组相等的条件是元素个数必须相等，并且对应元素也相等。</p><p>数组元素比较 java.lang.Comparable  与 java.util.Collects.Comparator。<br>Comparable 具有天生的比较 只有 compareTo() 方法。<br>Comparator 可以自定义 重写compare 和equal。</p><p>数组排序</p><div class="hljs"><pre><code class="hljs undefined">Arrays.<span class="hljs-built_in">sort</span>(sa, <span class="hljs-keyword">String</span>.CASE_INSENSITIVE_ORDER);<span class="hljs-comment">// 忽略大小写，默认是大写在前</span></code></pre></div><p>Java 标准类库中的排序算法针对正排序的特殊类型进行了优化 – 针对基本类型设计的 ”快速排序“（Quicksort），以及针对对象设计的 ”稳定归并排序“。</p><p>如果数组已经排好序了，可以使用 Arrays.binarySearch() 执行快速查找。如果找到了目标，返回值大于等于 0，否则，它产生负返回值，表示若要保持数组的排序状态此目标元素所应该插入的位置。这个负值的计算公式是</p><ul><li>(插入点) - 1<br>”插入点“ 是指，第一个大于查找对象的元素在数组中的位置。</li></ul><p>如果数组包含重复的元素，则无法保证找到的是这些副本中的哪一个。</p><p>如果使用 Comparator 排序了某个对象数组（基本类型数组无法使用 Comparator 进行排序），在使用 binarySearch() 时必须提供同样的 Comparator（使用 binarySearch() 方法的重载版本）。</p><h2 id="16-8-总结"><a href="#16-8-总结" class="headerlink" title="16.8 总结"></a>16.8 总结</h2><p>数组强调性能而不是灵活。 java的设计如果当时抛弃了设计基本类型低级数组。java也许会成为真正的纯面向对象语言。随着时间推移，容器基本上是更好的选择。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十五章</title>
    <link href="/2019/08/12/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/"/>
    <url>/2019/08/12/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章 泛型"></a>第十五章 泛型</h1><p>&emsp;&emsp;一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义类，如果要编写可以用用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。</p><p>&emsp;&emsp;所以泛型实现了参数化类型概念，使代码可以应用于多种类型。</p><h2 id="15-1-与C-比较"><a href="#15-1-与C-比较" class="headerlink" title="15.1 与C++比较"></a>15.1 与C++比较</h2><p>了解C++模板的某些方面，有助于理解泛型的基础。</p><h2 id="15-2-简单泛型"><a href="#15-2-简单泛型" class="headerlink" title="15.2 简单泛型"></a>15.2 简单泛型</h2><p>Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Holder</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Object</span> a;    <span class="hljs-keyword">public</span> Holder (<span class="hljs-built_in">Object</span> a) &#123; <span class="hljs-keyword">this</span>.a = a; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-keyword">set</span>(<span class="hljs-built_in">Object</span> a) &#123; <span class="hljs-keyword">this</span>.a = a; &#125;    <span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-keyword">get</span>()&#123; <span class="hljs-keyword">return</span> a; &#125;&#125;</code></pre></div><p>这个类就可以接收所有类型。</p><h4 id="15-2-1-一个元组类库"><a href="#15-2-1-一个元组类库" class="headerlink" title="15.2.1 一个元组类库"></a>15.2.1 一个元组类库</h4><p>创建一个对象，用它持有想要返回的多个对象（在编译器就能确保类型安全）。这个概念称为元组，它将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但不允许再向其中存放新的对象。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TwoTuple</span>&lt;<span class="hljs-title">A</span>,<span class="hljs-title">B</span>&gt; </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> A first;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> B second;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TwoTuple</span><span class="hljs-params">(A a, B b)</span></span>&#123;first = a; second = b;&#125;&#125;</code></pre></div><h4 id="15-2-2-一个堆栈类"><a href="#15-2-2-一个堆栈类" class="headerlink" title="15.2.2 一个堆栈类"></a>15.2.2 一个堆栈类</h4><div class="hljs"><pre><code class="hljs undefined">Stack<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span>  LinkedList<span class="hljs-tag">&lt;<span class="hljs-name">T</span>&gt;</span></code></pre></div><h2 id="15-3-泛型接口"><a href="#15-3-泛型接口" class="headerlink" title="15.3 泛型接口"></a>15.3 泛型接口</h2><p>泛型也可以用于接口 例如 生成器（generator）</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>Generator&lt;T&gt;&#123;    T next();&#125;</code></pre></div><h2 id="15-4-泛型方法"><a href="#15-4-泛型方法" class="headerlink" title="15.4 泛型方法"></a>15.4 泛型方法</h2><p>泛型方法使得该方法能够独立于类而产生变化。</p><p>无论何时，只要你能做到，你就应该尽量使用泛型方法。</p><p>对于static的方法而言，无法访问泛型类的类型参数。如果static方法需要使用泛型能力，就必须使其成为泛型方法。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(T x)</span></span>&#123;&#125;</code></pre></div><h2 id="15-5-匿名内部类"><a href="#15-5-匿名内部类" class="headerlink" title="15.5 匿名内部类"></a>15.5 匿名内部类</h2><p>泛型可以应用于内部类及匿名内部类。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Generator&lt;Teller&gt; generator=<span class="hljs-keyword">new</span> <span class="hljs-type">Generator</span>&lt;Teller&gt;()&#123;    <span class="hljs-keyword">public</span> Teller next()&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Teller</span>();&#125;&#125;</code></pre></div><h2 id="15-6-构建复杂模型"><a href="#15-6-构建复杂模型" class="headerlink" title="15.6 构建复杂模型"></a>15.6 构建复杂模型</h2><div class="hljs"><pre><code class="hljs undefined">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TupleList&lt;A</span>,<span class="hljs-title">B</span>,<span class="hljs-title">C</span>,<span class="hljs-title">D&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ArrayList&lt;FourTuple&lt;A</span>,<span class="hljs-title">B</span>,<span class="hljs-title">C</span>,<span class="hljs-title">D&gt;&gt;</span></span>&#123;&#125;</code></pre></div><h2 id="15-7-擦除的神秘之处"><a href="#15-7-擦除的神秘之处" class="headerlink" title="15.7 擦除的神秘之处"></a>15.7 擦除的神秘之处</h2><p>在泛型代码内部，无法获得任何有关泛型参数类型的信息。<br>Java泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。</p><h4 id="15-7-1-C-的方式"><a href="#15-7-1-C-的方式" class="headerlink" title="15.7.1 C++的方式"></a>15.7.1 C++的方式</h4><p>模板被实例化时，模板代码知道其模板参数的类型。</p><p>Java泛型的参数类型将擦除到它的第一个边界。</p><p>只有当你希望使用的类型参数比某个具体类型更加“泛化”时，即当你希望代码能够跨多个类工作时，使用泛型才有所帮助。</p><h4 id="15-7-2-迁移兼容性"><a href="#15-7-2-迁移兼容性" class="headerlink" title="15.7.2 迁移兼容性"></a>15.7.2 迁移兼容性</h4><p>如果用C++的方式实现，类型参数上执行基于类型语言操作和反射操作。擦除减少了泛型的泛化性。</p><p>泛型类型只有在静态类型检查期才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为它们的非泛型上届。</p><p>通过允许非泛型代码与泛型代码共存，擦除使得这种向着泛型迁移成为可能。</p><h4 id="15-7-3-擦除的问题"><a href="#15-7-3-擦除的问题" class="headerlink" title="15.7.3 擦除的问题"></a>15.7.3 擦除的问题</h4><p>泛型不能用于显式地引用运行时类型的操作之中，例如转型、instanceof操作和new表达式。（看起来好像拥有有关参数的类型信息而已）</p><p>另外，擦除和迁移兼容性意味着，使用泛型并不是强制的。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Base&lt;T&gt;</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Base</span></span>&#123;&#125;</code></pre></div><h4 id="15-7-4-边界处的动作"><a href="#15-7-4-边界处的动作" class="headerlink" title="15.7.4 边界处的动作"></a>15.7.4 边界处的动作</h4><p>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入代码的地点。</p><p>泛型中的所有动作都发生在边界处——对待传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十四章</title>
    <link href="/2019/08/10/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
    <url>/2019/08/10/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章 类型信息"></a>第十四章 类型信息</h1><p>&emsp;&emsp;RTTI（Run-Time-Type-Information），运行时类型信息。本章讲解Java 如何在编译时期识别对象和类的信息。另一种是“反射”机制，它允许在运行时候发现和使用类的信息。</p><h2 id="15-1-为什么需要RTTI"><a href="#15-1-为什么需要RTTI" class="headerlink" title="15.1 为什么需要RTTI"></a>15.1 为什么需要RTTI</h2><p>&emsp;&emsp;在多态的过程中，基类的派生类使用基类提供的方法时，动态绑定以及向上转型相关，在最后阶段运行过程中找到自己对应的派生类。也正是有了RTTI，编译器才能正确的找到对应的派生类。上述思想是Java中多态思想的体现，多态也是Java中设计的关键思想，尽量使代码尽可能少的了解其具体的类型，而只与通用的类（基类）打交道。这种设计使代码逻辑更加简单、易于理解。</p><h2 id="15-2-Class对象"><a href="#15-2-Class对象" class="headerlink" title="15.2 Class对象"></a>15.2 Class对象</h2><p>&emsp;&emsp;要理解RTTI在Java中的工作原理，首先要知道类型信息在运行时是如何表示的。这项工作是由称为Class对象的一种特殊的对象表示的。面向对象思想告诉我们，万事万物都是对象，Java中除了基本的数据类型，其它的都是对象。那么如果我们有如下代码：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">Student s</span> = new Student();</code></pre></div><p>&emsp;&emsp;我们使用new Student（）创建了一个Student类的对象，那么Student类又是不是对象呢？没错，如前文所说，万事万物都是对象，这里Student就是Class的对象，也就是说任何声明定义的类，都是Class类的类对象。当编译器编译完一个类时，在同名的.class文件中就会保存这个类的Class对象。而为了生成这个对象，运行这个类的JVM会使用一个称作是“类加载器”的子系统。</p><p>&emsp;&emsp;类加载器子系统实际上可以包含一条类加载器链，但只有一个原生的类加载器，它是JVM实现的一部分，用来加载所谓的可信类，以及JavaAPI。如果还需要其它特殊的操作，比如支持Web服务应用，或者是在网络上下载类，那么就可以在类加载器链上挂载额外的类加载器。</p><p>&emsp;&emsp;所有的类在其第一次加载的时候，都被动态的加载到JVM中，当程序创建第一个类的静态成员引用时，就会被加载。这也说明类的构造器也是类的静态方法，即使在构造器之前并没有使用static关键字。因此使用new关键词创建的类的新的对象，也会被当做是类的静态成员引用。也正是如此，Java程序在运行之前并非完全加载，动态加载在诸如C++这类的静态加载语言是无法实现的。</p><p>&emsp;&emsp;一旦某个类的Class对象被载入内存，它就用来创建这个类的所有对象，如下示例说明这点：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Candy</span>&#123;<span class="hljs-keyword">static</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Loading Candy"</span>);&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Gum</span>&#123;<span class="hljs-keyword">static</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Loading Gum"</span>);&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Cookie</span>&#123;<span class="hljs-keyword">static</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Loading Cookie"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SweetShop</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Inside main"</span>);<span class="hljs-keyword">new</span> Candy();System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After Creating Candy"</span>);<span class="hljs-keyword">try</span>&#123;Class.forName(<span class="hljs-string">"com.chenxyt.java.practice.Gum"</span>);&#125;<span class="hljs-keyword">catch</span>(ClassNotFoundException e)&#123;System.err.println(<span class="hljs-string">"Gum Not found"</span>);&#125;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After Creating Gum"</span>);<span class="hljs-keyword">new</span> Cookie();System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After Creating Cookie"</span>);&#125;&#125;</code></pre></div><p>&emsp;&emsp;Class对象仅在需要的时候被加载，static初始化是在类加载时候进行的。需要注意的是Class.forName（）这个方法，它是Class类的一个静态方法，所有的类都是Class类的对象，forName（）是取得Class对象引用的一种方法。它使用目标类名作为参数，返回Class对象的引用。如果找不到指定的类名则抛出ClassNotFound异常。无论何时你想获取到类的运行时使用的类型信息，就必须要获得恰当的Class对象的引用，Class.forName（）是实现此功能的捷径。因此你不需要为了获得Class对象的引用而持有该类型的对象。但是如果你已经拥有了一个指定类型的对象，那么就可以使用.getClass方法获取Class对象的引用。这个方法属于Object，它将返回表示该对象实际类型的Class对象引用。</p><p><strong>Java中除了以上两种Class.forName()和obj.getClass()可以产生类的对象引用，还有一种类字面常量的形式：</strong></p><div class="hljs"><pre><code class="hljs undefined">FancyToy.<span class="hljs-built_in">class</span>：</code></pre></div><p>&emsp;&emsp;这样做不仅简单，而且更加安全，因为在编译时即可检查，无需使用try-catch语句，所以更加高效。类字面常量不仅可以应用与普通的类，还可以应用在基本数据类型，以及接口和数组中。此外对于基本数据类型的包装器类，它还有个TYPE字段，TYPE是一个引用，指向对应的基本数据类型的Class对象。<br>&emsp;&emsp;此处有一点非常重要需要注意，当使用.class来创建对象的引用时，不会自动的初始化该Class对象。为了使用类而做的准备工作实际上包含三个步骤：</p><ol><li>加载：这是由类加载器执行的，该步骤将查找字节码（通常在classpath路径查找，但不是必须的），并从这些字节码中创建一个Class对象；</li><li>链接：在链接阶段验证类的字节码，为静态域分配存储空间，并且如果必要的话，会解析这个类创建的对其它类的所有引用；</li><li>初始化：如果该类具有超类，则对其进行初始化，执行静态初始化器和静态初始化块。<br>初始化被延迟到了对静态方法（构造器也是隐式的静态方法）或者非常数静态域进行首次引用时才执行：<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">class</span> Initable&#123; <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> staticFinal = <span class="hljs-number">45</span>; <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> staticFinal2 = ClassInitialization.rand.nextInt(<span class="hljs-number">1000</span>); <span class="hljs-keyword">static</span>&#123;  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Initializing Initable"</span>);  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Initable---------------"</span>); &#125;&#125;<span class="hljs-keyword">class</span> Initable2&#123; <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticNonFinal = <span class="hljs-number">145</span>; <span class="hljs-keyword">static</span>&#123;  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Initializing Initable2"</span>);  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Initable2---------------"</span>); &#125;&#125;<span class="hljs-keyword">class</span> Initable3&#123; <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> staticNonFinal = <span class="hljs-number">54</span>; <span class="hljs-keyword">static</span>&#123;  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Initializing Initable3"</span>);  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Initable3---------------"</span>); &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> ClassInitialization &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Random rand = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">45</span>); <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;  <span class="hljs-keyword">Class</span> initable = Initable.<span class="hljs-keyword">class</span>;  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"After Creating Initable Ref"</span>);  System.out.<span class="hljs-keyword">println</span>(Initable.staticFinal);  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"------------------"</span>);  System.out.<span class="hljs-keyword">println</span>(Initable.staticFinal2);  System.out.<span class="hljs-keyword">println</span>(Initable2.staticNonFinal);  <span class="hljs-keyword">Class</span> initable3 = <span class="hljs-keyword">Class</span>.forName(<span class="hljs-string">"com.chenxyt.java.practice.Initable3"</span>);  System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"After Creating Initable3 Ref"</span>);  System.out.<span class="hljs-keyword">println</span>(Initable3.staticNonFinal); &#125;&#125;</code></pre></div></li></ol><p>.class并不会引发初始化，相反使用Class.forName（）时则立刻完成了初始化的功能。同时，如果一个域被声明为static final的编译时常量，那么它可以不初始化类就被访问，就像Initable.staticFinal一样，但是仅仅被声明为static final并不会保证类不被初始化就能访问，就像Intable.staticFinal2那样，因为它不是编译时常量。<br>    如果一个static域不是final的，那么在对它访问的时候，总是要求在读取之前先进行链接（为这个域分配存储空间）和初始化（初始化该存储空间），就像在对Initable2.staticNonFinal的访问中看到这样。</p><p>Class类允许使用泛型指定相应的类型，如下两种形式均可：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> GenericClassReference &#123;<span class="hljs-keyword">public</span> static void main(String[] args) &#123;<span class="hljs-keyword">Class</span> intClass = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">class</span>;<span class="hljs-keyword">Class</span>&lt;<span class="hljs-keyword">Integer</span>&gt; genericIntClass = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">class</span>;genericIntClass = <span class="hljs-keyword">Integer</span>.<span class="hljs-keyword">class</span>;intClass = <span class="hljs-keyword">double</span>.<span class="hljs-keyword">class</span>;//类型不匹配//genericIntClass = <span class="hljs-keyword">double</span>.<span class="hljs-keyword">class</span>;&#125;&#125;</code></pre></div><p>&emsp;&emsp;普通的类引用不会产生警告信息，并可以被重新指定为其它类型的引用。而泛型类的引用只能被指定为指定的类型。通过使用泛型语法，可以使编译器做一些额外的类型检查。如果我们希望放松这种限制，那么似乎可以使用：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">Class</span>&lt;<span class="hljs-keyword">Number</span>&gt; genericClass = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">class</span>;</code></pre></div><p>&emsp;&emsp;因为Integer类继承自Number类，但实际上并不可以正常工作，因为Integer Class对象不是Number Class对象的子类。为了放松这种类型的限制，我们使用了通配符，它是Java泛型的一部分。通配符就是“？”表示任何事物。</p><p>&emsp;&emsp;尽管看起来这种形式与直接使用Class相同，但是它不会产生编译器警告信息。更确切的说使用通配符表示的是你并非是碰巧或者是由于疏忽而选择了一个非具体类的引用，而是你就是明确的选择了一个非具体的版本。使用通配符与extends关键字，可以有效的解决前边所说的继承的问题：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">Class</span>&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-keyword">Number</span>&gt; genericClass = <span class="hljs-built_in">int</span>.<span class="hljs-keyword">class</span>;</code></pre></div><p>表示创建一个Number 或是它子类的类对象。</p><h2 id="14-3-类型转换器先做检查"><a href="#14-3-类型转换器先做检查" class="headerlink" title="14.3 类型转换器先做检查"></a>14.3 类型转换器先做检查</h2><p>&emsp;&emsp;类型转换信息有两种，一种是传统的类型转换，由RTTI确保类型转换，如果执行了一个错误的类型转换，那么将抛出一个ClassCastException异常，另一种是代表对象类类型的Class对象，通过查询Class对象的信息获取运行时的所有状态。RTTI在Java中还有第三种类型转换的形式，就是使用关键字instanceof，它返回布尔值，判断某个对象是不是某个特定类的实例。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span><span class="hljs-comment">(x instanceof Dog)</span>&#123;    <span class="hljs-comment">(Dog)</span>x.bark<span class="hljs-comment">()</span>;&#125;</code></pre></div><p>&emsp;&emsp;这种先进行判断然后再使用的方式显得很必然，比如在进行向下转型的时候，如果不先进行判断，很容易发生ClassCastException异常。此外也提供了动态判断的形式isInstanceof（）方法。</p><h2 id="14-4-注册工厂"><a href="#14-4-注册工厂" class="headerlink" title="14.4 注册工厂"></a>14.4 注册工厂</h2><p>&emsp;&emsp;使用注册工厂的目的是将对象的创建工作交给类去完成，即创建一个工厂方法，然后进行多态的调用，从而为你创建恰当类型的对象。在如下的简单的版本中，工厂方法就是Factory接口中的Create方法。</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>Factory&lt;T&gt;&#123;T create();&#125;</code></pre></div><p>&emsp;&emsp;工厂方法，就是意味着我只提供一个创建实例的工厂方法，而无需每创建一个继承类就编写一个新的方法。关于工厂方法更多细节后边在设计模式模块专门再进行学习。</p><h2 id="14-5-instanceof与Class的等价性"><a href="#14-5-instanceof与Class的等价性" class="headerlink" title="14.5 instanceof与Class的等价性"></a>14.5 instanceof与Class的等价性</h2><p>instanceof与直接比较Class对象有一点很重要的区别</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> BaseType&#123;&#125;<span class="hljs-keyword">class</span> Derived <span class="hljs-keyword">extends</span> BaseType&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> FamilyVsExactType &#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> test(Object x)&#123;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Testing x of type"</span> + x.getClass());System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"x instance of BaseType"</span> + (x <span class="hljs-keyword">instanceof</span> BaseType));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"x instance of Derived"</span> + (x <span class="hljs-keyword">instanceof</span> Derived));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"BaseType.isInstance(x)"</span> + BaseType.<span class="hljs-keyword">class</span>.isInstance(x));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Derived isInstance(x)"</span> + Derived.<span class="hljs-keyword">class</span>.isInstance(x));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"x.getClass == BaseType.class"</span> + (x.getClass() == BaseType.<span class="hljs-keyword">class</span>));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"x.getClass == Derived.class"</span> + (x.getClass() == Derived.<span class="hljs-keyword">class</span>));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"x.getClass.equals(BaseType.class)"</span> + (x.getClass().equals(BaseType.<span class="hljs-keyword">class</span>)));System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"x.getClass.equals(Derived.class)"</span> + (x.getClass().equals(Derived.<span class="hljs-keyword">class</span>)));&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;test(<span class="hljs-keyword">new</span> BaseType());test(<span class="hljs-keyword">new</span> Derived());&#125;&#125;</code></pre></div><p>instanceof表示的是“你是这个类吗？或者你是这个类的子类吗？”而使用Class对象进行比较时，表示的则只有明确的类型信息，忽略了继承的关系。</p><h2 id="14-6-反射：运行时类型信息"><a href="#14-6-反射：运行时类型信息" class="headerlink" title="14.6 反射：运行时类型信息"></a>14.6 反射：运行时类型信息</h2><p>&emsp;&emsp;程序在编译的时候并不知道具体的类型信息，直到程序运行时通过反射才获取到了准确的类信息。这里提供了几个方法支持获取准确的类信息，以便创建动态的代码。使用Class类的getMethods（）方法可以获取这个类所包含的所有方法，使用getConstructors（）方法可以获取这个类的所有构造函数。前文也提到过，使用Class.forName（）可以用来动态的加载类。它的生成结果在编译的时候是不可知的，因此所有的方法特征信息和签名都是在运行时被提取出来的。</p><h2 id="14-7-动态代理"><a href="#14-7-动态代理" class="headerlink" title="14.7 动态代理"></a>14.7 动态代理</h2><p>&emsp;&emsp;代理是常用的设计模式之一，它的作用是在基本的对象操作之外，增加一些其它额外的操作。比如我想使用一个对象，同事想了解这个对象的运行过程，那么这个运行过程的监控显然就不能放在基本的对象代码中。有点类似前面文章中提到的组合类的思想，新建一个代理类，代理类引用要使用的对象，然后增加一些新的功能。<br>&emsp;&emsp;可以把代理模式类比成是中介，中介的目的是卖东西的基础上赚钱，卖东西就是基本操作，赚钱就是中介也就是代理做的额外的操作。下面一个示例展示简单的代理模式：</p><p>定义一个接口：</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface Interface </span>&#123;void doSomeThing();void somethingElse(String arg);&#125;</code></pre></div><p>这个接口的实现类，也就是前边所说的真正要操作的运行的对象：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span> </span>&#123; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"RealObject DoSomeThing"</span>);&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">somethingElse</span><span class="hljs-params">(String arg)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"RealObject somethingElse"</span>);&#125;&#125;</code></pre></div><p>定义一个代理类，代理类实现了Interface接口，同时通过传参的形式传入了前边的实现类，在完成实现类功能的基础上，做了自己的操作：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span></span>&#123;<span class="hljs-keyword">private</span> Interface proxied;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleProxy</span><span class="hljs-params">(Interface proxied)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated constructor stub</span><span class="hljs-keyword">this</span>.proxied = proxied;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"Proxy DoSomething"</span>);proxied.doSomeThing();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">somethingElse</span><span class="hljs-params">(String arg)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"Proxy somethingElse"</span>);proxied.somethingElse(arg);&#125;&#125;</code></pre></div><p>然后是这个接口的实现类，也就是前边所说的真正要操作的运行的对象：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RealObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span> </span>&#123; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"RealObject DoSomeThing"</span>);&#125; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">somethingElse</span><span class="hljs-params">(String arg)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"RealObject somethingElse"</span>);&#125;&#125;</code></pre></div><p> 然后定义一个代理类，代理类实现了Interface接口，同时通过传参的形式传入了前边的实现类，在完成实现类功能的基础上，做了自己的操作：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interface</span></span>&#123;<span class="hljs-keyword">private</span> Interface proxied;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SimpleProxy</span><span class="hljs-params">(Interface proxied)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated constructor stub</span><span class="hljs-keyword">this</span>.proxied = proxied;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSomeThing</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"Proxy DoSomething"</span>);proxied.doSomeThing();&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">somethingElse</span><span class="hljs-params">(String arg)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"Proxy somethingElse"</span>);proxied.somethingElse(arg);&#125;&#125;</code></pre></div><p>最后是Main方法，因为consumer方法传参是Interface接口，所以任何实现了它接口的实体类都可以当做参数。这里演示了使用基本的实体类和使用代理的区别，代理在完成普通实体类的功能基础上打印了自己的操作内容：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleProxyDemo</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">Interface iface</span>)</span>&#123;iface.doSomeThing();iface.somethingElse(<span class="hljs-string">"bobo"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;consumer(<span class="hljs-keyword">new</span> RealObject());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"=============="</span>);consumer(<span class="hljs-keyword">new</span> SimpleProxy(<span class="hljs-keyword">new</span> RealObject()));&#125;&#125;</code></pre></div><p>&emsp;&emsp;在任何时刻你若想实现一些与“实际”对象分离的额外操作，或者你希望很容易能对这部分操作做出修改，那么使用代理模式无疑是最为方便的。<br>&emsp;&emsp;Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态的创建代理，并且动态的处理对所代理方法的调用。动态代理所做的所有操作都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型，并确定相应的对策。下面用动态代理重写上边的示例。<br>&emsp;&emsp;Java中要实现动态代理类，必须要继承InvocationHandle这个类，这个类内部嵌入的对象是要被实现的真正的对象，同样使用构造方法传入，这个类唯一的一个方法invoke，它有三个参数，第一个参数是生成的动态代理类。既然动态代理是动态的创建代理，那么这个参数固然是所创建的动态代理，第二个参数是传入的对象执行的方法，第三个参数是传入的参数。最后将请求通过Method.invoke（）方法，传入必要的参数，执行代理对象的方法。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method; <span class="hljs-keyword">public</span> class DynamicProxyHandler implements InvocationHandler&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">Object</span> proxied;<span class="hljs-keyword">public</span> DynamicProxyHandler(<span class="hljs-keyword">Object</span> proxied) &#123;<span class="hljs-comment">// TODO Auto-generated constructor stub</span><span class="hljs-keyword">this</span>.proxied = proxied;&#125;@Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> invoke(<span class="hljs-keyword">Object</span> proxy, Method method, <span class="hljs-keyword">Object</span>[] args)<span class="hljs-keyword">throws</span> Throwable &#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"**** Proxy:"</span> + proxy.getClass() + <span class="hljs-string">",method:"</span> + method + <span class="hljs-string">",args "</span> + args );<span class="hljs-keyword">if</span>(args!=<span class="hljs-keyword">null</span>)&#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">Object</span> arg:args)&#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"  "</span> + arg);&#125;&#125;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> method.invoke(proxied, args);&#125;&#125;</code></pre></div><p>客户端类：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.lang.reflect.Proxy; <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SimpleDynamicProxyDemo &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> consumer(<span class="hljs-keyword">Interface</span> iface)&#123;iface.doSomeThing();iface.somethingElse(<span class="hljs-string">"DIDI"</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;RealObject real = <span class="hljs-keyword">new</span> RealObject();consumer(real);System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"========="</span>);<span class="hljs-keyword">Interface</span> proxy = (<span class="hljs-keyword">Interface</span>)Proxy.newProxyInstance(<span class="hljs-keyword">Interface</span>.<span class="hljs-keyword">class</span>.getClassLoader(),<span class="hljs-keyword">new</span> <span class="hljs-keyword">Class</span>[]&#123;<span class="hljs-keyword">Interface</span>.<span class="hljs-keyword">class</span>&#125;,<span class="hljs-keyword">new</span> DynamicProxyHandler(real));consumer(proxy);&#125;&#125;</code></pre></div><p>&emsp;&emsp;客户端类使用Proxy.newProxyInstance（）方法创建了一个代理对象。第一个参数是一个加载器，这里用的是系统加载器，所以使用其它类的加载器结果也是一样的，第二个参数是代理对象要实现的接口，第三个参数是Handler对象，表示我这个代理对象在调用方法时，会映射关联到哪个Hnadler上去，这里是关联到了我们定义的DynamicProxyHandler上，然后转由它的invoke方法执行对象方法。</p><p>我们可以在代理方法invoke（）中对诸如方法名、参数进行过滤，只执行指定的方法。</p><p><strong>Spring的AOP核心思想就是动态代理，现在更加理解了一些，简单表述一下就是在切入点处执行一写其它操作，如我这里是记录日志，然后执行正常的业务方法。记录日志就是脱离在实际业务之外的一些操作。</strong></p><p>##</p><h2 id="14-8-空对象"><a href="#14-8-空对象" class="headerlink" title="14.8 空对象"></a>14.8 空对象</h2><p>&emsp;&emsp;当一个对象为null的时候，任何对这个对象的操作都会引发异常。为了避免这种情况，当一个对象为null的时候，我们定义一个空对象赋值给它。何谓空对象呢？就是一个不存在实际意义但是不会引发异常的对象。</p><h2 id="14-9-接口与类型信息"><a href="#14-9-接口与类型信息" class="headerlink" title="14.9 接口与类型信息"></a>14.9 接口与类型信息</h2><p>&emsp;&emsp;接口或者是面向接口编程的重要目的是实现隔离，也就是解耦。但是通过类型信息，这种耦合还是会传播出去。也就是接口对解耦来说，并不是绝对的。如下示例：</p><p>定义一个接口A，它有唯一一个方法f</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>A&#123;public void f();&#125;</code></pre></div><p>接下来是接口的实现B，除了A中的方法，还有自己的方法g</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span></span>&#123; <span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"method f"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;    System.out.println(<span class="hljs-string">"method g"</span>);&#125;&#125;</code></pre></div><p>Main</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InterfaceViolation</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;A a = <span class="hljs-keyword">new</span> B();a.f();System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"a.getClass: "</span> + a.getClass().getName());<span class="hljs-keyword">if</span>(a instanceof B)&#123;B b = (B)a;b.g();&#125;&#125;&#125;</code></pre></div><p>这里通过使用RTTI，发现a是被当做B类型实现的，因此通过将其转型成B，可以调用了B中新加的方法。</p><p>    上面这种操作，完全合理并且可接受，但是提高了代码的耦合度，实际上并不允许这样做。解决办法是使用包访问权限来加以控制。</p><p>新定义一个实现类实现接口A：</p><div class="hljs"><pre><code class="hljs undefined">package com.chenxyt.java.practice; <span class="hljs-keyword">class</span> <span class="hljs-title">C</span> <span class="hljs-title">implements</span> <span class="hljs-title">A</span>&#123;@<span class="hljs-function">Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"C.f"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"C.g"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">u</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"C.u"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">v</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"C.v"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">w</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"C.w"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HidenC</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title">makeA</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> C();&#125;&#125;</code></pre></div><p>在另一个包中使用它：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.test;  <span class="hljs-keyword">import</span> java.lang.reflect.Method; <span class="hljs-keyword">import</span> com.chenxyt.java.practice.A;<span class="hljs-keyword">import</span> com.chenxyt.java.practice.HidenC; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HiddenImplementation</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;A a = HidenC.makeA();a.f();System.out.println(<span class="hljs-string">"a.getClass: "</span> + a.getClass().getName());<span class="hljs-comment">//编译错误 受包访问权限控制</span><span class="hljs-comment">/*if(a instanceof C)&#123;C c = (C)a;c.g();&#125;*/</span>callHiddenMethod(a,<span class="hljs-string">"g"</span>);callHiddenMethod(a,<span class="hljs-string">"v"</span>);callHiddenMethod(a,<span class="hljs-string">"u"</span>);callHiddenMethod(a,<span class="hljs-string">"w"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callHiddenMethod</span><span class="hljs-params">(Object a,String methodName)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;Method g = a.getClass().getDeclaredMethod(methodName);g.setAccessible(<span class="hljs-keyword">true</span>);g.invoke(a);&#125;&#125;</code></pre></div><p>由于包访问权限的限制，在另一个包中获取不到了C新定义的方法。但是如果知道方法名，依然可以通过反射调用所有的方法。</p><p>使用javap -private 可以看到包括private权限的方法在内的所有方法。因此任何人都可以获取到你这个类中方法名，然后通过反射调用他们。</p><p>内部类和匿名类 private域的方法也逃不过反射的查找。</p><h2 id="14-10-总结"><a href="#14-10-总结" class="headerlink" title="14.10 总结"></a>14.10 总结</h2><p>&emsp;&emsp;RTTI 允许匿名基类来发现类型信息。面向对象编程的目的是让我们在可以使用的地方都是用多态机制，只在必须以后使用RTTI。</p><p>&emsp;&emsp;然后使用多态机制的方法调用，要求我们拥有基类定义的控制权，这时候RTTI便是一种解决之道：科技城一个新类，然后添加你所需要的方法。在代码的其他地方，可以检查你自己特定的类型，并调用你自己的方法。这样不会破会对台性以及程序的扩展能力。</p><p>&emsp;&emsp;RTTI有时候能解决效率问题。也许你用多态用的很好，但是极端情况下可以使用RTTI。<strong>不要太早的关注程序的效率问题，这是歌 诱人的陷阱。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十三章</title>
    <link href="/2019/08/10/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
    <url>/2019/08/10/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十三章-字符串"><a href="#第十三章-字符串" class="headerlink" title="第十三章 字符串"></a>第十三章 字符串</h1><p>字符串操作是程序设计中的最常见的行为。</p><h2 id="13-1-不可变的string"><a href="#13-1-不可变的string" class="headerlink" title="13.1 不可变的string"></a>13.1 不可变的string</h2><p> String对象是不可变的，每一个看似修改了String值的方法，实际都是产生了一个新的字符串。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> class Immutable &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> upCase(<span class="hljs-keyword">String</span> s)&#123;<span class="hljs-built_in">return</span> s.toUpperCase();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<span class="hljs-keyword">String</span> q = <span class="hljs-string">"howdy"</span>;System.out.<span class="hljs-built_in">println</span>(q);<span class="hljs-keyword">String</span> qq = upCase(q);System.out.<span class="hljs-built_in">println</span>(qq);System.out.<span class="hljs-built_in">println</span>(q);&#125;&#125;</code></pre></div><p>当把q传给upCase方法时，实际上传递的是引用的一个拷贝。</p><p>方法的参数是用来传递信息的，而不是用来改变原有对象本身的。</p><h2 id="13-2-重载“-”与StringBuilder"><a href="#13-2-重载“-”与StringBuilder" class="headerlink" title="13.2 重载“+”与StringBuilder"></a>13.2 重载“+”与StringBuilder</h2><p>String对象是不可变的，所以指向它的任何引用都不会改变该对象的值。不可变性会对效率带来一个问题，为String对象重载“+”操作符就是一个例子，重载的意思是一个操作符应用与特定的类时被赋有特殊的意义。（用于String的“+”和”+=”是Java中仅有的两个重载过的操作符，Java不允许程序员自己重载操作符）<br>操作符“+”可以用来连接两个String</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> class Concatetion &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<span class="hljs-keyword">String</span> mango = <span class="hljs-string">"mango"</span>;<span class="hljs-keyword">String</span> s = <span class="hljs-string">"abc"</span> + mango + <span class="hljs-string">"def"</span> + <span class="hljs-number">42</span>;System.out.<span class="hljs-built_in">println</span>(s);&#125;&#125;</code></pre></div><p>&emsp;&emsp;上述代码的运行过程可能是这样的：<strong>String可能有一个append方法，然后它会生成一个新的String对象用来连接abc和mango，然后该对象再与def相连生成新的对象，依次类推</strong>。这样做的话会产生很多中间垃圾需要清理因此它效率极低。<br>可以使用JDK自带的反编译工具查看上述代码如何工作。</p><p>&emsp;&emsp;在编写一个类似toString（）的方法时，如果字符串较短时，我们可以使用普通的拼接方式，当字符串操作较为复杂的时候，我们在代码中直接创建一个StringBuilder对象进行操作效率会更加优异。</p><h2 id="13-3-无意识的递归"><a href="#13-3-无意识的递归" class="headerlink" title="13.3 无意识的递归"></a>13.3 无意识的递归</h2><p>使用toString（）方法打印出对象的内存地址，那么我们可能会考虑使用this关键字：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InfiniteRecursion</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"InfiniteRecursion address"</span> + <span class="hljs-keyword">this</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;List&lt;InfiniteRecursion&gt; v = <span class="hljs-keyword">new</span> ArrayList&lt;InfiniteRecursion&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;v.add(<span class="hljs-keyword">new</span> InfiniteRecursion());&#125;System.out.println(v);&#125;&#125;</code></pre></div><p>这里当运行</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">return</span> <span class="hljs-string">"InfiniteRecursion address"</span> + <span class="hljs-keyword">this</span>;</code></pre></div><p>时发生了类型转换，编译器发现“+”后边不是String类型，会试图转换成String类型，转换的方式就是调用toString方法，因此会递归调用，此处如果想正确打印地址，那么需要使用其基类Object的toString（）方法。</p><h2 id="13-4-String上的操作"><a href="#13-4-String上的操作" class="headerlink" title="13.4 String上的操作"></a>13.4 String上的操作</h2><p>所有的类都是Class类的对象，使用Class类的getMethods（）方法可以返回该类的所有方法：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringMethods</span> &#123;</span><span class="hljs-keyword">public</span> static void main(String[] args) &#123;<span class="hljs-class"><span class="hljs-keyword">Class</span>&lt;<span class="hljs-title">String</span>&gt; <span class="hljs-title">c</span> = <span class="hljs-title">String</span>.<span class="hljs-title">class</span>;</span><span class="hljs-function"><span class="hljs-keyword">Method</span>[] <span class="hljs-title">methods</span> =</span> c.getMethods();<span class="hljs-keyword">for</span>(<span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">method</span> :</span>methods)&#123;System.out.println(<span class="hljs-function"><span class="hljs-keyword">method</span>);</span>&#125;&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined">public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.hashCode</span>()<span class="hljs-comment">//比较两个字符串 重载了Object的方法 当两个字符串值相同、类型相同则认为相同 忽略了引用</span>public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.equals</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span>)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.toString</span>()<span class="hljs-comment">//获取指定索引下标位置上的字符</span>public char java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.charAt</span>(int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.codePointAt</span>(int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.codePointBefore</span>(int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.codePointCount</span>(int,int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.compareTo</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span>)<span class="hljs-comment">//按词典顺序比较两个字符串 大小写并不等价</span>public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.compareTo</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.compareToIgnoreCase</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)<span class="hljs-comment">//字符串连接 返回一个新的String为指定String连接参数</span>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.concat</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)<span class="hljs-comment">//查找字符串中是否包含指定字符 存在返回true</span>public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.contains</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.CharSequence</span>)<span class="hljs-comment">//比较两个字符串</span>public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.contentEquals</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.StringBuffer</span>)public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.contentEquals</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.CharSequence</span>)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.copyValueOf</span>(char[])public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.copyValueOf</span>(char[],int,int)public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.endsWith</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)<span class="hljs-comment">//比较字符串是否相同 忽略大小写</span>public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.equalsIgnoreCase</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.format</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span>[])public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.format</span>(java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Locale</span>,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span>[])public void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.getBytes</span>(int,int,byte[],int)public byte[] java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.getBytes</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>) throws java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.UnsupportedEncodingException</span>public byte[] java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.getBytes</span>(java<span class="hljs-selector-class">.nio</span><span class="hljs-selector-class">.charset</span><span class="hljs-selector-class">.Charset</span>)public byte[] java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.getBytes</span>()<span class="hljs-comment">// s.getChars(1,2,char,3) 赋值s串中下标为1-2的到char中 char中起始位置为3</span>public void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.getChars</span>(int,int,char[],int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.indexOf</span>(int,int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.indexOf</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,int)<span class="hljs-comment">//是否包含该字符 包含返回下标 否则返回-1</span>public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.indexOf</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.indexOf</span>(int)public native java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.intern</span>()public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.isEmpty</span>()public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.lastIndexOf</span>(int,int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.lastIndexOf</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.lastIndexOf</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,int)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.lastIndexOf</span>(int)<span class="hljs-comment">//String 中字符的个数</span>public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.length</span>()public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.matches</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public int java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.offsetByCodePoints</span>(int,int)public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.regionMatches</span>(boolean,int,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,int,int)public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.regionMatches</span>(int,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,int,int)<span class="hljs-comment">//把字符串中的第一个参数字符替换成第二个</span>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.replace</span>(char,char)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.replace</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.CharSequence</span>,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.CharSequence</span>)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.replaceAll</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.replaceFirst</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>[] java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.split</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,int)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>[] java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.split</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.startsWith</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>,int)<span class="hljs-comment">//字符串起始串</span>public boolean java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.startsWith</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span>)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.CharSequence</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.subSequence</span>(int,int)<span class="hljs-comment">//字符串截断</span>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.substring</span>(int)public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.substring</span>(int,int)<span class="hljs-comment">//返回一个字符数组，该字符数组包含字符串的所有字符</span>public char[] java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.toCharArray</span>()<span class="hljs-comment">//字符串字符转换成小写</span>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.toLowerCase</span>()public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.toLowerCase</span>(java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Locale</span>)<span class="hljs-comment">//字符串字符转换成大写</span>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.toUpperCase</span>()public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.toUpperCase</span>(java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Locale</span>)<span class="hljs-comment">//删除String两端的空白字符</span>public java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.trim</span>()public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(char)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(<span class="hljs-attribute">float</span>)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(int)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(long)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(double)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span>)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(char[])public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(char[],int,int)public static java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.String</span><span class="hljs-selector-class">.valueOf</span>(boolean)public final native java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Class</span> java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.getClass</span>()public final native void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.notify</span>()public final native void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.notifyAll</span>()public final void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(long,int) throws java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span>public final native void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>(long) throws java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span>public final void java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Object</span><span class="hljs-selector-class">.wait</span>() throws java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.InterruptedException</span></code></pre></div><h2 id="13-5-格式化输出"><a href="#13-5-格式化输出" class="headerlink" title="13.5 格式化输出"></a>13.5 格式化输出</h2><p>JavaSE5提供了格式化输出功能，这一功能使得控制输出的功能变得更加简单，同时也给开发者带来了更加强大的代码输出控制能力。JavaSE5引入的format方法可以用于PrintStream或PrintWriter对象，其中也包括System.out对象。format（）方法模仿在C语言的printf（）如下简单示例</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SimpleFormat</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;<span class="hljs-keyword">double</span> y = <span class="hljs-number">5.333221</span>;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Row1: ["</span> + x + <span class="hljs-string">" "</span> + y + <span class="hljs-string">"]"</span>);System.<span class="hljs-keyword">out</span>.format(<span class="hljs-string">"Row1: [%d %f]\n"</span>,x,y);System.<span class="hljs-keyword">out</span>.printf(<span class="hljs-string">"Row1: [%d %f]\n"</span>,x,y);&#125;&#125;</code></pre></div><p>format（）与printf（）相同，只需要加上对应的格式化字符即可。<br>Java中所有新的格式化功能都由java.util.Formatter类处理，可以将其看做是一个翻译器，它将你的格式化字符串和数据翻译成想要的结果。当你创建了一个Formatter对象的时候，需要向编译器传递一些信息，告诉他最终的结果将向哪里输出。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.io.PrintStream;<span class="hljs-keyword">import</span> java.util.Formatter;<span class="hljs-keyword">public</span> class Tutle &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;<span class="hljs-keyword">private</span> Formatter f;<span class="hljs-keyword">public</span> Tutle(<span class="hljs-keyword">String</span> name,Formatter f)&#123;<span class="hljs-keyword">this</span>.f = f;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">move</span>(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)&#123;f.format(<span class="hljs-string">"%s The Tutle is at (%d,%d)\n"</span>,name,x,y);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;Tutle tommy = <span class="hljs-keyword">new</span> Tutle(<span class="hljs-string">"Tommy"</span>,<span class="hljs-keyword">new</span> Formatter(System.out));Tutle terry = <span class="hljs-keyword">new</span> Tutle(<span class="hljs-string">"Terry"</span>,<span class="hljs-keyword">new</span> Formatter(System.err));tommy.<span class="hljs-built_in">move</span>(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>);terry.<span class="hljs-built_in">move</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>);&#125;&#125;</code></pre></div><p> 有的时候我们希望做一些更精致的格式化信息，比如控制空格与对齐，最常见的是控制域的最小尺寸，这可以通过指定width实现，Formatter对象通过在必要时添加空格，来确保一个域至少达到某个长度。默认情况下域是右对齐的，不过也可以通过“-”指定数据的对齐方式。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Formatter;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reciept</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> total = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> Formatter f = <span class="hljs-keyword">new</span> Formatter(System.out);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTitle</span><span class="hljs-params">()</span></span>&#123;f.format(<span class="hljs-string">"%-15s %5s %10s\n"</span>,<span class="hljs-string">"Item"</span>,<span class="hljs-string">"Qty"</span>,<span class="hljs-string">"Price"</span>);f.format(<span class="hljs-string">"%-15s %5s %10s\n"</span>,<span class="hljs-string">"----"</span>,<span class="hljs-string">"---"</span>,<span class="hljs-string">"-----"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> qty,<span class="hljs-keyword">double</span> price)</span></span>&#123;f.format(<span class="hljs-string">"%-15.15s %5d %10.2f\n"</span>,name,qty,price);total+=price;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printTotal</span><span class="hljs-params">()</span></span>&#123;f.format(<span class="hljs-string">"%-15.15s %5s %10.2f\n"</span>,<span class="hljs-string">"Tax"</span>,<span class="hljs-string">""</span>,total*<span class="hljs-number">0.06</span>);f.format(<span class="hljs-string">"%-15.15s %5s %10s\n"</span>,<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,<span class="hljs-string">"------"</span>);f.format(<span class="hljs-string">"%-15.15s %5s %10.2f\n"</span>,<span class="hljs-string">"Total"</span>,<span class="hljs-string">""</span>,total*<span class="hljs-number">1.06</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Reciept receipt = <span class="hljs-keyword">new</span> Reciept();receipt.printTitle();receipt.print(<span class="hljs-string">"Jack's Magic Beans"</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4.25</span>);receipt.print(<span class="hljs-string">"Princess Beans"</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5.1</span>);receipt.print(<span class="hljs-string">"Thres Bears Porridge"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">14.25</span>);receipt.printTotal();&#125;&#125;</code></pre></div><p>Formatter类也有很多类型转换，常用的类型转换如下</p><p>d：整数型（十进制）e：浮点数（科学计数）c：Unicode字符 x：整数（十六进制）b：Boolean值 h：散列码（十六进制）s：String %：字符“%”f：浮点数（十进制），针对不同的数据类型，有些转换是无效的，如果强制使用则会发生异常。</p><h2 id="13-6-正则表达式"><a href="#13-6-正则表达式" class="headerlink" title="13.6 正则表达式"></a>13.6 正则表达式</h2><p>&emsp;&emsp;正则表达式就是以某种方式来描述字符串，因此你可以说“如果一个字符串含有某些东西，那么它就是我需要的东西”。\d表示一位数字，Java中对于\反斜线有不同的处理，在其它语言中，\表示我想插入一个普通的反斜线，而在Java中\表示我将要插入一个正则表达式反斜线，所以它后边的值应该具有特殊意义。例如你想表示一个数字，那么就是\d，如果想插入一个普通的反斜线，则需要使用\，不过制表之类的应该使用单反斜线，\d\n，使用？表示可能存在，使用+表示一个或多个+之前的表达式。比如我们要判断可能有一个负号后边跟着一个或多个数字则使用：-？\d+</p><p>&emsp;&emsp;应用正则的最简单方式是使用String类提供的方法：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IntegerMatch</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"-1234"</span>.matches(<span class="hljs-string">"-?\\d+"</span>));System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"5678"</span>.matches(<span class="hljs-string">"-?\\d+"</span>));System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"+911"</span>.matches(<span class="hljs-string">"-?\\d+"</span>));System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"+911"</span>.matches(<span class="hljs-string">"(-|\\+)?\\d+"</span>));&#125;&#125;</code></pre></div><p> &emsp;&emsp;String类还带有一个非常有用的正则表达式方法split（），功能是将字符串在正则表达式匹配的地方分割开：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Arrays; <span class="hljs-keyword">public</span> class Splitting &#123;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> knights = <span class="hljs-string">"Then。when you have found the shrubbery.you must"</span> + <span class="hljs-string">"cut down the mightiest tree in the forest。。。"</span> + <span class="hljs-string">"with... a herring"</span>;     <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">split</span>(<span class="hljs-keyword">String</span> regex)&#123; System.out.<span class="hljs-built_in">println</span>(Arrays.toString(knights.<span class="hljs-built_in">split</span>(regex))); &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;           <span class="hljs-built_in">split</span>(<span class="hljs-string">" "</span>);           <span class="hljs-built_in">split</span>(<span class="hljs-string">"\\W+"</span>);          <span class="hljs-built_in">split</span>(<span class="hljs-string">"\\w+"</span>);          <span class="hljs-built_in">split</span>(<span class="hljs-string">"n\\W+"</span>);           &#125;     &#125;</code></pre></div><p>&emsp;&emsp;第一个是使用空格拆分，\W表示非单词字符，\w表示单词字符，第三个表示字母n以及后边的一个或多个非单词字符。可见与正则表达式相同的内容都消失了。</p><p>&emsp;&emsp;String类自带的最后一个正则表达式方法为替换，你可以替换正则表达式第一个匹配的子串，也可以替换所有匹配的地方。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Replacing</span> &#123;      <span class="hljs-keyword">static</span> String s = Splitting.knights;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;          System.<span class="hljs-keyword">out</span>.println(s.replaceFirst(<span class="hljs-string">"f\\w+"</span>,<span class="hljs-string">"located"</span>));          System.<span class="hljs-keyword">out</span>.println(s.replaceAll(<span class="hljs-string">"shrubbery|tree|herring"</span>,<span class="hljs-string">"banana"</span>));      &#125;  &#125;</code></pre></div><p>&emsp;&emsp;我们的任务是在能够完成任务的情况下编写简单的易于理解的正则表达式，而不是编写难以理解的正则表达式。<br>我们在使用正则表达式的时候很容易混淆，因为他是一种在Java之上的新语言，CharSequence，该接口从CharBuffer、String、StringBuffer、StringBuilder类之中抽象出了字符序列的一般化定义。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">CharSequence</span> &#123;<span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> i </span>)</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span>(<span class="hljs-params"></span>)</span>;<span class="hljs-function">String <span class="hljs-title">subSequence</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> start,<span class="hljs-keyword">int</span> end</span>)</span>;<span class="hljs-function">String <span class="hljs-title">toString</span>(<span class="hljs-params"></span>)</span>;&#125;</code></pre></div><h2 id="13-7-扫描输入"><a href="#13-7-扫描输入" class="headerlink" title="13.7 扫描输入"></a>13.7 扫描输入</h2><p>&emsp;&emsp;读取文本或者从标准输入读取数据一般的解决方法是读入一行文本，然后对其进行分词，然后使用Integer、Double的各种解析方法来解析数据。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.io.<span class="hljs-keyword">BufferedReader</span>;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.StringReader; <span class="hljs-keyword">public</span> class SimpleRead &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">BufferedReader</span> input = <span class="hljs-keyword">new</span> <span class="hljs-keyword">BufferedReader</span>(<span class="hljs-keyword">new</span> StringReader(<span class="hljs-string">"Sir Robin of Camelot\n22 1.523222"</span>));<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<span class="hljs-keyword">try</span>&#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"What's your name?"</span>);<span class="hljs-keyword">String</span> name = input.readLine();System.out.<span class="hljs-built_in">println</span>(name);System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"How old are you?What's your favorite double"</span>);<span class="hljs-keyword">String</span> numbers = input.readLine();System.out.<span class="hljs-built_in">println</span>(numbers);<span class="hljs-keyword">String</span> numArray[] = numbers.<span class="hljs-built_in">split</span>(<span class="hljs-string">" "</span>);<span class="hljs-built_in">int</span> age = Integer.parseInt(numArray[<span class="hljs-number">0</span>]);<span class="hljs-keyword">double</span> favorite = Double.parseDouble(numArray[<span class="hljs-number">1</span>]);System.out.format(<span class="hljs-string">"Hi %s.\n"</span>,name);System.out.format(<span class="hljs-string">"In 5 years you will be %d. \n"</span>,age+<span class="hljs-number">5</span>);System.out.format(<span class="hljs-string">"My Favorite double is %f."</span>,favorite/<span class="hljs-number">2</span>);&#125;<span class="hljs-keyword">catch</span>(IOException e)&#123;System.err.<span class="hljs-built_in">println</span>(<span class="hljs-string">"I/O Exception"</span>);&#125;&#125;&#125;</code></pre></div><p>&emsp;&emsp;以上代码中，使用了IO中的readLine（）方法读取输入流中的一行，然后进行解析。终于在JavaSE5新增了Scanner类，它可以大大的减轻扫描输入的工作。</p><div class="hljs"><pre><code class="hljs undefined">import java.util.Scanner;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BetterRead</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Scanner stdin = <span class="hljs-keyword">new</span> Scanner(SimpleRead.input);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"What's your name?"</span>);String name = stdin.nextLine();System.<span class="hljs-keyword">out</span>.println(name);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"How old are you?What's your favorite double"</span>);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"(input:&lt;age&gt;&lt;double&gt;)"</span>);<span class="hljs-keyword">int</span> age = stdin.nextInt();<span class="hljs-keyword">double</span> favorite = stdin.nextDouble();System.<span class="hljs-keyword">out</span>.println(age);System.<span class="hljs-keyword">out</span>.println(favorite);System.<span class="hljs-keyword">out</span>.format(<span class="hljs-string">"Hi %s.\n"</span>,name);System.<span class="hljs-keyword">out</span>.format(<span class="hljs-string">"In 5 years you will be %d. \n"</span>,age+<span class="hljs-number">5</span>);System.<span class="hljs-keyword">out</span>.format(<span class="hljs-string">"My Favorite double is %f."</span>,favorite/<span class="hljs-number">2</span>);&#125;&#125;</code></pre></div><p>&emsp;&emsp;Scanner的构造器可以接受任意类型的输入对象，其普通的next方法将返回一个String，而所有的基本类型都有一个next方法，该方法的作用是，读取到下一个完整的指定类型的分词之后才返回。同时Scanner还有对应的hasNext方法，用来判断是否有所输入分词的类型。<br>Scanner默认的定界符为空白符，我们也可以自己使用正则表达式指定分隔符：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.Scanner;</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScannerDelimiter</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;Scanner scanner = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-string">"12,24    ,35,67"</span>);scanner.useDelimiter(<span class="hljs-string">"\\s*,\\s*"</span>);<span class="hljs-keyword">while</span>(scanner.hasNextInt())&#123;System.out.println(scanner.nextInt());&#125;&#125;&#125;</code></pre></div><p>&emsp;&emsp;这个例子使用逗号以及任意的空白字符来实现字符串的分割。使用useDelimiter（）方法设置定界符，也可以使用delimiter（）方法返回现在所使用的定界符。</p><p>&emsp;&emsp;Scanner除了可以扫描基本类型外，还可以扫描正则表达式，这在扫描复杂数据类型的时候非常有用：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">import</span> java.util.regex.MatchResult; <span class="hljs-keyword">public</span> class ThreadAnalyzer &#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> threatData = <span class="hljs-string">"58.27.82.161@02/10/2005\n"</span> +<span class="hljs-string">"204.45.234.40@02/11/2005\n"</span> +<span class="hljs-string">"58.27.82.161@02/11/2005\n"</span> +<span class="hljs-string">"58.27.82.161@02/11/2005\n"</span> +<span class="hljs-string">"58.27.82.161@02/11/2005\n"</span> +<span class="hljs-string">"[Next log section width different data format]"</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;Scanner scanner = <span class="hljs-keyword">new</span> Scanner(threatData);<span class="hljs-keyword">String</span> pattern = <span class="hljs-string">"(\\d+[.]\\d+[.]\\d+[.]\\d+)@"</span> + <span class="hljs-string">"(\\d&#123;2&#125;/\\d&#123;2&#125;/\\d&#123;4&#125;)"</span>;<span class="hljs-keyword">while</span>(scanner.hasNext(pattern))&#123;scanner.next(pattern);MatchResult <span class="hljs-built_in">match</span> = scanner.<span class="hljs-built_in">match</span>();<span class="hljs-keyword">String</span> ip = <span class="hljs-built_in">match</span>.group(<span class="hljs-number">1</span>);<span class="hljs-keyword">String</span> date = <span class="hljs-built_in">match</span>.group(<span class="hljs-number">2</span>);System.out.format(<span class="hljs-string">"Thread on %s from %s\n"</span>,date,ip);&#125;&#125;&#125;</code></pre></div><p>&emsp;&emsp;当next（）方法配合指定正则表达式使用时，将找到下一个匹配该模式的输入部分，调用match（）方法获得匹配的结果。有一点需要注意，它只针对下一个输入分词进行匹配，如果正则表达式含有定界符，那将永远不能成功。</p><h1 id="13-8-StringTokenizer"><a href="#13-8-StringTokenizer" class="headerlink" title="13.8 StringTokenizer"></a>13.8 StringTokenizer</h1><p>&emsp;&emsp;在正则表达式和Scanner引入之前，我们使用的是StringTokenizer来进行字符串匹配，下面演示这种方式并与其它方式进行比较：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.Scanner;<span class="hljs-keyword">import</span> java.util.StringTokenizer; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReplacingStringTokenizer</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-type">String</span>[] args) &#123;<span class="hljs-type">String</span> input = <span class="hljs-string">"But I'm not dead yet!I feel happy!"</span>;<span class="hljs-type">StringTokenizer</span> stoke = new <span class="hljs-type">StringTokenizer</span>(input);<span class="hljs-keyword">while</span>(stoke.hasMoreElements())&#123;<span class="hljs-type">System</span>.out.<span class="hljs-built_in">print</span>(stoke.nextToken() + <span class="hljs-string">" "</span>);&#125;<span class="hljs-type">System</span>.out.<span class="hljs-built_in">println</span>();<span class="hljs-type">System</span>.out.<span class="hljs-built_in">println</span>(<span class="hljs-type">Arrays</span>.<span class="hljs-built_in">toString</span>(input.<span class="hljs-built_in">split</span>(<span class="hljs-string">" "</span>)));<span class="hljs-type">Scanner</span> scanner = new <span class="hljs-type">Scanner</span>(input);<span class="hljs-keyword">while</span>(scanner.hasNext())&#123;<span class="hljs-type">System</span>.out.<span class="hljs-built_in">print</span>(scanner.next() + <span class="hljs-string">" "</span>);&#125;&#125;&#125;</code></pre></div><p>&emsp;&emsp;使用正则表达式或者Scanner我们可以使用更加复杂的模式匹配字符串，而使用StringTokenizer则很困难了，因此实际上StringTokenizer这个类基本上已经被废弃了。</p><h2 id="13-9-总结"><a href="#13-9-总结" class="headerlink" title="13.9 总结"></a>13.9 总结</h2><ol><li>String类型作为程序设计中最为常见的一种操作类型，它是一种不可变的操作类型。</li><li>它内部重载了“+”操作符，使得可以使用”+”操作符完成字符串的拼接工作，拼接的原理是编译器为我们自动生成了StringBuilder类来完成。因此对于复杂的字符串拼接操作，我们自己使用StringBuilder效率会更高一些。</li><li>String还有很多常用的方法，正则表达式为我们提供了字符串匹配的多种形式。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>kafka 个人理解以及常用应用场景 &amp; kafka zookeeper 无坑搭建</title>
    <link href="/2019/08/07/kafka-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-kafka-zookeeper-%E6%97%A0%E5%9D%91%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/08/07/kafka-%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-kafka-zookeeper-%E6%97%A0%E5%9D%91%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="kafka-个人理解以及常用应用场景-amp-kafka-zookeeper-无坑搭建"><a href="#kafka-个人理解以及常用应用场景-amp-kafka-zookeeper-无坑搭建" class="headerlink" title="kafka 个人理解以及常用应用场景 &amp; kafka zookeeper 无坑搭建"></a>kafka 个人理解以及常用应用场景 &amp; kafka zookeeper 无坑搭建</h1><h2 id="一-kafka-zookeeper简介-amp-应用场景"><a href="#一-kafka-zookeeper简介-amp-应用场景" class="headerlink" title="一. kafka zookeeper简介 &amp; 应用场景"></a>一. kafka zookeeper简介 &amp; 应用场景</h2><p>ApacheKafka是一个分布式流媒体平台。由Scala和Java编写，是一种高吞吐量的分布式发布订阅消息系统。由于负载能力高，存储容量大，通常被我们用在大规模的日志收集和处理上，以及处理消息系统，例如用户操作记录、推送、用户相关任务信息。</p><p>ZooKeeper是一种用于分布式应用程序的高性能协调服务。ZooKeeper背后的动机是减轻分布式应用程序从头开始实施协调服务的责任。ZooKeeper数据保存在内存中。</p><p>在Kafka的设计中，选择了使用Zookeeper来进行所有Broker的管理。</p><h2 id="二-搭建"><a href="#二-搭建" class="headerlink" title="二. 搭建"></a>二. 搭建</h2><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><blockquote><p>新版本要求JDK版本为<strong>1.8</strong>, 低版本无法运行。<br><br>基础环境是 Ubuntu/Debian<br><br>集群实现用三台虚拟机完成，ip为 10.20.1.153, 10.20.1.154, 10.20.1.155</p></blockquote><ul><li>jdk 1.8</li><li>zookeeper</li><li>scala</li><li>kafka 2.3.0</li></ul><h3 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h3> <div class="hljs"><pre><code class="hljs bash"> <span class="hljs-comment"># 安装jdk的ppa源，因为默认的源可能没有1.8</span>sudo add-apt-repository ppa:openjdk-r/ppasudo apt-get update <span class="hljs-comment"># 安装jdk1.8</span>apt-get install openjdk-8-jdk <span class="hljs-comment"># 验证安装</span>java -version</code></pre></div><h3 id="zookeeper-安装"><a href="#zookeeper-安装" class="headerlink" title="zookeeper 安装"></a>zookeeper 安装</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 安装zookeeper</span>sudo apt-get install zookeeper</code></pre></div><p>或者 手动下载，下载地址为 <a href="http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz" target="_blank" rel="noopener">http://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.4.14/zookeeper-3.4.14.tar.gz</a></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 重命名一个配置文件 </span>cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre></div><p>现在已创建配置文件，可以启动ZooKeeper：</p><div class="hljs"><pre><code class="hljs undefined">bin/zkServer<span class="hljs-selector-class">.sh</span> start</code></pre></div><h3 id="kafka-安装"><a href="#kafka-安装" class="headerlink" title="kafka 安装"></a>kafka 安装</h3><p>去官网下载最新release版本，地址 <a href="http://kafka.apache.org/downloads" target="_blank" rel="noopener">http://kafka.apache.org/downloads</a>，或者直接wget获取</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 下载</span>wget http://apache.javapipe.com/kafka/1.0.0/kafka_2.12-1.0.0.tgz<span class="hljs-comment"># 解压</span>tar -zxvf kafka_2.12-1.0.0.tgz<span class="hljs-built_in">cd</span> kafka_2.12-1.0.0</code></pre></div><p><strong>这里注意一下，下载完直接运行会出错，必须先下载Scala或者下载kafka二进制版本(二进制版本官方也可以下)</strong></p><h3 id="Scala安装"><a href="#Scala安装" class="headerlink" title="Scala安装"></a>Scala安装</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-comment"># 安装scala</span>apt-get install scala<span class="hljs-comment"># 验证安装</span>scala -version&gt; Scala code runner version 2.9.2 -- Copyright 2002-2011, LAMP/EPFL</code></pre></div><h3 id="kafka-启动"><a href="#kafka-启动" class="headerlink" title="kafka 启动"></a>kafka 启动</h3><div class="hljs"><pre><code class="hljs undefined">bin/zookeeper-server-start<span class="hljs-selector-class">.sh</span> config/zookeeper.properties</code></pre></div><h3 id="创建主题"><a href="#创建主题" class="headerlink" title="创建主题"></a>创建主题</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">bin/kafka</span><span class="hljs-literal">-</span><span class="hljs-comment">topics</span><span class="hljs-string">.</span><span class="hljs-comment">sh</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">create</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">bootstrap</span><span class="hljs-literal">-</span><span class="hljs-comment">server</span> <span class="hljs-comment">localhost:9092</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">replication</span><span class="hljs-literal">-</span><span class="hljs-comment">factor</span> <span class="hljs-comment">1</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">partitions</span> <span class="hljs-comment">1</span> <span class="hljs-literal">-</span><span class="hljs-literal">-</span><span class="hljs-comment">topic</span> <span class="hljs-comment">test</span></code></pre></div><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><div class="hljs"><pre><code class="hljs undefined">bin/kafka-console-producer.<span class="hljs-keyword">sh</span> --broker-<span class="hljs-keyword">list</span> localhos<span class="hljs-variable">t:9092</span> --topic testThis <span class="hljs-keyword">is</span> <span class="hljs-keyword">a</span> messageThis <span class="hljs-keyword">is</span> another message</code></pre></div><h3 id="启动消费者"><a href="#启动消费者" class="headerlink" title="启动消费者"></a>启动消费者</h3><div class="hljs"><pre><code class="hljs undefined">bin/kafka-<span class="hljs-built_in">console</span>-consumer.sh --bootstrap-server localhost:<span class="hljs-number">9092</span> --topic test --<span class="hljs-keyword">from</span>-beginningThis <span class="hljs-keyword">is</span> a messageThis <span class="hljs-keyword">is</span> another message</code></pre></div><p>至此，基本的搭建已经完成 可以配合编程语音做一些简单的日志处理服务。</p>]]></content>
    
    
    <categories>
      
      <category>Kafka zookeeper</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十二章</title>
    <link href="/2019/08/07/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
    <url>/2019/08/07/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十三章-通过异常处理错误"><a href="#第十三章-通过异常处理错误" class="headerlink" title="第十三章 通过异常处理错误"></a>第十三章 通过异常处理错误</h1><p>Java基本理念是 “结构不佳的代码不能运行。”</p><p>发现错误的理想时机是在程序的编译过程中。异常处理是Java唯一正式的报告机制。</p><h2 id="13-1-概念"><a href="#13-1-概念" class="headerlink" title="13.1 概念"></a>13.1 概念</h2><p>&emsp;&emsp;使用异常处理能够降低处理代码的复杂度。使用异常的另一个好处是，它能够明显的降低代码的复杂程度，避免了大量的错误检查，只需要在一个特定的地方进行异常捕获，并且不需要做任何判断，异常捕获区能够捕获所有发生的错误。这种异常的处理方式与之前的错误处理方式相比，完全的将“正常做的事儿”与“出现问题怎么办”隔离开来。是代码的读写变得更加井井有条。</p><h2 id="13-2-基本异常"><a href="#13-2-基本异常" class="headerlink" title="13.2 基本异常"></a>13.2 基本异常</h2><p>对于一个对象引用t，传递给你的时候可能没有被初始化，所以在使用这个对象引用调用执行方法之前，进行合理的判断是非常有必要的。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">if</span>(t==<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NullPointerException</span>();&#125;</code></pre></div><p> 上面代码中，我们判断当前对象引用是否没有进行初始化，如果没有进行初始化，那么就创建一个NullPointerException（）对象，然后使用throw关键字，将该对象的引用抛出。</p><h2 id="13-3-捕获异常"><a href="#13-3-捕获异常" class="headerlink" title="13.3 捕获异常"></a>13.3 捕获异常</h2><p>关键字try后包围的一部分代码块，称作try块，这样做比起之前说的要在每个会产生错误的地方进行判断要容易的多，并且代码的可读性大大增强，产生异常之后抛出的异常必须在某处得到处理，这个地点就是异常处理区，异常处理区紧跟着try块，使用catch关键字表示：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">try</span>&#123; <span class="hljs-regexp">//</span>---&#125;<span class="hljs-keyword">catch</span>(Type1 arg1)&#123; <span class="hljs-regexp">//</span>---&#125;<span class="hljs-keyword">catch</span>(Type2 arg2)&#123;&#125;</code></pre></div><h2 id="13-4-创建自定义异常"><a href="#13-4-创建自定义异常" class="headerlink" title="13.4 创建自定义异常"></a>13.4 创建自定义异常</h2><p>Java中虽然提供了很多默认的异常类型，但是要想完全覆盖会发生的异常情况显然是不现实的，因此我们可以自定义异常来表示我们预期可能会出现的异常。自定义的形式也非常简单，只需要继承一个相似的异常类即可。建立一个新的异常类最贱的方法就是让编译器为你产生默认构造器。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;&#125;  public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritingException</span> </span>&#123;      public void f() <span class="hljs-keyword">throws</span> <span class="hljs-type">SimpleException</span>&#123;          <span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Throw SimpleException from f"</span>);          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">SimpleException</span>();      &#125;      public static void main(<span class="hljs-type">String</span>[] args) &#123;          <span class="hljs-type">InheritingException</span> ite = <span class="hljs-keyword">new</span> <span class="hljs-type">InheritingException</span>();          <span class="hljs-keyword">try</span>&#123;              ite.f();          &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-type">SimpleException</span> e)&#123;              <span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Caught it!"</span>);          &#125;      &#125; &#125;</code></pre></div><p>带有参数的构造器</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(String msg)</span></span>&#123;<span class="hljs-keyword">super</span>(msg);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FullConstructors</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MyException </span>&#123;System.out.println(<span class="hljs-string">"Throwing myException from f()"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MyException</span>&#123;System.out.println(<span class="hljs-string">"Throwing myException from g()"</span>);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MyException(<span class="hljs-string">"Originated in g()"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">try</span>&#123;f();&#125;<span class="hljs-keyword">catch</span>(MyException e)&#123;e.printStackTrace();&#125;<span class="hljs-keyword">try</span>&#123;g();&#125;<span class="hljs-keyword">catch</span>(MyException e)&#123;e.printStackTrace(System.out);&#125;&#125;&#125;</code></pre></div><p><strong>有参和无参数区别可以从控制台错误信息的眼神看出。标准错误流更加的引人注目。</strong></p><h2 id="12-5-异常说明"><a href="#12-5-异常说明" class="headerlink" title="12.5 异常说明"></a>12.5 异常说明</h2><p>Java提供了相应的语法（并强制使用这个语法），使你可以使用礼貌的方式告知客户端程序员某个方法可能会抛出的异常类型，然后客户端程序员就可以进行相应的处理。这就是异常说明，它属于方法声明的一部分，紧跟在形式参数列表之后，使用throws关键字，后面接一个所有潜在异常类型的列表，所以方法定义可能看起来像是这样：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TooBig,TooSmall,DivZero</span>&#123;&#125;;</code></pre></div><h2 id="12-6-捕获所有异常"><a href="#12-6-捕获所有异常" class="headerlink" title="12.6 捕获所有异常"></a>12.6 捕获所有异常</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">catch</span>（<span class="hljs-keyword">Exception</span> e）&#123;    <span class="hljs-comment">//---</span>&#125;</code></pre></div><ul><li>String getMessage（） 获取详细信息</li><li>String getLocalizedMessage（）获取用本地语言表示的详细信息</li><li>String toString（）返回对Throwable的简单描述</li><li>void printStackTrace（）打印Throwable的调用栈轨迹 输出到标准错误流</li><li>void printStackTrace（PrintStream）打印Throwable的调用栈轨迹 输出到可选择的流<br>void printStackTrace（PrintStream）打印Throwable的调用栈轨迹 输出到可选择的流</li></ul><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExceptionMethods</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"My Exception"</span>);&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Caught Exception"</span>);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"getMessage():"</span> + e.getMessage());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"getLocalizedMessage():"</span> + e.getLocalizedMessage());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"toString()"</span> + e.toString());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"printStackTrace():--=="</span>);e.printStackTrace();System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"printStackTrace(System.out):--=="</span>);e.printStackTrace(System.<span class="hljs-keyword">out</span>);&#125;&#125;&#125;</code></pre></div><p>printStackTrace（）方法所提供的信息可以使用getStackTrace（）方法获取到，这个方法返回一个由栈轨迹元素所构成的数组，其中每一个元素都表示栈中的一帧。元素0为栈顶元素，表示调用序列最后的一个方法，也就是Throwable创建和抛出的地方，数组中最后一个元素为方法调用序列中的第一个调用方法。下面程序简单演示：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WhoCalled</span> &#123;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<span class="hljs-keyword">for</span>(StackTraceElement ste : e.getStackTrace())&#123;System.<span class="hljs-keyword">out</span>.println(ste.getMethodName());&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>&#123;f();&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">h</span>(<span class="hljs-params"></span>)</span>&#123;g();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;f();System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"------------"</span>);g();System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"------------"</span>);h();&#125;&#125;</code></pre></div><h2 id="12-7-Java标准异常"><a href="#12-7-Java标准异常" class="headerlink" title="12.7 Java标准异常"></a>12.7 Java标准异常</h2><p> Throwable这个类表示任何可以被作为异常抛出的类，Error表示编译时的系统错误，一般不需要我们关心。Exception是可以被抛出的基本类型，在Java类库、用户方法以及运行时故障都可以抛出此类异常。所以Java程序员通常需要关心此类的异常信息，同时Java异常要求可以见名知意。Java中还有一种Runtime异常，它表示程序编译错误，无法由程序员自己控制，这种异常不需要我们自己主动捕获并抛出，程序会自动抛出此类异常，如前文提到的NullPointerException。</p><h2 id="12-8-使用finally进行清理"><a href="#12-8-使用finally进行清理" class="headerlink" title="12.8 使用finally进行清理"></a>12.8 使用finally进行清理</h2><p>一些代码，可能希望无论是否抛出异常，这些代码都必须要执行。这通常包括内存回收之外的一些操作，因为内存回收是由垃圾回收器完成。为了达到这个效果，可以在catch块之后加上finally块。在finally块中处理这些代码。完整的异常处理如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">Exception</span> e1)&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-keyword">catch</span>(<span class="hljs-keyword">Exception</span> e2)&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//---</span>&#125;</code></pre></div><p>finally字句不管异常是否抛出都能被执行：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> FinallyWorks &#123;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;<span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span>++ == <span class="hljs-number">0</span>)&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();&#125;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"No Exception"</span>);&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Exception"</span>);&#125;<span class="hljs-keyword">finally</span>&#123;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"In finally clause"</span>);<span class="hljs-keyword">if</span>(<span class="hljs-keyword">count</span> == <span class="hljs-number">2</span>)&#123;<span class="hljs-keyword">break</span>;&#125;&#125;&#125;&#125;&#125;</code></pre></div><p>不管异常是否被抛出，finally字句都执行了。这个程序告诉我们，当程序发生了异常之后不能正确的回到原来的执行顺序上，我们可以在finally块中处理一些必要做的事情。比如打开文件的操作，当文件操作发生异常的时候，我们要确保文件被正确的关闭。</p><h2 id="12-9-异常的限制"><a href="#12-9-异常的限制" class="headerlink" title="12.9 异常的限制"></a>12.9 异常的限制</h2><p>异常会被继承的基类和接口所限制</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseballException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foul</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseballException</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseballException</span></span>&#123;&#125;<span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inning</span></span>&#123;public <span class="hljs-type">Inning</span>() <span class="hljs-keyword">throws</span> <span class="hljs-type">BaseballException</span>&#123;&#125;public void event() <span class="hljs-keyword">throws</span> <span class="hljs-type">BaseballException</span>&#123;&#125;public <span class="hljs-keyword">abstract</span> void atBat() <span class="hljs-keyword">throws</span> <span class="hljs-type">Strike</span>,<span class="hljs-type">Foul</span>;public void walk()&#123;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StormException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RainedOut</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StormException</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PopFoul</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foul</span></span>&#123;&#125;interface <span class="hljs-type">Storm</span>&#123;public void events() <span class="hljs-keyword">throws</span> <span class="hljs-type">RainedOut</span>;public void rainHard() <span class="hljs-keyword">throws</span> <span class="hljs-type">RainedOut</span>;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StormyInning</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Inning</span> <span class="hljs-title">implements</span> <span class="hljs-title">Storm</span></span>&#123; public <span class="hljs-type">StormyInning</span>() <span class="hljs-keyword">throws</span> <span class="hljs-type">BaseballException</span> &#123;<span class="hljs-keyword">super</span>();<span class="hljs-comment">// TODO Auto-generated constructor stub</span>&#125; <span class="hljs-meta">@Override</span>public void rainHard() <span class="hljs-keyword">throws</span> <span class="hljs-type">RainedOut</span> &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125; <span class="hljs-meta">@Override</span>public void atBat() <span class="hljs-keyword">throws</span> <span class="hljs-type">Strike</span>, <span class="hljs-type">Foul</span> &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125; <span class="hljs-meta">@Override</span>public void events() <span class="hljs-keyword">throws</span> <span class="hljs-type">RainedOut</span> &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;<span class="hljs-comment">//抽象类中的该方法没有抛出任何异常 所以覆盖重写的时候 也不能抛出异常</span><span class="hljs-comment">//public void walk() throws RainedOut&#123;</span><span class="hljs-comment">//</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//抽象类中的该方法抛出了异常 重写的时候可以选择不抛出异常</span><span class="hljs-comment">//public void event()&#123;</span><span class="hljs-comment">//</span><span class="hljs-comment">//&#125;</span><span class="hljs-comment">//抽象类中的该方法抛出了BaseballException 所以可以抛出其异常的子异常</span>public void event() <span class="hljs-keyword">throws</span> <span class="hljs-type">Foul</span>&#123;&#125;&#125;</code></pre></div><p>当继承或者实现一个类的时候，这个子类只能抛出基类中异常列表中的异常，或者其子异常，或者不抛出异常，但是不能抛出其它异常，或者抛出异常的基类异常。</p><h2 id="12-10-构造器"><a href="#12-10-构造器" class="headerlink" title="12.10 构造器"></a>12.10 构造器</h2><p>“如果异常发生了，所有东西能被正确清理吗？”大多数情况都是非常安全的，可以使用finally进行清理。但是当使用构造函数的时候，就有些问题了。比如使用构造函数构造文件操作，因为finally语句不管构造成功或者失败都会执行。假如构造失败了，如果文件没有被打开，那么这时候如果执行finally关闭文件操作就是不正确的。还有，如果文件构造成功了，因为文件需要在后边使用，所以在finally中关闭文件显然是不合理的。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InputFile</span> &#123;<span class="hljs-keyword">private</span> BufferedReader <span class="hljs-keyword">in</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InputFile</span>(<span class="hljs-params">String name</span>) throws Exception</span>&#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(name));&#125;<span class="hljs-keyword">catch</span>(FileNotFoundException e1)&#123;<span class="hljs-comment">//没有找到文件也就是文件没有打开 所以不需要清理</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"The file is not found"</span>);<span class="hljs-keyword">throw</span> e1;&#125;<span class="hljs-keyword">catch</span>(Exception e2)&#123;<span class="hljs-comment">//所有其它的异常都发生在文件打开之后 因此需要进行清理工作</span><span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">in</span>.close();&#125;<span class="hljs-keyword">catch</span>(IOException e3)&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-keyword">throw</span> e2;&#125;<span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//此处由于构造成功也会执行 所以不能进行文件关闭操作</span>&#125;&#125;&#125;</code></pre></div><p> 对于这种需要在构造器中创建的对象，合理的做法是使用嵌套try-catch</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CleanUp</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<span class="hljs-keyword">try</span>&#123;InputFile <span class="hljs-keyword">in</span> = <span class="hljs-keyword">new</span> InputFile(<span class="hljs-string">"CleanUp.java"</span>);<span class="hljs-keyword">try</span>&#123;<span class="hljs-comment">//</span>&#125;<span class="hljs-keyword">catch</span>(Exception e1)&#123;<span class="hljs-comment">//此处为文件操作异常</span>&#125;<span class="hljs-keyword">finally</span>&#123;<span class="hljs-comment">//-- 此处清理操作关闭文件</span>&#125;&#125;<span class="hljs-keyword">catch</span>(Exception e2)&#123;<span class="hljs-comment">//--此处捕获构造异常</span>&#125;&#125;&#125;</code></pre></div><h2 id="12-11-异常匹配"><a href="#12-11-异常匹配" class="headerlink" title="12.11 异常匹配"></a>12.11 异常匹配</h2><p>在抛出异常之后，异常处理系统会按照代码的编写顺序找到最近的异常处理程序并执行，此时便任务异常已经得到了处理，就不会继续进行下去。查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配，子类的对象也可以匹配到其基类的处理程序。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Annyoance</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span></span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sneeze</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Annyoance</span></span>&#123;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Human</span> </span>&#123;public static void main(<span class="hljs-type">String</span>[] args) &#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Sneeze</span>();&#125;<span class="hljs-keyword">catch</span>(<span class="hljs-type">Sneeze</span> s)&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Catch Sneeze"</span>);&#125;<span class="hljs-keyword">catch</span>(<span class="hljs-type">Annyoance</span> a)&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Catch Annyoance1"</span>);&#125;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Sneeze</span>();&#125;<span class="hljs-keyword">catch</span>(<span class="hljs-type">Annyoance</span> a)&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Catch Annyoance2"</span>);&#125;&#125;&#125;</code></pre></div><p> 编译器发现Annyoance是Sneeze的基类，所以编译的过程会提示警告。</p><h2 id="12-12-其他可选方式"><a href="#12-12-其他可选方式" class="headerlink" title="12.12 其他可选方式"></a>12.12 其他可选方式</h2><ul><li>历史 在java中 对于范型用于异常说明的方式存在着一些限制。</li><li>观点 好的程序设计语言能帮助写出好程序，但是避免不了程序员用它写出坏程序</li><li>把异常传递给控制台</li><li>被检查的异常转换成不检查的异常 RuntimeException可以抛出异常，但是还是要用 try 捕获你想你肯定想得到的异常。</li></ul><h2 id="12-13-异常使用指南"><a href="#12-13-异常使用指南" class="headerlink" title="12.13 异常使用指南"></a>12.13 异常使用指南</h2><ol><li>知道如何处理情况下捕获</li><li>解决问题重新调用产生问题的方法</li><li>进行修补，绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境的事情做完，相同的异常抛出到更高层。</li><li>把当前运行环境的事情做完，不相同的异常抛出到更高层。</li><li>终止程序。</li><li>简化异常。</li><li>让类库和程序更安全。</li></ol><h2 id="12-14-总结"><a href="#12-14-总结" class="headerlink" title="12.14 总结"></a>12.14 总结</h2><p>异常是Java编程中不可或缺的一部分，它将程序正常执行的路径与错误处理分开，减少了编码判断的冗余。使用try-catch的方式进行异常处理，同时我们也可以创建自己的异常，继承其它的异常类。一些RuntimeException无需我们自己捕捉，程序会自动捕捉。注意构造器内发生异常的情况，因为构造器往往是只是简单的构造了一个对象，对象还需要使用，所以在使用finally进行清理的时候需要注意这一点。因为finally域的代码块不管异常是否发生都会执行。处理异常的时候可以使用基类Throwable提供的方法，比如使用printStackTrace打印栈的调用顺序。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十一章</title>
    <link href="/2019/08/07/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
    <url>/2019/08/07/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十一章-持有对象"><a href="#第十一章-持有对象" class="headerlink" title="第十一章 持有对象"></a>第十一章 持有对象</h1><p>在前面的学习过程中，我们使用的都是固定数量的且生命周期已知的对象。而在一些情况中，我们可能需要不确定数量不确切类型的对象，这种创建一个单一的对象显然是不行的了。Java提供了多种支持，比如数组，数组可以保存一组基本数据类型。但是数组的大小是固定的，在更特殊的编程条件下，固定长度显然是不友好的，所以Java类库提供了一套相当完整的容器类来解决这个问题。我们也称作是集合类。本章优先学习常用的集合以及用法，后续将会更加深入的讨论其它的集合。</p><h2 id="11-1-泛型和类型安全的容器"><a href="#11-1-泛型和类型安全的容器" class="headerlink" title="11.1 泛型和类型安全的容器"></a>11.1 泛型和类型安全的容器</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> counter;<span class="hljs-keyword">private</span> final <span class="hljs-keyword">long</span> id = counter++;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getid</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> id;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppleAndOrangesWithoutGeneric</span> &#123;@SuppressWarnings(<span class="hljs-string">"unchecked"</span>)<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;ArrayList al = <span class="hljs-keyword">new</span> ArrayList();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;al.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> Apple());al.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> Orange());&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;al.size();i++)&#123;Apple apple = (Apple) al.<span class="hljs-keyword">get</span>(i);System.<span class="hljs-keyword">out</span>.println(apple.getid());&#125;&#125;&#125;</code></pre></div><p>在这里我们实际上存入ArrayList是Object对象，因为所有的类都继承自Object类，所以这里实际上不光可以添加Orange对象还可以添加任意类型的对象。我们在get（）获取数据的时候，我们以为获取的是一个Apple对象，实际上获取的是一个Obejct的引用，然后强制转换成我们需要的对象。在这里我们强制的将从ArrayList中取出的Object引用强制转换成Apple类型，那么当遇到这个对象类型实际上是Orange类型时，就会发生类型转换错误。</p><p> JavaSE5之后引入了泛型的概念，这个概念应用在这种不确定类型的对象集合中最好不过。例如我们如果想创建一个Apple类型的容器，那么就可以使用ArrayList 其中&lt;&gt;括起来的是类型参数（可以有多个），它指定了这个容器可以保存的数据类型，在进入容器之前就限制了对象的类型，所以在取出数据的时候就不会发生类型转换错误了。相对来说是更加安全的。</p><div class="hljs"><pre><code class="hljs undefined">import java.util.ArrayList; <span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> counter;<span class="hljs-keyword">private</span> final <span class="hljs-keyword">long</span> id = counter++;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getid</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> id;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Orange</span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AppleAndOrangesWithoutGeneric</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;ArrayList&lt;Apple&gt; al = <span class="hljs-keyword">new</span> ArrayList&lt;Apple&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)&#123;al.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> Apple());<span class="hljs-comment">//al.add(new Orange());</span>&#125;<span class="hljs-keyword">for</span>(Apple apple :al)&#123;System.<span class="hljs-keyword">out</span>.println(apple.getid());&#125;&#125;&#125;</code></pre></div><p>现在你可以阻止将Orange对象加入到Apple容器中了，并且我们可以使用for-each循环获取容器中的内容。实际上当我们固定了一种泛型数据参数，正如前面几章说到的，继承的时候基类收发的消息，子类也可以收发，所以泛型同样支持向上转型，我们可以传递其导出类参数。</p><h2 id="11-2-基本概念"><a href="#11-2-基本概念" class="headerlink" title="11.2 基本概念"></a>11.2 基本概念</h2><p> Java容器的用途是“保存对象”，并将其划分为两个不同的概念。</p><p>    Collection：一个独立的元素序列，这些元素都服从一条或多条规则。List必须按照插入的顺序保存对象，而Set不能有重复的元素。Queue按照排队的规则来确定对象的产生顺序。</p><p>    Map：一组成对的“键值对”对象，允许你使用键来查找值。ArrayList允许你使用数组查找值，所以某种意义上讲它是将对象与数字进行了绑定。</p><p>    尽管并非总是这样，但是理想情况下我们都是与这些接口打交道。比如，我们可以像下边这样创建一个List:</p><div class="hljs"><pre><code class="hljs undefined">List<span class="hljs-tag">&lt;<span class="hljs-name">Apple</span>&gt;</span> apples = new ArrayList<span class="hljs-tag">&lt;<span class="hljs-name">Apple</span>&gt;</span>();</code></pre></div><p>ArrayList已经被向上转型为List，使用接口的目的是如何修改它的实现，这里实现由ArrayList完成。这种方式并非永远有效，会带来一个其它的问题，ArrayList类可能新添加了其它的方法，因此当它向上转型为List时，可能会是不完善的。因此如果我们要使用这类方法，那就需要使用更加确切的类型。</p><h2 id="11-3-添加一组元素"><a href="#11-3-添加一组元素" class="headerlink" title="11.3 添加一组元素"></a>11.3 添加一组元素</h2><div class="hljs"><pre><code class="hljs undefined">import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.Collections;import java.util.List; public class AddingGroups &#123;public static void main(String[] args) &#123;Collection&lt;Integer&gt; collection = new ArrayList&lt;Integer&gt;(Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>));Integer[] moreInts = &#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;collection.addAll(Arrays.asList(moreInts));Collections.addAll(collection,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>);Collections.addAll(collection,moreInts);List&lt;Integer&gt; <span class="hljs-type">list</span> = Arrays.asList(<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">17</span>,<span class="hljs-number">18</span>);<span class="hljs-type">list</span>.set(<span class="hljs-number">1</span>,<span class="hljs-number">29</span>);<span class="hljs-comment">//run error 数组不支持变更长度</span><span class="hljs-type">list</span>.add(<span class="hljs-number">21</span>);&#125;&#125;</code></pre></div><p> Collection的构造器可以传递另一个Collection用来初始化，但是这种方式不如定义个空的Collection然后使用addAll的形式添加数据灵活</p><h2 id="11-4-容器的打印"><a href="#11-4-容器的打印" class="headerlink" title="11.4 容器的打印"></a>11.4 容器的打印</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Collection;<span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">HashMap</span>;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.LinkedHashMap;<span class="hljs-keyword">import</span> java.util.LinkedHashSet;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.TreeMap;<span class="hljs-keyword">import</span> java.util.TreeSet;<span class="hljs-keyword">public</span> class PrintingContainers &#123;<span class="hljs-keyword">static</span> Collection <span class="hljs-built_in">fill</span>(Collection&lt;<span class="hljs-keyword">String</span>&gt; collection)&#123;collection.<span class="hljs-built_in">add</span>(<span class="hljs-string">"one"</span>);collection.<span class="hljs-built_in">add</span>(<span class="hljs-string">"two"</span>);collection.<span class="hljs-built_in">add</span>(<span class="hljs-string">"three"</span>);collection.<span class="hljs-built_in">add</span>(<span class="hljs-string">"four"</span>);collection.<span class="hljs-built_in">add</span>(<span class="hljs-string">"five"</span>);collection.<span class="hljs-built_in">add</span>(<span class="hljs-string">"five"</span>);<span class="hljs-keyword">return</span> collection;&#125;<span class="hljs-keyword">static</span> Map <span class="hljs-built_in">fill</span>(Map&lt;<span class="hljs-keyword">String</span>,<span class="hljs-keyword">String</span>&gt; <span class="hljs-built_in">map</span>)&#123;<span class="hljs-built_in">map</span>.put(<span class="hljs-string">"one"</span>,<span class="hljs-string">"ONE"</span>);<span class="hljs-built_in">map</span>.put(<span class="hljs-string">"two"</span>,<span class="hljs-string">"TWO"</span>);<span class="hljs-built_in">map</span>.put(<span class="hljs-string">"three"</span>,<span class="hljs-string">"THREE"</span>);<span class="hljs-built_in">map</span>.put(<span class="hljs-string">"four"</span>,<span class="hljs-string">"FOUR"</span>);<span class="hljs-built_in">map</span>.put(<span class="hljs-string">"five"</span>,<span class="hljs-string">"FIVE"</span>);<span class="hljs-built_in">map</span>.put(<span class="hljs-string">"five"</span>,<span class="hljs-string">"FIVE"</span>);<span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ArrayList==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"LinkedList==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> LinkedList&lt;<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"HashSet==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"TreeSet==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> TreeSet&lt;<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"LinkedHashSet==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> LinkedHashSet&lt;<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"HashMap==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;<span class="hljs-keyword">String</span>,<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"TreeMap==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> TreeMap&lt;<span class="hljs-keyword">String</span>,<span class="hljs-keyword">String</span>&gt;()));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"LinkedHashMap==="</span> + <span class="hljs-built_in">fill</span>(<span class="hljs-keyword">new</span> LinkedHashMap&lt;<span class="hljs-keyword">String</span>,<span class="hljs-keyword">String</span>&gt;()));&#125;&#125;</code></pre></div><p>这里展示了Java容器中的两种主要的类型：Collection和Map，Collection又包括List和Set他们每个位置只能保存一个数据。而Map保存数据的形式则是使用键值对“key-value”的形式。List：以特定的顺序保存数据，Set：集合中的元素都不能重复。Collection还包括另外一种Queue，它要求元素只能从集合的一端进入，从另一端取出。<br>    从本例的输出结果可以看出，默认的容器带有的toString方法，可以很好的将容器中的数据展示出来。Collection使用[]括起来，Map使用{}括起来，键值对使用=连接。<br>    接着分析打印输出，ArrayList和LinkedList都是List类型，它们能够按照元素的填入顺序进行打印。区别在于执行某些操作时候的性能不同，而且LinkedList的功能要多于ArrayList，这在后文介绍。<br>    HashSet、TreeSet、LinkedHashSet都是Set类型，每个相同的元素只保存一个，HashSet使用了相当复杂的存储结构，后文会介绍，因此HashSet的存储顺序没有实际意义。TreeSet按元素比较结果的升序排序，LinkedHashSet与List相同，按照元素的插入顺序进行了排序。<br>    Map也可以称作是关联数组，可以使用key查找对应的value，同时可以不用关心它们的大小。Map会自动的扩容。同时也不需要关心打印的顺序。</p><h2 id="11-5-List"><a href="#11-5-List" class="headerlink" title="11.5 List"></a>11.5 List</h2><p>List将元素按照插入的顺序排列起来，它在Collection的接口中增加了新的功能，使得可以在List的中间插入和删除元素。List有两种类型如上一节介绍:<br>    1.ArrayList 优势在于随机访问的速度很快，但是在List中间插入和删除元素比较慢。<br>    2.LinkedList 与上基本相反，它的特性集较ArrayList更大。<br>    下面的一个例子展示List的一些特性，首先有个枚举类型，它有几个常量，然后是一个向List中增加数据的方法，这个方法我们使用的是ArrayList，注意前边说到，ArrayList增删操作性能消耗很大，如果我们的程序设计中出现了大量的ArrayList插入操作，那么可能会导致性能的降低</p><div class="hljs"><pre><code class="hljs undefined">import java.util.ArrayList;import java.util.List;import java.util.Random;<span class="hljs-keyword">enum</span> Pet&#123;Pet,Rat,Manx,Mutt,Pug,Cymric,Humaster&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Pets</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Pet&gt; <span class="hljs-title">arrayList</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> n</span>)</span>&#123;List&lt;Pet&gt; pets = <span class="hljs-keyword">new</span> ArrayList&lt;Pet&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)&#123;Random rand = <span class="hljs-keyword">new</span> Random();<span class="hljs-keyword">int</span> j = rand.nextInt(n);<span class="hljs-keyword">switch</span>(j)&#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:pets.<span class="hljs-keyword">add</span>(Pet.Pet);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:pets.<span class="hljs-keyword">add</span>(Pet.Rat);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:pets.<span class="hljs-keyword">add</span>(Pet.Manx);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:pets.<span class="hljs-keyword">add</span>(Pet.Mutt);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:pets.<span class="hljs-keyword">add</span>(Pet.Pug);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:pets.<span class="hljs-keyword">add</span>(Pet.Cymric);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:pets.<span class="hljs-keyword">add</span>(Pet.Humaster);<span class="hljs-keyword">break</span>;<span class="hljs-keyword">default</span>:<span class="hljs-keyword">break</span>;&#125;&#125;<span class="hljs-keyword">return</span> pets;&#125;&#125;</code></pre></div><h2 id="11-6-迭代器"><a href="#11-6-迭代器" class="headerlink" title="11.6 迭代器"></a>11.6 迭代器</h2><p> 迭代器（也是一种设计模式），是一种应用在容器之上的设计。它是一个对象，它的作用是遍历并选择序列中的对象，而不需要确定该序列的底层机构。也就是说，我们使用迭代器的目的是解决了不同容器之间的互通性问题。因此迭代器通常被称作是“轻量级对象”，创建它的代价较小。因此通常有些奇怪的限制。例如：Java中的迭代器只能单向移动，并且它通常：<br>    1、使用方法iterator（）要求容器返回一个Iterator，Iterator将准备好返回容器的第一个元素。<br>    2、使用next（）方法获得容器中的下一个元素。<br>    3、使用hasNext（）方法检查容器中是否还有下一个元素。<br>    4、使用remove（）方法将迭代器中新近返回的元素删除。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Iterator;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SimpleIterator &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;List&lt;Pet&gt; pets = Pets.arrayList(<span class="hljs-number">7</span>);Iterator&lt;Pet&gt; it = pets.iterator();System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"1:"</span> + pets);System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"2:"</span> + it);<span class="hljs-keyword">while</span>(it.hasNext())&#123;Pet p = it.<span class="hljs-keyword">next</span>();System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"---&gt;"</span> + p);&#125;it = pets.iterator();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">7</span>;i++)&#123;it.<span class="hljs-keyword">next</span>();it.remove();System.out.<span class="hljs-keyword">println</span>(pets);&#125;&#125;&#125;</code></pre></div><p>第二行我们打印Iterator时并没有像打印其它对象时把数据打印出来，而是只打印了这个迭代器底层容器的类型ArrayList。还有就是迭代器对象第一次.next之后获取的是第一个元素，remove方法移除的是next方法获取到的元素，所以remove之前必须要调用next方法。在同一方法中使用Iterator时，要注意前面使用过之后，Iterator的位置会发生变化。<br>    现在我们换用其它类型的容器来测试迭代器的作用，这里有个display（）方法，它不考虑任何容器的类型来进行打印：</p><p>还有一种比Iterator更加强大的迭代器ListIterator，这个迭代器功能更全，可以向前或者向后移动，也可以使用set（）方法替换它最后访问的元素（使用方式如Iterator的remove方法，要先指定访问元素），同时它还可以使用listIterator（n）方法直接指定到第n个元素的ListIterator。下面的示例展示了ListIterator的功能：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.ListIterator;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> SimpleListIterator &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;List&lt;Pet&gt; pets = Pets.arrayList(<span class="hljs-number">7</span>);ListIterator&lt;Pet&gt; lit = pets.listIterator();System.out.<span class="hljs-keyword">println</span>(pets);System.out.<span class="hljs-keyword">println</span>(lit);System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"=====Next====="</span>);<span class="hljs-keyword">while</span>(lit.hasNext())&#123;<span class="hljs-keyword">int</span> index = lit.nextIndex();Pet p = lit.<span class="hljs-keyword">next</span>();System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Index:"</span> + index + <span class="hljs-string">","</span> + <span class="hljs-string">"Pet:"</span> + p );&#125;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"=====Previous====="</span>);lit = pets.listIterator(<span class="hljs-number">7</span>);<span class="hljs-keyword">while</span>(lit.hasPrevious())&#123;<span class="hljs-keyword">int</span> index = lit.previousIndex();Pet p = lit.<span class="hljs-keyword">previous</span>();System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Index:"</span> + index + <span class="hljs-string">","</span> + <span class="hljs-string">"Pet:"</span> + p );&#125;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"=====Update Set====="</span>);lit = pets.listIterator();<span class="hljs-keyword">while</span>(lit.hasNext())&#123;Pet p = lit.<span class="hljs-keyword">next</span>();lit.set(Pet.Humaster);&#125;System.out.<span class="hljs-keyword">println</span>(pets);&#125;&#125;</code></pre></div><h2 id="11-7-LinkedList"><a href="#11-7-LinkedList" class="headerlink" title="11.7 LinkedList"></a>11.7 LinkedList</h2><p>LinkedList与ArrayList相同都是实现了List接口，但是它在增删的时候效率较高，在随机访问的时候效率略低。LinkedList还增加了其作为栈、队列、双端队列的操作方法。这些方法有的只是名字有差异，或者是返回值有差异。</p><div class="hljs"><pre><code class="hljs undefined">import java.util.LinkedList;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListFeatures</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;LinkedList&lt;Pet&gt; pets = <span class="hljs-keyword">new</span> LinkedList&lt;Pet&gt;(Pets.arrayList(<span class="hljs-number">7</span>));System.<span class="hljs-keyword">out</span>.println(pets);<span class="hljs-comment">//以下两个方法都返回容器的第一个元素 在容器为空的时候抛异常</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.getFirst()---》"</span> + pets.getFirst());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.elements()---》"</span> + pets.element());<span class="hljs-comment">//与上两个方法相同 区别在于为空时返回null</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.peek()---》"</span> + pets.peek());<span class="hljs-comment">//以下两个方法移除列表的第一个元素 在容器为空的时候抛出异常</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.remove()---&gt;"</span> + pets.<span class="hljs-keyword">remove</span>());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.removeFirst()---&gt;"</span> + pets.removeFirst());<span class="hljs-comment">//与上两个方法相同 区别在于容器为空时返回null</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.pool()---&gt;"</span> + pets.poll());System.<span class="hljs-keyword">out</span>.println(pets);<span class="hljs-comment">//在容器第一个位置加入新的元素 其它元素依次后移</span>pets.addFirst(Pet.Manx);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After addFirst()"</span> + pets);<span class="hljs-comment">//以下两个方法在容器尾部插入新元素</span>pets.<span class="hljs-keyword">add</span>(Pet.Humaster);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After add()"</span> + pets);pets.addLast(Pet.Pug);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After addLast()"</span> + pets);<span class="hljs-comment">//offer 是针对queue 在尾部插入数据 add是针对list 在尾部插入数据</span>pets.offer(Pet.Rat);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After offer()"</span> + pets);<span class="hljs-comment">//移除最后一个并返回该元素</span>System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"pets.removeLast()"</span> + pets.removeLast());System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"After removeLast()"</span> + pets);&#125;&#125;</code></pre></div><h2 id="11-8-Stack-栈"><a href="#11-8-Stack-栈" class="headerlink" title="11.8 Stack 栈"></a>11.8 Stack 栈</h2><p>“栈”通常是指“后进先出的容器”，比如装羽毛球的桶，最后放进去的羽毛球可以第一个被拿出来，因为另一端也就是栈底是封闭的。LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。这里我们使用一个真正的Stack，内部使用LinkedList来实现它。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<span class="hljs-keyword">private</span> LinkedList&lt;T&gt; storage = <span class="hljs-keyword">new</span> LinkedList&lt;T&gt;();<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T v)</span></span>&#123;storage.addFirst(v);&#125;<span class="hljs-keyword">public</span> <span class="hljs-function">T <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">return</span> storage.<span class="hljs-title">getFirst</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-function">T <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">return</span> storage.<span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">return</span> storage.<span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-function">String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-function"><span class="hljs-keyword">return</span> storage.<span class="hljs-title">toString</span><span class="hljs-params">()</span></span>;&#125;&#125;</code></pre></div><p>这里使用泛型来告诉编译器这个Stack是持有参数化类型T的容器，这个Stack是使用LinkedList实现的，而LinkedList也被告知是使用了T类型的对象。peek（）方法返回栈顶元素，但是并不是移除。而pop（）方法这里是弹出栈顶元素，也就是移除了栈顶元素。如果我们只是需要栈的行为，而不需要其它无关的行为方法，那么这里使用继承就显然不合适了。后边会讨论在Java1.0中，java.util.Stack这个类的设计。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackTest</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Stack&lt;String&gt; <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack&lt;String&gt;();<span class="hljs-keyword">for</span>(String s : <span class="hljs-string">"My Dog has fleas"</span>.split(<span class="hljs-string">" "</span>))&#123;<span class="hljs-built_in">stack</span>.push(s);&#125;<span class="hljs-keyword">while</span>(!<span class="hljs-built_in">stack</span>.empty())&#123;System.out.print(<span class="hljs-built_in">stack</span>.pop() + <span class="hljs-string">" "</span>);&#125;&#125;&#125;</code></pre></div><p>这里使用了push方法将字符串“My Dog has fleas”用空格分开的单词压入栈中，然后使用pop方法弹出栈顶元素。因为pop方法调用之后会移除栈顶元素，所以会依次弹出栈中的所有元素。在这里我们使用了自己定义的Stack，如果我们导入了java.util.Stack类的话，那么我们这样使用可能会产生命名冲突的现象，解决方法是我们在实例化的时候使用完整的类名，或者修改我们自己定义的Stack类名。</p><h2 id="11-9-Set"><a href="#11-9-Set" class="headerlink" title="11.9 Set"></a>11.9 Set</h2><p> Set不保存重复的元素（至于如何判断元素是否重复，则较为复杂，稍后便会看到），Set最常见的使用是判断对象的归属性，即判断某个对象是否在Set中。正因为如此，Set的查询效率就显得尤为重要了，所以通常会使用HashSet来实现所需要的功能，它对查询专门做了优化。</p><p>    Set具有与Collection完全一样的接口，我们可以说Set就是Collection，这是表现了不同的功能，这是Java中继承与多态思想的展现。Set中更加复杂的问题后边17章会介绍。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">public</span> class SetofInteger &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;Random <span class="hljs-built_in">random</span> = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);Set&lt;Integer&gt; <span class="hljs-built_in">set</span> = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++)&#123;<span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-built_in">random</span>.nextInt(<span class="hljs-number">30</span>));&#125;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">set</span>);&#125;&#125;</code></pre></div><p>set中插入了0-29的随机数，插入了10000次，但是从打印结果可以看出，只保证了每个数据只出现了一次。而且似乎插入的顺序并没有规律可寻。这是因为出于查找速度的考虑，HashSet使用了散列，将在17章中介绍。HashSet使用散列存储，TreeSet使用红黑树存储，LinkedHahSet因为查询速度的原因也使用了散列，但是它看起来像是使用了链表来进行存储，因为它保证了元素的插入顺序。</p><p>    注意：插入顺序与元素的顺序的区别，插入顺序是我们在容器中添加元素时的顺序，而元素的顺序说的是按照某种规则比如从小到大或者从大到小的顺序，也就是元素的结果。当然，上边的示例如果我们相对元素的结果进行排序，那么可以使用TreeSet来替换，因为LinkedHashSet只是保证了元素的插入顺序。</p><p>    Set 常用的方法是使用contains（）判断是否存在某元素，当然还有一些其它的顾名思义的方法：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Collections;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">public</span> class SetOperations &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;Set&lt;<span class="hljs-keyword">String</span>&gt; set1 = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">String</span>&gt;();Collections.addAll(set1,<span class="hljs-string">"A B C D E F G H I J K L"</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">" "</span>));set1.<span class="hljs-built_in">add</span>(<span class="hljs-string">"M"</span>);System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"H:"</span> +  set1.contains(<span class="hljs-string">"H"</span>));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"N:"</span> +  set1.contains(<span class="hljs-string">"N"</span>));Set&lt;<span class="hljs-keyword">String</span>&gt; set2 = <span class="hljs-keyword">new</span> HashSet&lt;<span class="hljs-keyword">String</span>&gt;();Collections.addAll(set2,<span class="hljs-string">"H I J K L"</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">" "</span>));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"set2 in set1:"</span> + set1.containsAll(set2));set1.remove(<span class="hljs-string">"H"</span>);System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"set1: "</span> + set1);System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"set2 in set1:"</span> + set1.containsAll(set2));set1.removeAll(set2);System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"set2 removed from set1:"</span> + set1);Collections.addAll(set1,<span class="hljs-string">"X Y Z"</span>.<span class="hljs-built_in">split</span>(<span class="hljs-string">" "</span>));System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"XYZ added to set1:"</span> + set1);&#125;&#125;</code></pre></div><h2 id="11-10-Map"><a href="#11-10-Map" class="headerlink" title="11.10 Map"></a>11.10 Map</h2><p>Map可以将一个对象映射到另一个对象上组建一种一对一的键值关系。比如可以设计这样一个程序来验证Java中Random的随机性，理想情况下，Random对每个随机数产生的概率是相同的。我们测试这一理论，于是定义一个Map，键来表示随机出现的数字，值来表示该数字出现的次数。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.<span class="hljs-keyword">HashMap</span>;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Random;<span class="hljs-keyword">public</span> class RandomTest &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;Random <span class="hljs-built_in">random</span> = <span class="hljs-keyword">new</span> Random(<span class="hljs-number">47</span>);Map&lt;Integer,Integer&gt; <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;Integer,Integer&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i =<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">1000000</span>;i++)&#123;<span class="hljs-built_in">int</span> x = <span class="hljs-built_in">random</span>.nextInt(<span class="hljs-number">20</span>);Integer freq = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(x);<span class="hljs-built_in">map</span>.put(x,freq == <span class="hljs-keyword">null</span>?<span class="hljs-number">1</span>:freq+<span class="hljs-number">1</span>);&#125;System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">map</span>);&#125;&#125;</code></pre></div><p> Map与数组或者其它的Collection一样，可以扩展到多维角度，即key是String类型，value可以重新定义为一个容器。比如上边的示例改造为一个动物有多个名字。那么你需要的就是一个Map&lt;String,List&gt;:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.<span class="hljs-built_in">List</span>;<span class="hljs-keyword">import</span> java.util.<span class="hljs-built_in">Map</span>;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapOfList</span> </span>&#123;public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123; <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">List</span>&lt;Pet&gt;&gt; petList = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">String</span>,<span class="hljs-built_in">List</span>&lt;Pet&gt;&gt;(); petList.put(<span class="hljs-string">"MyDog"</span>,Arrays.asList(Pet.Cymric,Pet.Humaster,Pet.Mutt)); System.out.println(petList); System.out.println(<span class="hljs-string">"key:"</span> + petList.keySet()); System.out.println(<span class="hljs-string">"value:"</span> + petList.values()); <span class="hljs-keyword">for</span>(<span class="hljs-built_in">String</span> s:petList.keySet())&#123; System.out.<span class="hljs-built_in">print</span>(s + <span class="hljs-string">":"</span>); <span class="hljs-keyword">for</span>(Pet p:petList.<span class="hljs-keyword">get</span>(s))&#123; System.out.<span class="hljs-built_in">print</span>(p + <span class="hljs-string">" "</span>); &#125; &#125;&#125;&#125;</code></pre></div><h2 id="11-11-Queue-队列"><a href="#11-11-Queue-队列" class="headerlink" title="11.11 Queue 队列"></a>11.11 Queue 队列</h2><p>队列是一个典型的先进先出的容器，就像是一个两端打开的管子，从一端放进去的物品，从另一端取出，并且最先取出的是最先放进去的物品。因此队列的取出顺序往往是与插入顺序相同的。正因为队列这种顺序特性，它常常被作为一种可靠的将对象从程序的某个区域发送到另一个区域的途径。LinkedList实现了Queue的接口，因此LinkedList可以当做是Queue的一种实现，这是面向对象编程中继承与多态思想的体现。将LinkedList向上转型为Queue，下面的示例将展示Queue接口中与Queue相关的方法：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueDemo</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printQ</span><span class="hljs-params">(Queue <span class="hljs-built_in">queue</span>)</span></span>&#123;<span class="hljs-comment">//不移除的情况下返回队列头部元素  element（）方法相同  peek为空返回null  element为空抛出异常</span><span class="hljs-keyword">while</span>(<span class="hljs-built_in">queue</span>.peek()!=null)&#123;<span class="hljs-comment">//remove（）移除头元素 为空抛出异常 poll 为空返回null</span>System.out.println(<span class="hljs-built_in">queue</span>.remove() + <span class="hljs-string">" "</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Queue&lt;Integer&gt; <span class="hljs-built_in">queue</span> = <span class="hljs-keyword">new</span> LinkedList&lt;Integer&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<span class="hljs-comment">//元素插入队尾</span><span class="hljs-built_in">queue</span>.offer(i);&#125;printQ(<span class="hljs-built_in">queue</span>);Queue&lt;Character&gt; qc = <span class="hljs-keyword">new</span> LinkedList&lt;Character&gt;();<span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:<span class="hljs-string">"QUEUEDEMO"</span>.toCharArray())&#123;qc.offer(c);&#125;printQ(qc);&#125;&#125;</code></pre></div><p>&emsp;&emsp;offer方法是队列的相关方法之一，它在队列允许的情况下，将元素插入到队列的尾部，或者返回false，peek和element方法都是在不删除的情况下返回队列的第一个元素，peek在队列为空时返回null，element在队列为空抛NoSuchElementException，poll和remove删除当前队列的第一个元素，如果为空poll返回null，remove抛NoSuchElementException异常。</p><p>&emsp;&emsp;先进先出描述了最典型的队列规则，在某些情况下，队列还需要弹出当前最需要的元素，这种队列称作是优先级队列。优先级队列每个元素都具有一个执行的优先级，也就是这个元素何时弹出与何时插入没有必然的联系。PriorityQueue添加到Java SE5中，是为了这种优先级形式自动实现。当我们在PriorityQueue上调用了offer（）方法来插入一个对象时，这个对象在队列中就会被重新排序。默认的排序是对象在队列中的自然顺序。但是你可以通过提供自己的Comparator来修改这个顺序。PriorityQueue可以确保你在调用peek、poll、remove等方法时获取的是当前队列中优先级最高的元素。</p><p>&emsp;&emsp;JavaSE5中定义的reverseOrder反序定义了PriorityQueue的优先级。</p><h2 id="11-12-Collection和Iterator"><a href="#11-12-Collection和Iterator" class="headerlink" title="11.12 Collection和Iterator"></a>11.12 Collection和Iterator</h2><p>使用Collection和Iterator看起来没有什么区别，通常情况下，使用Collection要更方便一些。</p><h2 id="11-13-Foreach与迭代器"><a href="#11-13-Foreach与迭代器" class="headerlink" title="11.13 Foreach与迭代器"></a>11.13 Foreach与迭代器</h2><p>&emsp;&emsp;foreach语法可以应用在数组中，也可以应用在任何Collection对象，之所以能够这样，是因为JavaSE5引入了新的被称为Iterable的接口，该接口包含了一个能够产生Iterator的iterator（）方法，并且Iterable接口被foreach用来在序列中移动。因此如果你创建了任何实现Iterabel的类，都可以将它应用在foreach中。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.Iterator; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IterableClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<span class="hljs-keyword">protected</span> String[] words = (<span class="hljs-string">"And that is how we know the earth"</span>).split(<span class="hljs-string">" "</span>);<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;String&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Iterator&lt;String&gt;()&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> index&lt;words.length;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> words[index++];&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//---</span>&#125;&#125;;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">for</span>(String s :<span class="hljs-keyword">new</span> IterableClass())&#123;System.out.print(s + <span class="hljs-string">" "</span>);&#125;&#125;&#125;</code></pre></div><p>&emsp;&emsp;iterator（）方法返回的实现了Iterator 的匿名内部类的实例，该匿名内部类可以遍历数组中的所有单词。在main（）中，你可以看到IteratorClass确实可以用于foreach语句中。</p><h2 id="11-14-总结"><a href="#11-14-总结" class="headerlink" title="11.14 总结"></a>11.14 总结</h2><p>&emsp;&emsp;容器也就是集合，是Java基础中很重要的一个模块，本篇文章了解了基础的容器使用方式。Java提供了多种容器持有对象的方式：<br>    1.数组将数字也就是下标与内容关联，查询时不需要进行类型转换，缺点是大小一旦确定，则不能被改变。<br>    2.Collection保存单一的元素，Map保存相关联的键值对。<br>    3.像数组一样，List也建立数字索引与对象的关联，因此数组和List都是排序好的容器。<br>    4.如果要进行大量的随机访问，就要使用ArrayList，如果要进行大量的插入删除操作，就要使用LinkedList。<br>    5.各种队列与栈的操作，由LinkedList提供支持。<br>    6.Map是一种将对象与对象进行关联的容器，HashMap设计用来快速访问，TreeMap保持键始终处于排序状态，所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供快速访问的能力。<br>    7.Set不接受重复的数据，HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保持元素。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第十章</title>
    <link href="/2019/08/05/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
    <url>/2019/08/05/Thinking-in-Java-%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章 内部类"></a>第十章 内部类</h1><p>将一个类定义放在另一个类的内部，这就是内部类。<br>内部类和组合十完全不同的概念。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Parcell</span> &#123;<span class="hljs-keyword">class</span> <span class="hljs-title">Contents</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Destination</span>&#123;<span class="hljs-keyword">private</span> String label;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Destination</span>(<span class="hljs-params">String whereto</span>)</span> &#123;<span class="hljs-comment">// TODO Auto-generated constructor stub</span>label = whereto;&#125;<span class="hljs-function">String <span class="hljs-title">readLabel</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> label;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Contents <span class="hljs-title">contents</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contents();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Destination <span class="hljs-title">destination</span>(<span class="hljs-params">String s</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Destination(s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ship</span>(<span class="hljs-params">String dest</span>)</span>&#123;Contents c = <span class="hljs-keyword">new</span> Contents();Destination d = <span class="hljs-keyword">new</span> Destination(dest);System.<span class="hljs-keyword">out</span>.println(d.readLabel());&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Parcell p1 = <span class="hljs-keyword">new</span> Parcell();p1.ship(<span class="hljs-string">"Inner Class"</span>);Parcell p2 = <span class="hljs-keyword">new</span> Parcell();Contents c = p2.contents();Parcell.Destination d = p2.destination(<span class="hljs-string">"Class Inner"</span>);&#125;&#125;</code></pre></div><p>&emsp;&emsp;上面代码我们创建了一个内部类，内部类与其它类的区别在于将类隐藏在了另一个类的内部，同时如contents方法所示，外部类的方法还可以返回一个指向内部类的引用，这也是很常见的一种用法。此外我们看到main（）方法中创建的内部类对象是使用外部类的引用关联创建的，</p><h2 id="9-2-链接到外部类"><a href="#9-2-链接到外部类" class="headerlink" title="9.2 链接到外部类"></a>9.2 链接到外部类</h2><p>&emsp;&emsp;当我们创建了一个内部类对象，此对象就与制造它的外围对象之间有了一种关联，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外围类的所有元素的访问权。<br>&emsp;&emsp;所以内部类自动拥有对其外围类所有成员的访问权限。当某个外围类的对象创建一个内部类的对象的时候，这个内部类对象必然会秘密捕获一个外围类对象的引用，也就是这个引用来选择外围类的成员。这里所有的细节都交给了编译器来处理。内部类的对象只能在其与外部类的对象相关联的时候才能被创建（在static方法中），构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错，不过绝大多数情况下这种都不需要我们操心。这里也就解释了上一节关于内部类初始化方式不同的原因。意思就是在static方法中，不能通过直接的new 构造函数的形式创建内部类，因为这种形式没有将内部类与外部类对象做关联，要先创建一个外部类的对象，然后使用该对象的引用创建内部类对象。当然如果内部类是静态的，那么就没有这种要求了。<br>&emsp;&emsp;我们将上一个示例中的ship方法改成static修饰，原来的使用构造器创建内部类对象的方法就报错了。因为它没有找到关联的外部类对象引用。然后我们把这个内部类Contents改成static修饰，则编译器就不报错了。或者使用main函数中的形式，先创建一个外部类的对象，然后使用这个对象的引用去创建内部类对象。</p><h2 id="10-3-使用-this-与-new"><a href="#10-3-使用-this-与-new" class="headerlink" title="10.3 使用.this 与.new"></a>10.3 使用.this 与.new</h2><p>&emsp;&emsp;在内部类生成外部类对象的引用，那么可以使用外部类名.this的形式，这里如果只使用this，则返回的是内部类对象的引用。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DoThis</span> &#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"This is outClass's method"</span>);&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> DoThis <span class="hljs-title">outer</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> DoThis.<span class="hljs-keyword">this</span>;<span class="hljs-comment">//return this;</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Inner <span class="hljs-title">inner</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Inner();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;DoThis dt = <span class="hljs-keyword">new</span> DoThis();Inner <span class="hljs-keyword">in</span> = dt.inner();<span class="hljs-keyword">in</span>.outer().f();&#125;&#125;<span class="hljs-comment">// output </span>This <span class="hljs-keyword">is</span> outClass<span class="hljs-string">'s method</span></code></pre></div><p>&emsp;&emsp;我们不能使用new直接创建内部类对象，我们需要使用外部类对象的引用创建，这里可以使用外部类对象的引用.new语法进行创建。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoThis</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;<span class="hljs-keyword">public</span> DoThis outer()&#123;<span class="hljs-keyword">return</span> DoThis.<span class="hljs-built_in">this</span>;<span class="hljs-comment">//return this;</span>&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;DoThis dt = <span class="hljs-keyword">new</span> <span class="hljs-type">DoThis</span>();Inner <span class="hljs-keyword">in</span> = dt.<span class="hljs-keyword">new</span> <span class="hljs-type">Inner</span>();&#125;&#125;</code></pre></div><h2 id="10-4-内部类与向上转型"><a href="#10-4-内部类与向上转型" class="headerlink" title="10.4 内部类与向上转型"></a>10.4 内部类与向上转型</h2><p>&emsp;&emsp;当将内部类向上转型为基类时，尤其是转型为接口时，内部类就有了用武之地。这是因为我们可以使内部类也就是接口的实现完全不可见也不可用，得到的只是基类或者接口的引用，从而更好的隐藏了实现的细节。<br></p><p>创建2个接口 和一个类</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>Destination&#123;String readLabel();&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>Contents &#123;int value();&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcell4</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PContents</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Contents</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDestination</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Destination</span></span>&#123;<span class="hljs-keyword">private</span> String label;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">PDestination</span><span class="hljs-params">(String whereto)</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated constructor stub</span>label = whereto;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readLabel</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> label;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Destination <span class="hljs-title">destination</span><span class="hljs-params">(String s)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PDestination(s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Contents <span class="hljs-title">contents</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PContents();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestParcell</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Parcell4 p = <span class="hljs-keyword">new</span> Parcell4();Contents c = p.contents();Destination d = p.destination(<span class="hljs-string">"Inner Class"</span>);System.out.println(d.readLabel());System.out.println(c.value());<span class="hljs-comment">//因为PContents是private 所以不能被访问</span><span class="hljs-comment">//Parcell4.PContents pc = p.new PContents();</span>&#125;&#125;</code></pre></div><p>&emsp;&emsp;上面代码增加了一些新的东西，首先内部类PContents是private，除了Parcell4没有人能访问它，所以main函数最后一行编译不能通过。其次PDestination是protected的，所以除了该类本身和其子类还有同一个包中的类，其它类不能访问。因此客户端如果想访问这些实现，就受到了限制。不过我们可以看到，main函数的第二、第三行都实现了转型，也就是虽然不可见，但是不影响使用接口的实现。因此private的内部类提供了一种设计思路，通过这种方式完全阻止了依赖任何类型的编码，并且完全隐藏了实现的细节，并且由于不能访问任何新增加的、原本不属于公共接口的方法，因此接口的扩展就是没有价值的了。</p><p><strong>如果有对向上转型有什么作用和理解上的问题 可以参考 <a href="https://blog.csdn.net/TNTZS666/article/details/80273986" target="_blank" rel="noopener">https://blog.csdn.net/TNTZS666/article/details/80273986</a> 写的很白话易懂。</strong></p><h2 id="10-5-在方法和作用域内的内部类"><a href="#10-5-在方法和作用域内的内部类" class="headerlink" title="10.5 在方法和作用域内的内部类"></a>10.5 在方法和作用域内的内部类</h2><p> 有些时候我们可以将内部类创建在方法的作用域里或者是其它任何地方的作用域中，这么做有两个理由：</p><ol><li>如前所示，实现了某个类型的接口，可以创建并返回接口的引用。</li><li>要解决一个复杂的问题，需要一个类来辅助解决，但是又不希望这个类是公开的。<br>在方法的作用域内部创建的内部类称为局部内部类：<div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel5</span> </span>&#123; <span class="hljs-keyword">public</span> Destination destination(<span class="hljs-keyword">String</span> s)&#123;  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PDestination</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Destination</span></span></span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> label;   <span class="hljs-keyword">private</span> PDestination(<span class="hljs-keyword">String</span> whereTo)&#123;    label=whereTo;   &#125;   @Override   <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> readLabel() &#123;    <span class="hljs-comment">// TODO Auto-generated method stub</span>    <span class="hljs-keyword">return</span> label;   &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">PDestination</span>(s); &#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;  Parcel5 p5 = <span class="hljs-keyword">new</span> <span class="hljs-type">Parcel5</span>();  Destination d = p5.destination(<span class="hljs-string">"Area Inner Class"</span>);  System.out.println(d.readLabel()); &#125;&#125;</code></pre></div></li></ol><p>如上所示，destination方法中的内部类实现了Destination接口，PDestination类是destination方法内部的类，所以其它地方不能访问。return语句向上转型返回了Destination，它是PDestination类的接口，也就是基类。<br>下面的例子展示在任意作用域中使用内部类：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Parcel6</span> &#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">internalTracking</span>(<span class="hljs-params">boolean b</span>)</span>&#123;<span class="hljs-keyword">if</span>(b)&#123;<span class="hljs-keyword">class</span> <span class="hljs-title">TrackingSkip</span>&#123;<span class="hljs-keyword">private</span> String id;TrackingSkip(String s)&#123;id = s;&#125;<span class="hljs-function">String <span class="hljs-title">getSkip</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> id;&#125;&#125;TrackingSkip ts = <span class="hljs-keyword">new</span> TrackingSkip(<span class="hljs-string">"SLIP"</span>);String s = ts.getSkip();System.<span class="hljs-keyword">out</span>.println(s);&#125;<span class="hljs-comment">//因为内部类在if（b）的作用域内 此处已经超过了作用范围 所以不可以使用</span><span class="hljs-comment">//TrackingSkip ts1 = new TrackingSkip("SLIP1");</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">track</span>(<span class="hljs-params"></span>)</span>&#123;internalTracking(<span class="hljs-literal">true</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Parcel6 p = <span class="hljs-keyword">new</span> Parcel6();p.track();&#125;&#125;</code></pre></div><p>上边的例子主要是想在方法中判断如果入参为true则实现一个类的功能，而这个类又不想被外部可见，所以在if中创建了内部类。</p><h2 id="10-6-匿名内部类"><a href="#10-6-匿名内部类" class="headerlink" title="10.6 匿名内部类"></a>10.6 匿名内部类</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel7</span> </span>&#123; <span class="hljs-function"><span class="hljs-keyword">public</span> Contents <span class="hljs-title">contents</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contents()&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;   <span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// TODO Auto-generated method stub</span>    <span class="hljs-keyword">return</span> i;   &#125;  &#125;; &#125; <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  Parcel7 p7 = <span class="hljs-keyword">new</span> Parcel7();  Contents c = p7.contents(); &#125;&#125;</code></pre></div><p>contents方法内部要返回一个Contents对象的时候，我们突然加了一个类的定义，这个类没有名字，它实现了Contents接口，也就是我们实际上创建了一个继承自Contents类的匿名类对象，于是这个return对象的引用就变成了一个来自向上转型的Contents引用。上述这个匿名内部类是下面这种形式的一种简化。</p><p>下面是无参构造器：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel7</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyContents</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Contents</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> Contents <span class="hljs-title">contents</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyContents();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Parcel7 p7 = <span class="hljs-keyword">new</span> Parcel7();Contents c = p7.contents();&#125;&#125;</code></pre></div><p>有参构造器基类：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapping</span> &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wrapping</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span>&#123;i=x;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> i;&#125;&#125;</code></pre></div><p>匿名内部类：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Parcel8</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> Wrapping <span class="hljs-title">wrapping</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> x</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wrapping(x)&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> super.<span class="hljs-keyword">value</span>() * <span class="hljs-number">11</span>;&#125;&#125;;&#125;&#125;</code></pre></div><p> 只需要传递合适的参数到基类的构造器中即可，虽然Wrapping只是一个普通的实现类，但是他还是被其导出类当做了公共接口来使用。<br>当匿名内部类的域要使用外部对象的引用时，需要强行将函数参数的引用设置为final才可以。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel8</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> Wrapping <span class="hljs-title">wrapping</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> x)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Wrapping(x)&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.value() * x;&#125;&#125;;&#125;&#125;</code></pre></div><h2 id="10-7-嵌套类"><a href="#10-7-嵌套类" class="headerlink" title="10.7 嵌套类"></a>10.7 嵌套类</h2><p>内部类，都是必须要有外部类关联的，也就是这些内部类有个隐式的引用，指向外部类。如果我们不需要这种关联，那么就可以将内部类显示的声明为static的，这种内部类称为嵌套类。嵌套类意味着：</p><ol><li><p>要创建嵌套类的对象，并不依赖外部对象</p></li><li><p>不能从嵌套类的对象中访问非静态的外围类对象</p></li></ol><p>嵌套类与普通的内部类还有一个区别，普通内部类的字段与方法，只能放在类的外部层次上，所以普通的内部类不能有static数据和static字段，也不能包含嵌套类，而嵌套类可以包含所有这些东西。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parcel11</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParcelContents</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Contents</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">11</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">value</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> i;&#125;&#125;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ParcelDestination</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Destination</span></span>&#123;<span class="hljs-keyword">private</span> String label;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ParcelDestination</span><span class="hljs-params">(String whereTo)</span></span>&#123;label = whereTo;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readLabel</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> label;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">8</span>;<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnotherLevel</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">funx</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//</span>&#125;<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> y = <span class="hljs-number">11</span>;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Destination <span class="hljs-title">destination</span><span class="hljs-params">(String s)</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ParcelDestination(s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Contents <span class="hljs-title">contents</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ParcelContents();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Contents c = <span class="hljs-keyword">new</span> ParcelContents();Destination d = <span class="hljs-keyword">new</span> ParcelDestination(<span class="hljs-string">"dss"</span>);Destination d1 = destination(<span class="hljs-string">"d1"</span>);&#125;&#125;</code></pre></div><p>在正常情况下，不能在接口内部放置任何代码，但是嵌套类可以作为接口的一部分，放在接口中的任何域都是public static的，所以放入的类是嵌套类，甚至我们可以使用此类实现外部接口。如果你想要创建某些公共的代码，并让它可以被某个接口的所有不同实现所共有.<br>一个内部类被嵌套多少层并不重要，重要的是它能够透明的访问它所嵌入的外围类的所有成员，即便是被定义为private的域。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ManyInner</span> &#123;</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>&#123;</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>&#123;</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>&#123;f();g();&#125;&#125;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MNA</span>&#123;</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;ManyInner mi = <span class="hljs-keyword">new</span> ManyInner();ManyInner.A a = mi.<span class="hljs-keyword">new</span> A();ManyInner.A.B b = a.<span class="hljs-keyword">new</span> B();b.h();&#125;&#125;</code></pre></div><p> 如上可见，在嵌套了多层的内部类B中调用方法f（）和方法g（）并不需要任何其它附加条件，即便他们被定义为private。</p><h2 id="10-8-为什么需要内部类"><a href="#10-8-为什么需要内部类" class="headerlink" title="10.8 为什么需要内部类"></a>10.8 为什么需要内部类</h2><p>内部类实现接口与外部类实现接口的区别在于后者不是总能享用到接口带来的方便，有时需要用到接口的实现。所以使用内部类最吸引人的原因：<br>    <strong>每个内部类都能够独立的继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的实现），对于内部类都没有影响。</strong></p><p>内部类有效的实现了“多重继承”，如果在一个类中要使用两个接口，那么使用单一类和内部类看起来没有什么区别（因为单一类可以直接实现多个接口，此处不写例子了），而<strong>如果这两个接口换成是抽象类或者是具体的类，那么由于Java不支持多重继承的原因，这里使用单一类显然不能解决问题了，而内部类恰好可以有效的解决这个问题，看似是个“多重继承”。</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">//要继承的类1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span></span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-comment">//要继承的类2</span><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span></span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-comment">//外部类继承A 内部匿名类继承B</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">H</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">F</span></span>&#123;<span class="hljs-function">G <span class="hljs-title">makeG</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> G()&#123;<span class="hljs-comment">//--</span>&#125;;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutiExtends</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeF</span><span class="hljs-params">(F f)</span></span>&#123;<span class="hljs-comment">//--</span>&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">takeG</span><span class="hljs-params">(G g)</span></span>&#123;<span class="hljs-comment">//--</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;H h = <span class="hljs-keyword">new</span> H();takeF(h);takeG(h.makeG());&#125;&#125;</code></pre></div><p>如果不是要解决类似上边的“多重继承”问题，那么可以不实用内部类，但是使用内部类还可以获得一些其它的特性。</p><ol><li>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外部类的对象信息相互独立。</li><li>在单个外围类中，可以让多个内部类继承或实现多个基类。</li><li>创建内部类的时刻并不依赖于外围对象的创建。</li><li>内部类并没有令人迷惑的is-a关系，它是一个独立的实体。</li></ol><h2 id="10-9-内部类的继承"><a href="#10-9-内部类的继承" class="headerlink" title="10.9 内部类的继承"></a>10.9 内部类的继承</h2><p> 内部类由于与外部类之间有一个隐式的引用关联关系，所以在继承内部类的时候，要显示的说明他们之前的关联。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">withInner</span></span>&#123;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span></span>&#123;&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InheritInner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">withInner</span>.<span class="hljs-title">Inner</span></span>&#123;<span class="hljs-type">InheritInner</span>(withInner wi)&#123;wi.<span class="hljs-keyword">super</span>();&#125;public static void main(<span class="hljs-type">String</span>[] args) &#123;withInner wi = <span class="hljs-keyword">new</span> withInner();<span class="hljs-type">InheritInner</span> ii = <span class="hljs-keyword">new</span> <span class="hljs-type">InheritInner</span>(wi);&#125;&#125;</code></pre></div><p>在子类的构造函数中要传入继承内部类的外部类的引用。</p><h2 id="10-10-内部类可以被覆盖吗"><a href="#10-10-内部类可以被覆盖吗" class="headerlink" title="10.10 内部类可以被覆盖吗"></a>10.10 内部类可以被覆盖吗</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span>&#123;<span class="hljs-keyword">private</span> Yolk y;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Yolk</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yolk</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Egg.Yolk"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Egg</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"New Egg"</span>);y = <span class="hljs-keyword">new</span> Yolk();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BigEgg</span> <span class="hljs-title">extends</span> <span class="hljs-title">Egg</span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Yolk</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Yolk</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"BigEgg.Yolk"</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<span class="hljs-keyword">new</span> BigEgg();&#125;&#125;<span class="hljs-comment">//output </span>New EggEgg.Yolk</code></pre></div><p>基类中使用了默认的构造函数，并创建了一个内部类对象，子类中“覆盖”了内部类，所以预期的结果应该是使用子类中覆盖之后的内部类构造器。但是实际结果显然不是这样的，它还是走了正常的逻辑流程，说明子类并没有覆盖基类中内部类，这两个内部类彼此独立，在自己的命名空间中。当我们想进行类似“覆盖”内部类的功能时，可以明确的继承内部类，然后覆盖其方法。</p><h2 id="10-11-局部内部类"><a href="#10-11-局部内部类" class="headerlink" title="10.11 局部内部类"></a>10.11 局部内部类</h2><p>定义在方法体中内部类称为局部内部类：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">interface</span> Counter&#123;<span class="hljs-keyword">int</span> <span class="hljs-keyword">next</span>();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> LocalInnerClass &#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<span class="hljs-comment">//局部内部类</span>Counter getCounter(<span class="hljs-keyword">final</span> String name)&#123;<span class="hljs-keyword">class</span> LocalCounter <span class="hljs-keyword">implements</span> Counter&#123;<span class="hljs-keyword">public</span> LocalCounter()&#123;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"LocalCounter Constructor"</span>);&#125;@Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">next</span>() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.<span class="hljs-keyword">println</span>(name);<span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>++;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LocalCounter();&#125;<span class="hljs-comment">//匿名类</span>Counter getCounter2(<span class="hljs-keyword">final</span> String name)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Counter()&#123;&#123;System.out.<span class="hljs-keyword">println</span>(<span class="hljs-string">"Counter Constructor"</span>);&#125;@Override<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">next</span>() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.<span class="hljs-keyword">println</span>(name);<span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>++;&#125;&#125;;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(String[] args) &#123;LocalInnerClass lc = <span class="hljs-keyword">new</span> LocalInnerClass();Counter c1 = lc.getCounter(<span class="hljs-string">"Local Counter"</span>);Counter c2 = lc.getCounter2(<span class="hljs-string">"Annoy Counter"</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;System.out.<span class="hljs-keyword">println</span>(c1.<span class="hljs-keyword">next</span>());&#125;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;System.out.<span class="hljs-keyword">println</span>(c2.<span class="hljs-keyword">next</span>());&#125;&#125;&#125;</code></pre></div><p>它们具有相同的行为能力，那么既然局部类在方法体外部是看不见的，那么为什么不使用匿名类呢？唯一的理由是我们需要一个已命名的构造器，或者重载构造器，而匿名类只能用于实例初始化。也就是说因为没有名字，所以没有可见的构造器。所以使用局部内部类的另一个原因就是需要不止一个该内部类的对象。</p><h2 id="10-12-内部类标识符"><a href="#10-12-内部类标识符" class="headerlink" title="10.12 内部类标识符"></a>10.12 内部类标识符</h2><p> 由于每个类都会产生一个.class文件，其中包含如何创建该类型的全部信息。（此信息产生一个“meta-class”,叫做class对象）所以内部类也一定会有个.class文件，它们有规范的命名规则，外围类加上“$”加上内部类的名字。</p><p>    如果是匿名内部类，编译器会简单的产生一个数字作为标识符，如果内部类是嵌套在别的内部类里，那么就继续使用”$”符号。</p><h2 id="10-13-总结"><a href="#10-13-总结" class="headerlink" title="10.13 总结"></a>10.13 总结</h2><ol><li>内部类是定义在一个类内部的类，这个类可以在方法中，也可以在方法外。内部类可以访问到其外部类的所有域。</li><li>内部类与外部类之间的关联关系是使用一个隐式的外部类引用，所以在创建内部类时，需要先创建一个外部类引用进行关联。这种形式出现在当内部类不是static修饰并且在static方法域中创建内部类对象引用的时候。</li><li>在内部类中，要使用外部类.this才可以返回外部类的对象引用，如果使用this只是返回了内部类的对象引用。当我们创建了一个外部类对象引用时，可以使用引用.new 内部类（）的形式创建内部类对象。</li><li>内部类可以用来向上转型实现接口，这种方式有效的建立了接口与实现的隔离，可以使实现完全不可见，不可修改。</li><li>在方法和作用域里的类，有两个作用，一个是如前所示用来实现接口并返回。另一个原因是我想创建一个类辅助我解决问题，但是不想这个类可见。</li><li>使用return new xx（）{} 在{}内部定义类的一些域可以创建一个实现或继承xx的匿名类，这个匿名类没有名字，也就没有构造函数。匿名类使用的外部方法引用需要被修饰为final。</li><li>如前所示，内部类的创建需要与外部类进行关联。如果我们不需要进行关联，那么可以将内部类修饰为static，这种称为嵌套类。嵌套类与外部类彼此独立。</li><li>内部类可以实现类似“多重继承”。</li><li>内部类与外部类的引用有关联，所以在继承内部类的时候需要显示的在构造函数中引用外部类的引用，以说明这种关联。</li><li>外部类被继承之后，内部类没有发生特别的变化，也就是它不会被覆盖，如果在子类中重新定义同名的内部类，这会被认为是第二个类，与之前的内部类彼此在不同的命名空间，没有关联。</li><li>局部内部类是定义在方法中的，作用与匿名类相同，但是有构造函数，可以进行构造函数重载。</li><li>所有的类都有标识符，内部类的标识符为外部类名字$内部类名字。</li></ol><p>此章节大量引用 crayoncxy 的学习笔记,大体总结很到位,(比自己总结的到位)所以读完就直接拉过来了。链接：<a href="https://crayoncxy.github.io/2018/11/15/%E3%80%90Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%91%E5%8D%81%E4%B8%80%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/" target="_blank" rel="noopener">https://crayoncxy.github.io/2018/11/15/%E3%80%90Java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%91%E5%8D%81%E4%B8%80%EF%BC%9A%E5%86%85%E9%83%A8%E7%B1%BB/</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第九章</title>
    <link href="/2019/07/30/Thinking-in-Java-%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
    <url>/2019/07/30/Thinking-in-Java-%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第九章-接口"><a href="#第九章-接口" class="headerlink" title="第九章 接口"></a>第九章 接口</h1><p>接口和内部类为我们踢动了一种将接口与实现分离的更加结构化的方法。</p><h2 id="9-1-抽象类和抽象方法"><a href="#9-1-抽象类和抽象方法" class="headerlink" title="9.1 抽象类和抽象方法"></a>9.1 抽象类和抽象方法</h2><p>&emsp;&emsp;在第八章关于多态的例子中，基类方法往往没有具体的实现，它存在的目的是为不同的子类提供统一的方法，通过动态绑定以及向上转型来完成子类需要的功能。为此，我们可以创建一个这样的类，只为子类提供接口，并且不允许这个类实例化对象，我们可以让这个类中的方法返回一个错误信息，但是这样存在一个问题，错误只能在运行时产生并且带来的影响不可预估。Java为我们提供了一个更加明确的方法，称为抽象方法，抽象方法顾名思义它是虚拟存在的，也就是它不能够被执行。这种方法是不完整的，它只有方法的声明，没有方法的实现，为了区分，使用abstract关键字表示一个方法是抽象方法。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>;</code></pre></div><p>&emsp;&emsp;包含抽象方法的类叫做抽象类，如果一个类包含一个或多个抽象方法，那么这个类叫做抽象类，同样使用abstract关键字修饰。抽象类是不安全的，因为它不完整，所以当试图用它实例化一个对象时，编译器会报错。如果一个类继承自一个抽象类，那么它必须为基类中所有的抽象方法提供一个具体的实现，否则这个子类也必须被定义为抽象类。我们也可以定义一个没有任何方法（包括没有抽象方法）的抽象类，这样做的目的是，这个类没有什么实际的意义，同时也不想让它能够创建对象。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">what</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Instrumet"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String s)</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">what</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Wind"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String s)</span></span>&#123;System.out.println(<span class="hljs-string">"Wind.play"</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Percussion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">what</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Percussion"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String s)</span></span>&#123;System.out.println(<span class="hljs-string">"Percussion.play"</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stringed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">what</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Stringed"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String s)</span></span>&#123;System.out.println(<span class="hljs-string">"Stringed.play"</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Brass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">what</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Brass"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String s)</span></span>&#123;System.out.println(<span class="hljs-string">"Brass.play"</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WoodWind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">what</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"WoodWind"</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String s)</span></span>&#123;System.out.println(<span class="hljs-string">"WoodWind.play"</span> + s);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">adjust</span><span class="hljs-params">()</span></span>&#123;&#125;;&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tune</span><span class="hljs-params">(Instrument i )</span></span>&#123;i.play(<span class="hljs-string">"finish"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tuneAll</span><span class="hljs-params">(Instrument[] e)</span></span>&#123;<span class="hljs-keyword">for</span>(Instrument i:e)&#123;tune(i);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Instrument[] iArray = &#123;<span class="hljs-keyword">new</span> Wind(),<span class="hljs-keyword">new</span> Percussion(),<span class="hljs-keyword">new</span> Brass(),<span class="hljs-keyword">new</span> Stringed(),<span class="hljs-keyword">new</span> WoodWind()&#125;;tuneAll(iArray);&#125;&#125;<span class="hljs-comment">//output </span>Wind.playfinishPercussion.playfinishBrass.playfinishStringed.playfinishWoodWind.playfinish</code></pre></div><p>&emsp;&emsp;创建抽象类和抽象方法非常的有用，因为他们使类的抽象性更加明确，并告诉用户和编译器打算怎么样使用他们。抽象类还是一个很有用的重构工具，因为他们使得我们可以很容易的将公共方法沿着继承的层次向上移动。但是除了框架这么用 一般鞋业务很少设计这么复杂。</p><h2 id="9-2-接口"><a href="#9-2-接口" class="headerlink" title="9.2 接口"></a>9.2 接口</h2><p>&emsp;&emsp;使抽象的概念更加深入了一步。抽象类中可以允许抽象方法和普通方法共存，普通方法存在的目的是为所有继承的子类提供一个相同实现的方法。而接口创建了一个完全抽象的概念，接口内部不存在任何方法具体的实现。所有的实现都交由到实现这个接口的类完成。<br><br>&emsp;&emsp;接口使用interface关键字代替class关键字，访问权限控制与一个class相同，接口中可以包含域，但是这些域被隐式的定义为static和final型。<br><br>&emsp;&emsp;要想实现一个接口，就需要使用implements关键字显示的指明要实现哪个接口。接口中的方法必须被定义为public方法。实现接口的类要显示的编写实现接口中的所有方法，即便有些方法不需要实现，那也要如同接口一样写一个空的方法体。</p><h2 id="9-3-完全解耦"><a href="#9-3-完全解耦" class="headerlink" title="9.3 完全解耦"></a>9.3 完全解耦</h2><p>只要一个方法操作的是类而非接口，那么你就只能使用这个类及其子类。如果你想将这个方法应用在不在此继承结构中的某个类，那么使用接口将很大程度的放宽这种限制。因此，它可以使我们编写可复用性更好的代码。<br>    例如，有一个Processor类，它有一个name（）方法，还有一个process（）方法，该方法接受输入参数，修改输入的值然后进行输出。这个类作为基类被扩展，子类创建各种不同类型的Processor，在本例中，Processor子类通过process（）方法修改String对象的值，返回类型可以是协变类型，而非参数类型。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">import</span> java.util.<span class="hljs-type">Arrays</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Processor</span></span>&#123;    public <span class="hljs-type">String</span> name()&#123;        <span class="hljs-keyword">return</span> getClass().getSimpleName();    &#125;    <span class="hljs-type">Object</span> process(<span class="hljs-type">Object</span> input)&#123;        <span class="hljs-keyword">return</span> input;    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpCase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Processor</span></span>&#123;    <span class="hljs-type">String</span> process(<span class="hljs-type">Object</span> input)&#123;        <span class="hljs-keyword">return</span> input.toString().toUpperCase();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownCase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Processor</span></span>&#123;    <span class="hljs-type">String</span> process(<span class="hljs-type">Object</span> input)&#123;        <span class="hljs-keyword">return</span> input.toString().toLowerCase();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Splitter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Processor</span></span>&#123;    <span class="hljs-type">String</span> process(<span class="hljs-type">Object</span> input)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-type">Arrays</span>.toString(input.toString().split(<span class="hljs-string">" "</span>));    &#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span></span>&#123;    public static void process(<span class="hljs-type">Processor</span> p,<span class="hljs-type">Object</span> s)&#123;        <span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Using Processor:"</span> + p.name());        <span class="hljs-type">System</span>.out.println(p.process(s));    &#125;    public static <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-type">S</span> = <span class="hljs-string">"Disagreement with beliefs is by definition incorrect"</span>;    public static void main(<span class="hljs-type">String</span>[] args) &#123;        process(<span class="hljs-keyword">new</span> <span class="hljs-type">UpCase</span>(), <span class="hljs-type">S</span>);        process(<span class="hljs-keyword">new</span> <span class="hljs-type">DownCase</span>(), <span class="hljs-type">S</span>);        process(<span class="hljs-keyword">new</span> <span class="hljs-type">Splitter</span>(), <span class="hljs-type">S</span>);    &#125;&#125;<span class="hljs-comment">//output </span><span class="hljs-type">Using</span> <span class="hljs-type">Processor</span>:<span class="hljs-type">UpCase</span><span class="hljs-type">DISAGREEMENT</span> <span class="hljs-type">WITH</span> <span class="hljs-type">BELIEFS</span> <span class="hljs-type">IS</span> <span class="hljs-type">BY</span> <span class="hljs-type">DEFINITION</span> <span class="hljs-type">INCORRECT</span><span class="hljs-type">Using</span> <span class="hljs-type">Processor</span>:<span class="hljs-type">DownCase</span>disagreement <span class="hljs-keyword">with</span> beliefs is by definition incorrect<span class="hljs-type">Using</span> <span class="hljs-type">Processor</span>:<span class="hljs-type">Splitter</span>[<span class="hljs-type">Disagreement</span>, <span class="hljs-keyword">with</span>, beliefs, is, by, definition, incorrect]</code></pre></div><p>Apply.process()方法可以接收Processor类型跟它的子类，并将它应用到了Object对象，然后打印。像这种，根据继承关系，创建一个能够根据所传递的参数对象不同而具有不同行为的方法，称为策略设计模式。这类方法包含索要执行的方法中固定不变的部分（如本例的name（）方法），而“策略”包含变化的部分（如本例的process（））方法。策略就是传递的参数对象，它包含要执行的代码。这类Processor对象就是一个策略，在main（）方法中可以看到三种不同类型的策略应用到Obejct对象上。</p><p>如果操作的是接口而不是类的时候，那么这些限制就会变得松动，使得你可以复用接口的Apply.process()方法，下面是修改为接口的版本。</p><div class="hljs"><pre><code class="hljs undefined">package com.chenxyt.java.practice;public<span class="hljs-built_in"> interface </span>Processor&#123;String name();Object process (Object input);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.practice;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterAdapter</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Processor</span></span></span>&#123;Filter filter;<span class="hljs-keyword">public</span> FilterAdapter(Filter filter)&#123;<span class="hljs-built_in">this</span>.filter = filter;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> name()&#123;<span class="hljs-keyword">return</span> filter.name();&#125;<span class="hljs-keyword">public</span> WaveForm process(Object input)&#123;<span class="hljs-keyword">return</span> filter.process((WaveForm)input)&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterProcessor</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;WaveForm w = <span class="hljs-keyword">new</span> <span class="hljs-type">WaveForm</span>();Apply.process(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">LowPass</span>(<span class="hljs-number">1.0</span>)),w);Apply.process(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">HighPass</span>(<span class="hljs-number">2.0</span>)),w);Apply.process(<span class="hljs-keyword">new</span> <span class="hljs-type">FilterAdapter</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">BandPass</span>(<span class="hljs-number">3.0</span>,<span class="hljs-number">4.0</span>)),w);&#125;&#125;</code></pre></div><p> 在这种使用适配器的方式中，FilterAdapter的构造器接受了Filter参数，然后生成对应接口Processor的对象。<br>本节主要的内容是使用接口的方式将只有基类和其子类的使用方法解耦出来，便于程序更好的进行复用。</p><h2 id="9-4-Java中的多重继承"><a href="#9-4-Java中的多重继承" class="headerlink" title="9.4 Java中的多重继承"></a>9.4 Java中的多重继承</h2><p>C++中允许多重继承，并且每一个继承的类都可以有一个实现，Java中是不允许的，Java中可以实现多个接口，每个接口名字在implements后边用逗号隔开，并且，Java中只能继承一个类。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CanFight</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fight</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CanSwim</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Swim</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CanFly</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActionChracter</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fight</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//---</span>&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hero</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ActionChracter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CanFight</span>,<span class="hljs-title">CanSwim</span>,<span class="hljs-title">CanFly</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Fly</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//---</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swim</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//--</span>&#125;;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adventure</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">t</span><span class="hljs-params">(CanFight x)</span></span>&#123;x.Fight();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">u</span><span class="hljs-params">(CanSwim x)</span></span>&#123;x.Swim();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">v</span><span class="hljs-params">(CanFly x)</span></span>&#123;x.Fly();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">w</span><span class="hljs-params">(ActionChracter x)</span></span>&#123;x.Fight();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Hero h = <span class="hljs-keyword">new</span> Hero();t(h);u(h);v(h);w(h);&#125;&#125;</code></pre></div><p> 可以看到Hero类组合具体类ActionChracter和另外的三个接口，当通过这种方式将类和接口组合在一起时，这个类必须放在前边，接口放在后边，否则编译器会报错。同时我们注意到，CanFight接口与ActionChracter类中的Fight（）方法相同，而且Hero中并没有提供Fight（）的具体定义。可以扩展接口，当想要创建对象的时候，所有的定义必须都存在，即使Hero没有显示的定义Fight（）方法，由于其继承了ActionChracter类，所以定义随之而来，这使创建对象变成了可能。这里的意思是说，一个类实现了某些接口，这些接口中所有的定义在这个类中必须要有相关的实现（编译器会主动提示），然后因为这个类继承了一个类（ActionChracter），所以如果基类有实现了接口中的方法，那么子类就可以不显示的实现这个方法。</p><p>这个例子中，给出的四个方法分别使用接口作为了参数，所以在Hero作为参数传递的时候，它被依次进行了向上转型，Java中的接口设计，使得这项功能并不复杂。这个例子所展示的是使用接口的核心原因：为了能够向上转型为多个基本类型，提升程序的灵活性。使用接口的第二个原因与抽象类相同，防止程序员在使用的过程中创建该类的对象。当然关于这一点是使用抽象类还是接口，当要创建的类中没有任何方法定义和成员变量的定义是，选择接口是合适的，并且当知道某事物应当成为一个基类的时候，那么第一选择是应当使它成为接口。</p><h2 id="9-5-通过继承来扩展接口"><a href="#9-5-通过继承来扩展接口" class="headerlink" title="9.5 通过继承来扩展接口"></a>9.5 通过继承来扩展接口</h2><p>接口也可以继承，通过继承可以很容易的在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">Monster</span>&#123;<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">menace</span>();&#125;<span class="hljs-comment">//新接口继承原来的接口</span><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">DangerousMonster</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">Monster</span>&#123;<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">destroy</span>();&#125;<span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">Lethal</span>&#123;<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">kill</span>();&#125;<span class="hljs-comment">//实现接口 要依次定义这个接口的方法以及它继承接口的方法  编译器自动补充</span><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">DragonZill</span> <span class="hljs-selector-tag">implements</span> <span class="hljs-selector-tag">DangerousMonster</span>&#123;<span class="hljs-variable">@Override</span>public void menace() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;<span class="hljs-variable">@Override</span>public void destroy() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-comment">//接口可以多重继承</span><span class="hljs-selector-tag">interface</span> <span class="hljs-selector-tag">Vampire</span> <span class="hljs-selector-tag">extends</span> <span class="hljs-selector-tag">DangerousMonster</span> ,<span class="hljs-selector-tag">Lethal</span>&#123;<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">drinkblood</span>();&#125;<span class="hljs-comment">//继承多个接口 都要把定义实现</span><span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">VeryBadVampire</span> <span class="hljs-selector-tag">implements</span> <span class="hljs-selector-tag">Vampire</span>&#123; <span class="hljs-variable">@Override</span>public void destroy() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125; <span class="hljs-variable">@Override</span>public void menace() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125; <span class="hljs-variable">@Override</span>public void kill() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125; <span class="hljs-variable">@Override</span>public void drinkblood() &#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;</code></pre></div><p><strong>组合不同的接口中避免使用相同的方法名。</strong></p><h2 id="9-6-适配接口"><a href="#9-6-适配接口" class="headerlink" title="9.6 适配接口"></a>9.6 适配接口</h2><p>&emsp;&emsp;接口最吸引人的地方，就是允许同一个接口具有多个不同的实现。简单来说，就是一个接受接口类型的方法，而该接口的实现和向该接口传递的对象取决于方法的使用者。因此常用的方式就是前边的策略模式，此时你编写一个执行某些操作的方法，该方法接受一个同样是你指定的接口，你主要就是声明”你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口“这使你的方法更加灵活。</p><h2 id="9-7-接口中的域"><a href="#9-7-接口中的域" class="headerlink" title="9.7 接口中的域"></a>9.7 接口中的域</h2><p>&emsp;&emsp;在接口中的域，会被自动的隐式转换为static final类型，所以接口就可以很便捷的创建一组常量值，也就是枚举。在JavaSE5之前，没有枚举的概念之前，可以使用接口来创建常量组。</p><div class="hljs"><pre><code class="hljs undefined">public<span class="hljs-built_in"> interface </span>Months&#123;int JANUARY = 1,<span class="hljs-attribute">FEBRUARY</span>=2,MARCH=3,APRIL=4,<span class="hljs-attribute">MAY</span>=5,JUNE=6,JULY=7,AUGUST=8,SEPTEMBER=9,OCTOBER=10,<span class="hljs-attribute">NOVEMBER</span>=11,DECEMBER=12;&#125;</code></pre></div><p>&emsp;&emsp;这种形式在后来已经被enum取代了。因为是final类型，所以必须显示的指定初始化的值，同时因为是static域，所以它们在第一次访问的时候被初始化，并且这些域不属于接口的一部分，它们的值存储在接口的静态存储区域。</p><h2 id="9-8-嵌套接口"><a href="#9-8-嵌套接口" class="headerlink" title="9.8 嵌套接口"></a>9.8 嵌套接口</h2><p>接口可以嵌套在类或者其它的接口中。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">B</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BImp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">B</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CImp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">C</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">D</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">D</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DImp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">D</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> D <span class="hljs-title">getD</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DImp();&#125;<span class="hljs-keyword">private</span> D dRef;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reveiveD</span><span class="hljs-params">(D d)</span></span>&#123;dRef = d;dRef.f();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">E</span></span>&#123;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">G</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">H</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//强制必须为public</span><span class="hljs-comment">//private interface I&#123;&#125;;</span>&#125; <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NestingInterfaces</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>.<span class="hljs-title">B</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">A</span>.<span class="hljs-title">C</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-comment">//因为接口D是私有的 所以不能被实现</span><span class="hljs-comment">//class DImp implements A.D&#123;);</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">E</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EGImp</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">E</span>.<span class="hljs-title">G</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EImp2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">E</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EG</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">E</span>.<span class="hljs-title">G</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;A a = <span class="hljs-keyword">new</span> A();<span class="hljs-comment">//D是private 不能实例化</span><span class="hljs-comment">//A.D ad = new A.D();</span><span class="hljs-comment">//getD()方法只能返回D</span><span class="hljs-comment">//A.DImp2 di2 = a.getD();</span><span class="hljs-comment">//private接口的域不能被访问</span><span class="hljs-comment">//a.getD().f();</span><span class="hljs-comment">//可以通过内部返回域的方法获取</span>A a2 = <span class="hljs-keyword">new</span> A();a2.reveiveD(a.getD());&#125;&#125;</code></pre></div><p>理解不太透彻，不做解析了。。。 自己看书把。</p><h2 id="9-9-接口与工厂"><a href="#9-9-接口与工厂" class="headerlink" title="9.9 接口与工厂"></a>9.9 接口与工厂</h2><p>&emsp;&emsp;接口是实现多重继承的重要途径，而生成遵循某个接口对象的典型方式就是工厂方法设计模式。<br>&emsp;&emsp;使用工厂方法与直接调用构造器不同，我们在工厂对象上调用的是创建方法，而该工厂对象将生成接口的某个实现的对象。理论上来说，我们通过这种方式可以将我们的代码与接口的实现完全分离，这就使我们可以透明的将某个实现替换成另一个实现。使用工厂方法设计模式的原因是想要创建框架，提高代码的复用性。如下：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Game</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">GameFactory</span></span>&#123;<span class="hljs-function">Game <span class="hljs-title">getGame</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Checkers</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> moves = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOVES = <span class="hljs-number">3</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"Checkers moves"</span> + moves);<span class="hljs-keyword">return</span> ++moves != MOVES;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CheckersFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GameFactory</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Game <span class="hljs-title">getGame</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Checkers();&#125;&#125; <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chess</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Game</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> moves = <span class="hljs-number">0</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MOVES = <span class="hljs-number">4</span>;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">move</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span>System.out.println(<span class="hljs-string">"Chess move"</span> + moves);<span class="hljs-keyword">return</span> ++moves != MOVES;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChessFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">GameFactory</span></span>&#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Game <span class="hljs-title">getGame</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">// TODO Auto-generated method stub</span><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Chess();&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Games</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PlayGame</span><span class="hljs-params">(GameFactory fact)</span></span>&#123;Game s = fact.getGame();<span class="hljs-keyword">while</span>(s.move())&#123;<span class="hljs-comment">//--</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;PlayGame(<span class="hljs-keyword">new</span> CheckersFactory());PlayGame(<span class="hljs-keyword">new</span> ChessFactory());&#125;&#125;</code></pre></div><p>如果Games类表示一段复杂的代码，那么这种方式就允许你在不同的游戏类型中复用这段代码。<strong>工厂设计模式主要是框架饿设计。</strong></p><h2 id="9-10-总结"><a href="#9-10-总结" class="headerlink" title="9.10 总结"></a>9.10 总结</h2><p>&emsp;&emsp;抽象类跟接口是将具体方法更加抽象的一种形式。这一章节主要讲了抽象类、抽象方法的形式以及使用场景，比较重要的一点是关于接口的使用，如何解耦，接口可以多重继承，接口可以嵌套等应用场景。任何抽象性设计都应该真正的需求而产生的。需要时候应该重构接口 而不是导出添加额外的类来增加复杂性。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第八章</title>
    <link href="/2019/07/27/Thinking-in-Java-%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
    <url>/2019/07/27/Thinking-in-Java-%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第八章-多态"><a href="#第八章-多态" class="headerlink" title="第八章 多态"></a>第八章 多态</h1><p>多态是继数据抽象和继承之后的第三种基本特征。</p><h2 id="8-1-再讨论向上转型"><a href="#8-1-再讨论向上转型" class="headerlink" title="8.1 再讨论向上转型"></a>8.1 再讨论向上转型</h2><p>在第七章中我们说过，对象引用既可以作为它自己本身的类型使用，也可以作为它的基类型使用，这种把某个类型引用作为它的基类型使用的做法被称为向上转型。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Instrument</span>(<span class="hljs-params"></span>)</span> &#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Instrument-----:"</span>);&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-title">extends</span> <span class="hljs-title">Instrument</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Wind-----:"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Music</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span>(<span class="hljs-params">Instrument i</span>)</span>&#123;i.print();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Wind wind = <span class="hljs-keyword">new</span> Wind();play(wind);&#125;&#125;<span class="hljs-comment">// output </span>Wind-----:</code></pre></div><p>Main方法中play方法传递wind引用的时候，不需要做任何类型转换。这样做是允许的，因为Wind自Instrument类继承而来，所以Instrument类的接口必定存在于Wind类中。这种向上转型的特性，避免了重新编写方法带来的程序代码冗余问题。</p><h2 id="8-2-转机"><a href="#8-2-转机" class="headerlink" title="8.2 转机"></a>8.2 转机</h2><p>当有多个子类的时候，编译器是怎样知道我们传递给基类引用的参数是哪个子类呢？比如我们把刚才的程序做个修改，再增加一个子类：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Instrument</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"Instrument-----:"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wind</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"Wind-----:"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Instrument</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"Rain-----"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Music</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(Instrument i)</span></span>&#123;i.print();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Rain rain = <span class="hljs-keyword">new</span> Rain();play(rain);&#125;&#125;<span class="hljs-comment">// output </span>Rain-----</code></pre></div><br>     在play方法中，既然做到了向上转型，那么编译器怎样知道类型从哪里转来的呢？即执行哪个对应的print()方法呢？解决这个问题有一个新的概念叫**后期绑定**，就是程序运行时根据对象的类型来进行绑定，也叫做动态绑定。一种语言要想实现动态绑定，那么它必须具有某种特定的机制来支持它在运行时准确的找到对象引用对应的类型，随着语言的不同这种机制有所不同，但大体上都是在对象中增加了某种类型信息。<br>    **Java中除了static和final之外，其它所有的方法都是后期绑定**，所以我们无需显示的去做什么操作，因为动态绑定会自动发生。而前期绑定并不会对性能造成什么影响，使用final修饰的意图是防止被覆盖，并且告诉编译器这个是前期绑定，那么编译器可以更好的为其分配资源。<br>    上述代码中，不同的子类与基类都有相同的方法（返回值、方法名、参数列表都相同），但是方法体内部不相同，这种操作叫做方法的重写或者方法的覆盖，即子类覆盖了父类方法的实现，当参数传递为子类对象的引用时，虽然看似调用了父类的这个方法，但是实际上由于动态绑定调用了子类的方法，实现了不同的功能。这也就是面向对象编程中多态的意义所在。<h4 id="8-2-4-缺陷：-“覆盖”-私有方法"><a href="#8-2-4-缺陷：-“覆盖”-私有方法" class="headerlink" title="8.2.4 缺陷： “覆盖” 私有方法"></a>8.2.4 缺陷： “覆盖” 私有方法</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PrivateOverride</span>&#123;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"private void f"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;PrivateOverride po = <span class="hljs-keyword">new</span> Derived();po.f();&#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Derived</span> <span class="hljs-title">extends</span> <span class="hljs-title">PrivateOverride</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"public void f"</span>);&#125;&#125;<span class="hljs-comment">// output private void f</span></code></pre></div><p>解析：私有方法被认为是final 不会被覆盖，而且是被继承类屏蔽的。所以Derived()中的f()当做一个新的方法执行。所以不能被覆盖。</p><h4 id="8-2-5-缺陷-域与静态方法"><a href="#8-2-5-缺陷-域与静态方法" class="headerlink" title="8.2.5 缺陷:  域与静态方法"></a>8.2.5 缺陷:  域与静态方法</h4><p>对于域和静态方法都不是多态的。域是在访问的时候编译期进行解析的。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Super</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> field = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getField</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> field;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sub</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Super</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> field = <span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getField</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> field;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSuperField</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.field;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">fieldAccess</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Super sup = <span class="hljs-keyword">new</span> Sub();System.out.println(<span class="hljs-string">"sup.field"</span> + sup.field + <span class="hljs-string">"---sup.GetField"</span> + sup.getField());Sub sub = <span class="hljs-keyword">new</span> Sub();System.out.println(<span class="hljs-string">"sub.field"</span> + sub.field + <span class="hljs-string">"---sub.GetField"</span> + sub.getField() + <span class="hljs-string">"---sub.GetSuperField"</span> + sub.getSuperField());&#125;&#125;<span class="hljs-comment">//output </span>sup.field0---sup.GetField1sub.field1---sub.GetField1---sub.GetSuperField0</code></pre></div><p>解析：<br></p><ol><li>任何域访问操作都将由对象编译器解析，因此不是多态的。 <strong>Super.field 和 Sub.field 分配了不同的空间。</strong></li><li> 静态方法由于只与类有关，而不与对象牵连，因此它不存在多态的形式。</li></ol><h2 id="8-3-构造器的多态"><a href="#8-3-构造器的多态" class="headerlink" title="8.3 构造器的多态"></a>8.3 构造器的多态</h2><p>构造器属于类的，它是一个隐式的static方法，因此不存在多态。这里继续分析构造器的调用过程。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">First</span></span>&#123;public <span class="hljs-type">First</span>()&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"First---"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Second</span></span>&#123;public <span class="hljs-type">Second</span>()&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Second---"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Third</span></span>&#123;public <span class="hljs-type">Third</span>()&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Third---"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fourty</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Third</span></span>&#123;public <span class="hljs-type">Fourty</span>()&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Fourty---"</span>);&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fifty</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fourty</span></span>&#123;public <span class="hljs-type">Fifty</span>()&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Fifty---"</span>);&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sixty</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fifty</span></span>&#123;public <span class="hljs-type">Sixty</span>()&#123;<span class="hljs-type">System</span>.out.println(<span class="hljs-string">"Sixty---"</span>);&#125;<span class="hljs-type">First</span> first = <span class="hljs-keyword">new</span> <span class="hljs-type">First</span>();<span class="hljs-type">Second</span> second = <span class="hljs-keyword">new</span> <span class="hljs-type">Second</span>();public static void main(<span class="hljs-type">String</span>[] args) &#123;<span class="hljs-keyword">new</span> <span class="hljs-type">Sixty</span>();&#125;&#125;</code></pre></div><p><strong>类的加载过程是自上而下的，因此会先寻找基类进行加载，待所有继承类就加载完成之后，加载子类的成员变量以及构造函数。</strong><br>最终程序执行顺序如下：</p><ol><li>初始化基类中用到的静态变量，静态方法。</li><li>初始化main（）方法中的常量，如果是有静态变量的对象，先初始化静态变量，然后加载其构造器。</li><li>加载基类构造器。</li><li>按顺序初始化成员变量。</li><li>加载子类构造器。</li></ol><h2 id="8-4-协变返回类型"><a href="#8-4-协变返回类型" class="headerlink" title="8.4 协变返回类型"></a>8.4 协变返回类型</h2><p>JavaSE5中新增了协变返回类型，在子类中的覆盖方法，可以返回其基类中该方法返回类型的某一个子类型。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;public <span class="hljs-type">String</span> toString()&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Father"</span>;&#125;;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;public <span class="hljs-type">String</span> toString()&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Son"</span>;&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mill</span></span>&#123;<span class="hljs-type">Father</span> process()&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Father</span>();&#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">wheatMill</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mill</span></span>&#123;<span class="hljs-type">Son</span> process()&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Son</span>();&#125;&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span></span>&#123;public static void main(<span class="hljs-type">String</span>[] args) &#123;<span class="hljs-type">Mill</span> m = <span class="hljs-keyword">new</span> <span class="hljs-type">Mill</span>();<span class="hljs-type">Father</span> f = m.process();<span class="hljs-type">System</span>.out.println(f);m = <span class="hljs-keyword">new</span> wheatMill();f = <span class="hljs-keyword">new</span> <span class="hljs-type">Son</span>();<span class="hljs-type">System</span>.out.println(f);&#125;&#125;<span class="hljs-comment">// output </span><span class="hljs-type">Father</span><span class="hljs-type">Son</span></code></pre></div><h2 id="8-5-用继承进行设计"><a href="#8-5-用继承进行设计" class="headerlink" title="8.5 用继承进行设计"></a>8.5 用继承进行设计</h2><p>继承会增加程序的复杂性，在程序设计过程中应优先使用组合。如果单纯的是想使用某一个类，让这个类的对象完成一些功能，那么使用组合会更好一些。此外， 对于继承中多态的实现，很大部分原因是由于向上转型与动态绑定，针对向上转型，与之相对的叫做向下转型，我们都知道向上转型是安全的，而由于扩展性的原因，向下转型并不是安全的。因为父类可能并没有子类中的一个方法。</p><h2 id="8-6-总结"><a href="#8-6-总结" class="headerlink" title="8.6 总结"></a>8.6 总结</h2><p>如果不运用数据抽象和继承，就不能季节多态的例子。 多态是面向对象“封装”、“继承”、“多态”三大特性之一，理解多态的特性能够更好的设计程序，同时，掌握程序初始化加载的过程能够更好的理解程序。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java &amp;&amp; php 知识梳理和简要自学路线 </title>
    <link href="/2019/07/24/java-php-%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%92%8C%E7%AE%80%E8%A6%81%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF/"/>
    <url>/2019/07/24/java-php-%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86%E5%92%8C%E7%AE%80%E8%A6%81%E8%87%AA%E5%AD%A6%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><ul><li>编程语言 java php …</li><li>基本算法</li><li>网络知识 tcp/ip http/https</li><li>系统知识</li><li>基本设计模式</li></ul><hr><h2 id="工具方面"><a href="#工具方面" class="headerlink" title="工具方面"></a>工具方面</h2><ul><li>系统 linux/unix (deepin ubuntu mac) 比较好用的本地开发环境 </li><li>代码管理 git/svn</li><li>持续集成 （CI/CD） jenkins / gitlab （CI/CD） + yml脚本 实现自动部署</li><li>java项目管理工具 Maven/ Gradle</li><li>php 依赖管理工具 composer </li></ul><hr><h2 id="框架方面"><a href="#框架方面" class="headerlink" title="框架方面"></a>框架方面</h2><h4 id="应用层框架"><a href="#应用层框架" class="headerlink" title="应用层框架"></a>应用层框架</h4><h5 id="java"><a href="#java" class="headerlink" title="java"></a>java</h5><ul><li>ssh spring + structs + hibernates (java 早期)</li><li>ssm spring + springmvc + mybatis</li><li>spring boot</li></ul><h5 id="php"><a href="#php" class="headerlink" title="php"></a>php</h5><ul><li>thinkphp </li><li>yii</li><li>laravel</li><li>phalcon （扩展级别 高性能）</li><li>yar （rpc通信框架）</li><li>swoole （解决php 并发 异步 socket 框架 扩展实现）</li><li>workerman （ php实现 简单 易学 socket 框架）</li></ul><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><ul><li><p>MQ消息队列</p></li><li><p>RPC通信框架</p><ol><li>gRPC thrift dubbo springcloud （java）</li><li>elasticsearch 数据库 搜索引擎</li><li>yar swoole（php） </li></ol></li></ul><h4 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h4><ul><li>SQL : mysql</li><li>NOSQL : redis  memcached mongodb elasticsearch</li></ul><hr><h2 id="架构方面"><a href="#架构方面" class="headerlink" title="架构方面"></a>架构方面</h2><h4 id="分布式-微服务"><a href="#分布式-微服务" class="headerlink" title="分布式/微服务"></a>分布式/微服务</h4><h5 id="rpc通信"><a href="#rpc通信" class="headerlink" title="rpc通信"></a>rpc通信</h5><ul><li>spring cloud (java) </li><li>yar (php)</li><li>dubbo (java)</li></ul><h4 id="虚拟化-容器化技术"><a href="#虚拟化-容器化技术" class="headerlink" title="虚拟化/容器化技术"></a>虚拟化/容器化技术</h4><ul><li>Docker 容器化</li><li>k8s</li></ul><hr><h2 id="源码-性能"><a href="#源码-性能" class="headerlink" title="源码/性能"></a>源码/性能</h2><ul><li>JDK 源码 部分设计思想</li><li>Spring 源码</li><li>JVM 细节与排错</li><li>高并发/ 高可用</li></ul>]]></content>
    
    
    <categories>
      
      <category>learing route</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第七章</title>
    <link href="/2019/07/24/Thinking-in-Java-%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
    <url>/2019/07/24/Thinking-in-Java-%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章 复用类"></a>第七章 复用类</h1><h2 id="7-1-组合语法"><a href="#7-1-组合语法" class="headerlink" title="7.1 组合语法"></a>7.1 组合语法</h2><p>当实例对象是一个对象的引用时，编译器则为其初始化为null，这样在使用这个对象时，就会发生错误。因此我们需要如下几个方法，初始化组合中的引用：</p><ol><li><p>在定义对象的地方，也就是对象引用建立的时候直接指定对象，这意味着对象的初始化发生在构造器调用之前。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Construct</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> cont = <span class="hljs-string">"Hello World"</span>;&#125;</code></pre></div></li><li><p>在类的构造器中，如第5章所述，我们可以通过构造器的形式，也就是new，初始化一个对象。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.practice;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Construct</span></span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> cont;Construct(<span class="hljs-keyword">String</span> cont)&#123;<span class="hljs-built_in">this</span>.cont = cont;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructTest</span> </span>&#123;Construct construct = <span class="hljs-keyword">new</span> <span class="hljs-type">Construct</span>(<span class="hljs-string">"Hello"</span>);&#125;</code></pre></div></li><li><p>就在这样使用这些对象之前，也就是惰性初始化，当我们必须要使用这个对象的时候，发现没有初始化该对象呢，那么进行初始化，这种方式可以提供系统性能，降低资源消耗，在必须用到的时候才创建。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructTest</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> s;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<span class="hljs-keyword">if</span>(s==<span class="hljs-literal">null</span>)&#123;s=<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">"Hello"</span>);&#125;&#125;&#125;</code></pre></div></li><li><p>使用实例初始化，这种与构造器的相同之处都是在代码中显式的去创建一个对象，区别在于一个调用了构造器方法，一个赋值了一个实例。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConstructTest</span> &#123;</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String s;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;s=<span class="hljs-string">"Hello"</span>;&#125;&#125;</code></pre></div></li></ol><h2 id="7-2-继承语法"><a href="#7-2-继承语法" class="headerlink" title="7.2 继承语法"></a>7.2 继承语法</h2><p>另一种复用类的手段就是继承，我们创建一个新的类，如果没有显示的指明继承哪个类，那么它默认继承自Object类，我们也可以通过extends关键字继承一个指定的类。继承表现的是一种is-a的关系或者说是like-a，被继承的类称作父类或者基类，继承之后新生成的类称为子类或者派生类。子类拥有父类中所有被public或protected域修饰的方法、属性。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.practice;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-keyword">public</span> String Name;<span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> age;<span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> money;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPrint</span><span class="hljs-params">()</span></span>&#123;System.out.println(<span class="hljs-string">"Hello World"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Son son = <span class="hljs-keyword">new</span> Son();son.Name = <span class="hljs-string">"Zhang San"</span>;son.doPrint();<span class="hljs-comment">//money是父类私有的域，所以子类不能进行访问</span><span class="hljs-comment">//son.money = 2014;</span>&#125;&#125;</code></pre></div><h2 id="7-3-代理"><a href="#7-3-代理" class="headerlink" title="7.3 代理"></a>7.3 代理</h2><p>在使用组合的过程中，不提供成员对象的直接访问，而是通过一个新的方法暴露出来给其它使用者调用。避免直接暴露组合的对象。</p><div class="hljs"><pre><code class="hljs undefined">package com.chenxyt.java.practice;<span class="hljs-keyword">class</span> <span class="hljs-title">Construct</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"print"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"say"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"clean"</span>);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Son</span>&#123;<span class="hljs-keyword">public</span> Construct construct = <span class="hljs-keyword">new</span> Construct();<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delegation</span>(<span class="hljs-params"></span>)</span>&#123;construct.clean();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Son son = <span class="hljs-keyword">new</span> Son();son.delegation();&#125;&#125;</code></pre></div><h2 id="7-4-结合使用组合和继承"><a href="#7-4-结合使用组合和继承" class="headerlink" title="7.4 结合使用组合和继承"></a>7.4 结合使用组合和继承</h2><p>代码说明：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.practice;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mother</span></span>&#123;<span class="hljs-comment">//---</span>&#125;public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;public <span class="hljs-type">Mother</span> mother = <span class="hljs-keyword">new</span> <span class="hljs-type">Mother</span>();public static void main(<span class="hljs-type">String</span>[] args) &#123;<span class="hljs-comment">//---</span>&#125;&#125;</code></pre></div><p>一个继承父类的子类中引用一个其它的类实例对象。<br><strong>子类可以继承父类的全部，所以对于父类重载了的方法，子类也是可以继承并可以重载使用。</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.practice;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFunc</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//---</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFunc</span><span class="hljs-params">(String s)</span></span>&#123;<span class="hljs-comment">//--</span>&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFunc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<span class="hljs-comment">//--</span>&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Son son = <span class="hljs-keyword">new</span> Son();son.doFunc();son.doFunc(<span class="hljs-string">"H"</span>);son.doFunc(<span class="hljs-number">1</span>);&#125;&#125;</code></pre></div><h2 id="7-5-在组合和继承之间选择"><a href="#7-5-在组合和继承之间选择" class="headerlink" title="7.5 在组合和继承之间选择"></a>7.5 在组合和继承之间选择</h2><p>组合和继承都允许在新类中放置子对象，组合是显式的，而继承是隐式的。一般情况下，使用组合的地方多出是想使用其对象，就是在新类内部引用一个对象，然后利用这个对象完成一系列功能。而继承的使用场景主要是新类想使用原来类的一部分接口这种。在使用组合和继承的时候，要注意访问权限控制。</p><h2 id="7-6-protected关键字"><a href="#7-6-protected关键字" class="headerlink" title="7.6 protected关键字"></a>7.6 protected关键字</h2><p> 主要是为了控制继承类的访问权限。父类方法或变量被子类使用的这种。</p><h2 id="7-7-向上转型"><a href="#7-7-向上转型" class="headerlink" title="7.7 向上转型"></a>7.7 向上转型</h2><p>编译器会知道子类传递的参数引用属于父类哪一种类型，并将其子类对象引用的类型转换成父类，这个过程称作向上引用。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">package</span> com.chenxyt.java.practice;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> s;Father(<span class="hljs-keyword">String</span> s)&#123;<span class="hljs-built_in">this</span>.s = s;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void doFunc(Father father)&#123;System.out.println(s);&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">Father</span></span></span>&#123;Son(<span class="hljs-keyword">String</span> s) &#123;<span class="hljs-keyword">super</span>(s);<span class="hljs-comment">// TODO Auto-generated constructor stub</span>&#125; <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;Son son = <span class="hljs-keyword">new</span> <span class="hljs-type">Son</span>(<span class="hljs-string">"Hello"</span>);Father.doFunc(son);&#125;&#125;</code></pre></div><p>解析：父类中有一个static的方法，并且方法的参数是父类的对象，在子类中直接通过类名.方法的形式调用了该方法，并传递了子类的对象引用作为参数。编译器没有报错。</p><h2 id="7-8-final关键字"><a href="#7-8-final关键字" class="headerlink" title="7.8 final关键字"></a>7.8 final关键字</h2><ol><li><p>final 数据 ：一个固定的常量，或者一个在运行时候被初始化的值而我们却不希望它被改变，那么就可以使用final来修饰。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FinalTest</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final String ARG_NAME = <span class="hljs-string">"Hello World"</span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(ARG_NAME);&#125;&#125;</code></pre></div></li><li><p>final参数：Java中允许方法使用final修饰的参数，这意味着这个参数指向的对象不可以被修改.</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Gzino</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFunc</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-comment">//--</span>&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalTest</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">with</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Gzino g)</span></span>&#123;<span class="hljs-comment">//error! 此处不可以修改该对象的引用</span><span class="hljs-comment">//g = new Gzino();</span><span class="hljs-comment">//可以使用该参数</span>g.doFunc();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">without</span><span class="hljs-params">(Gzino g)</span></span>&#123;<span class="hljs-comment">//没有被final修饰，可以使用</span>g = <span class="hljs-keyword">new</span> Gzino();g.doFunc();&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;FinalTest ft = <span class="hljs-keyword">new</span> FinalTest();ft.with(<span class="hljs-keyword">new</span> Gzino());ft.without(<span class="hljs-keyword">new</span> Gzino());&#125;&#125;</code></pre></div></li><li><p>final方法：类中所有的private域都被隐式的注为private，因为不允许其它人修改。还有一种是final类，被final类修饰的方法我们认为这个类不能被其它人修改，也不能被继承，当你想达到这样的目的时，可以使用final类。</p></li></ol><h2 id="7-9-初始化及类的加载"><a href="#7-9-初始化及类的加载" class="headerlink" title="7.9 初始化及类的加载"></a>7.9 初始化及类的加载</h2><p>在许多语言中，程序在启动的过程中发生了加载，然后是初始化，最后是程序运行。但Java采用不同的加载机制， 每个类的编译文件都在它自己的代码文件中，该文件只有在用到该程序的时候才被加载。所以一般可以说“类的代码在初次使用时才发生加载“，这通常是指加载发生在创建第一个类对象时，但是当static域被访问时，也会发生加载。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Insect</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">9</span>;<span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> j;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Insect</span>(<span class="hljs-params"></span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"i="</span> + i + <span class="hljs-string">"--j="</span> + j);j=<span class="hljs-number">39</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x1 = printInit(<span class="hljs-string">"static Insect.x1 initialized"</span>);<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">printInit</span>(<span class="hljs-params">String s</span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(s);<span class="hljs-keyword">return</span> <span class="hljs-number">53</span>;&#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LoadTest</span> <span class="hljs-title">extends</span> <span class="hljs-title">Insect</span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> k = printInit(<span class="hljs-string">"LoadTest.k initialized"</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadTest</span>(<span class="hljs-params"></span>)</span>&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"k= "</span> + k);System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"j= "</span> + j);&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x2 = printInit(<span class="hljs-string">"static LoadTest.x2 initialized"</span>);<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"LoadTest constructor"</span>);LoadTest lt = <span class="hljs-keyword">new</span> LoadTest();&#125;&#125;<span class="hljs-comment">// output</span><span class="hljs-keyword">static</span> Insect.x1 initialized<span class="hljs-keyword">static</span> LoadTest.x2 initializedLoadTest constructori=<span class="hljs-number">9</span>--j=<span class="hljs-number">0</span>LoadTest.k initializedk= <span class="hljs-number">53</span>j= <span class="hljs-number">39</span></code></pre></div><p>解析：程序在启动的时候先查找main函数，main函数都是程序的入口，发现main方法里面有LoadTest类，这时开始加载LoadTest类，在加载的过程中，发现这个类有基类，于是他继续加载基类，如果还有基类那么继续加载另一个基类，因为子类中可能会用到基类的内容。然后基类中的static域初始化，这时第一行打印。然后子类中的static域初始化，这时第二行执行。这时必要的类资源已经加载完毕，可以进行对象创建，第三行打印。初始化对象，首先对象中的所有基本类型被赋初始值0，对象被赋值为null，这是通过将对象内存设置为二进制零实现的。然后基类的构造函数被调用，这里是自动调用的，也可以通过super方法直接调用，这时第四行被打印。基类构造器和子类构造器执行相同的方式经过相同的过程。基类构造器执行完毕之后，实例变量按顺序被创建，最后执行子类的构造方法，所以最后两行被打印。</p><h2 id="7-10-总结"><a href="#7-10-总结" class="headerlink" title="7.10 总结"></a>7.10 总结</h2><p> 讲解就看小节就okay了。 这里说下注意点：<br> 组合一般是将现有类型做为新类型底层实现的一部分加以复用。<br> 继承复用的是接口。<br><br> 导出类举有基类接口，由此可以向上转型。这对多态来说很关键。<br><br> 理解final。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo 搭建注意事项</title>
    <link href="/2019/07/23/hexo-%E6%90%AD%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2019/07/23/hexo-%E6%90%AD%E5%BB%BA%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo-搭建注意事项"><a href="#hexo-搭建注意事项" class="headerlink" title="hexo 搭建注意事项"></a>hexo 搭建注意事项</h1><ol><li>建议直接看 hexo 官方文档  不然搜到很多简写的不清晰的很容易入坑。</li><li>官方文档 <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a></li><li>部署到 github 上 直接 使用 hexo d 不要把全部源码 push 上去。github个人博客会检查很多未知语法<br></li><li>源码可以新起一个分支 push 上去。切记不要混到 master 主分支 影响博客访问。</li><li>github 绑定 域名不需要备案只需要 域名实名制 保证解析就OK了。</li></ol>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第六章</title>
    <link href="/2019/07/23/Thinking-in-Java-%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
    <url>/2019/07/23/Thinking-in-Java-%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="由于此书讲的太细，一小节都总结太细-太影响效率，故从此章节改为大体总结，不扣细节。"><a href="#由于此书讲的太细，一小节都总结太细-太影响效率，故从此章节改为大体总结，不扣细节。" class="headerlink" title="由于此书讲的太细，一小节都总结太细 太影响效率，故从此章节改为大体总结，不扣细节。"></a><strong>由于此书讲的太细，一小节都总结太细 太影响效率，故从此章节改为大体总结，不扣细节。</strong></h3><h1 id="第六章-访问权限控制"><a href="#第六章-访问权限控制" class="headerlink" title="第六章 访问权限控制"></a>第六章 访问权限控制</h1><p>为了让自己的程序变得更加易用、可读和完善的。在重构修改的过程中，避免他们对自己类库内部的程序进行改动。Java中提供了访问权限控制的概念，提供了三种不同级别的访问控制，访问开放程度由高到低依次为“public”、“protected”“private”，这样就能区分哪些内容是可用的，哪些内容是不可用的，从而将变动的事物与不变的事物区分开来。此外，Java提供了package加以控制，而访问权限控制的作用会因为类库是否在一个相同的package还是不同的package受到影响。</p><h2 id="6-1-包-库-单元"><a href="#6-1-包-库-单元" class="headerlink" title="6.1 包: 库 单元"></a>6.1 包: 库 单元</h2><h4 id="6-1-1-～-6-1-5"><a href="#6-1-1-～-6-1-5" class="headerlink" title="6.1.1  ～ 6.1.5"></a>6.1.1  ～ 6.1.5</h4><p> 包内包含一组类，它们在单一的名字空间下被组织在了一起。声明一个类所属的包使用package关键字，同时在另一个包中的类要访问其它包中的类使用import关键字导入要使用的包。这种方式可以在一定程度上避免重名的问题，因为包的名字要避免重名，而不同包内的类是可以根据具体的需求命相同的名字。包有效的将不同类的内容进行了隔离，同时也可以相互联系。</p><div class="hljs"><pre><code class="hljs undefined">* <span class="hljs-comment">// access/mypackage/MyPackagedClass.java</span>** package access.mypackage;** <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyPackagedClass</span> &#123;*<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyPackagedClass</span>(<span class="hljs-params"></span>)</span> &#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"MyPackagedClass()"</span>);&#125;* &#125;*/<span class="hljs-comment">// 以上是 新建package 里java</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">UnpackagedMyClass</span> &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;access.mypackage.MyPackagedClass m = <span class="hljs-keyword">new</span> access.mypackage.MyPackagedClass();&#125;&#125;</code></pre></div><h2 id="6-2-Java-访问权限修饰词"><a href="#6-2-Java-访问权限修饰词" class="headerlink" title="6.2 Java 访问权限修饰词"></a>6.2 Java 访问权限修饰词</h2><ol><li><p>public：所有可见，被public修饰的内容在同一个包中的所有类都可见。同时Java提供默认的访问权限，即不被任何修饰符修饰的内容默认为public权限。</p></li><li><p>private：私有可见，只有该类可见，该类的对象都不可见。如果一个类的构造函数被声明为private，那么就不能通过这个类的构造函数来进行初始化对象。</p></li><li><p>protected:受保护的可见，与private不同，除了只有自己的类可见之外，该类的继承者也可见被修饰的域。<strong>除此之外还可以被当前包的类访问，但是其它包的类不可以访问，即便是使用了import的关键字</strong></p></li></ol><p>访问权限控制对程序结构控制的重要手段。</p><h2 id="6-3-接口和实现"><a href="#6-3-接口和实现" class="headerlink" title="6.3 接口和实现"></a>6.3 接口和实现</h2><p>为了方便他人使用，会在具体方法实现外部建立一层接口，只提供接口给外部开发人员调用，而不提供具体实现的方法。</p><h2 id="6-4-类的访问权限"><a href="#6-4-类的访问权限" class="headerlink" title="6.4 类的访问权限"></a>6.4 类的访问权限</h2><p>在Java中，访问权限控制也可以确定包中的哪些类可以被访问，也就是说可以用来修饰类，一个文件中最多只能有一个使用public修饰的类。如果希望客户端程序员使用该类，并可以创建对象，那么就可以将该类修饰为public。并且被修饰为public的类必须要与该文件的名字完全相同</p><h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>讲述了public、private和protected 三种类型的概念和应用场景。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第五章</title>
    <link href="/2019/07/21/Thinking-in-Java-%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
    <url>/2019/07/21/Thinking-in-Java-%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-初始化与清理"><a href="#第五章-初始化与清理" class="headerlink" title="第五章 初始化与清理"></a>第五章 初始化与清理</h1><p>C 语言中 很多开发者 会忘记清理使用过的变量 导致内存耗尽。<br><br>C++ 引入构造器 即 创建对象时被自动调用的方法。<br><br>Java 中也采用了构造器，并额外提供了“垃圾回收器”。</p><h2 id="5-1用构造器确保初始化"><a href="#5-1用构造器确保初始化" class="headerlink" title="5.1用构造器确保初始化"></a>5.1用构造器确保初始化</h2><p> Java中通过提供构造器，保证每个类的对象都进行了初始化。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Rock</span>&#123;Rock()&#123;System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Rock"</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<span class="hljs-keyword">new</span> Rock();&#125;&#125;&#125;<span class="hljs-comment">// output</span> Rock Rock Rock Rock Rock</code></pre></div><h2 id="5-2-方法重载"><a href="#5-2-方法重载" class="headerlink" title="5.2 方法重载"></a>5.2 方法重载</h2><p>对于这种方法名相同，方法参数不同的写法，称作是重载。方法重载不仅支持构造器重载，也支持普通方法重载</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> class test&#123;    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> age;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> name;    test()&#123;    &#125;    test(<span class="hljs-built_in">int</span> i)&#123;        age=i;    &#125;    test(<span class="hljs-keyword">String</span> j)&#123;        name=j;    &#125;    test(<span class="hljs-built_in">int</span> i,<span class="hljs-keyword">String</span> j)&#123;        age=i;        name=j;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;        test ct1 = <span class="hljs-keyword">new</span> test();        test ct2 = <span class="hljs-keyword">new</span> test(<span class="hljs-number">22</span>);        test ct3 = <span class="hljs-keyword">new</span> test(<span class="hljs-string">"张三"</span>);        test ct4 = <span class="hljs-keyword">new</span> test(<span class="hljs-number">23</span>,<span class="hljs-string">"李四"</span>);        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ct1 age="</span> + ct1.age + <span class="hljs-string">"---name="</span> + ct1.name);        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ct2 age="</span> + ct2.age + <span class="hljs-string">"---name="</span> + ct2.name);        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ct3 age="</span> + ct3.age + <span class="hljs-string">"---name="</span> + ct3.name);        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"ct4 age="</span> + ct4.age + <span class="hljs-string">"---name="</span> + ct4.name);    &#125;&#125;<span class="hljs-comment">// output </span>ct1 age=<span class="hljs-number">0</span>---name=<span class="hljs-keyword">null</span>ct2 age=<span class="hljs-number">22</span>---name=<span class="hljs-keyword">null</span>ct3 age=<span class="hljs-number">0</span>---name=张三ct4 age=<span class="hljs-number">23</span>---name=李四</code></pre></div><h4 id="5-2-1-区分重载方法"><a href="#5-2-1-区分重载方法" class="headerlink" title="5.2.1 区分重载方法"></a>5.2.1 区分重载方法</h4><p>独一无二的参数类型列表，(顺序不同也可以区分不同的方法)</p><h4 id="5-2-2-涉及基本类型的重载"><a href="#5-2-2-涉及基本类型的重载" class="headerlink" title="5.2.2 涉及基本类型的重载"></a>5.2.2 涉及基本类型的重载</h4><p>重载方法中如果传入了低类型的参数，那么如果找不到合适的方法，会被隐式的提升成高类型的数据。如果传入了高类型的参数，如果不进行类型转换，那么编译器会报错。<strong>如果无法找到恰好接受char参数的方法，就会把char直接提升至int。</strong></p><h4 id="5-2-3-以返回值区分重载方法"><a href="#5-2-3-以返回值区分重载方法" class="headerlink" title="5.2.3 以返回值区分重载方法"></a>5.2.3 以返回值区分重载方法</h4><p>可以使用返回值区分，当然前提是如果你关心方法的返回值。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;</code></pre></div><h2 id="5-3-默认构造器"><a href="#5-3-默认构造器" class="headerlink" title="5.3 默认构造器"></a>5.3 默认构造器</h2><p>又名“无参”构造器 作用是创建默认对象。 如果你没有显示的在代码中创建一个构造器，那么Java会自动帮你创建一个无参构造器来完成初始化。 理解：<strong>创建对象必须要构造器，要不Java也不回费劲帮你创建默认构造器</strong></p><h2 id="5-4-this-关键字"><a href="#5-4-this-关键字" class="headerlink" title="5.4 this 关键字"></a>5.4 this 关键字</h2><p>表示当前对象的引用，并返回当前对象</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Leaf</span>&#123;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<span class="hljs-function">Leaf <span class="hljs-title">increment</span>(<span class="hljs-params"></span>)</span>&#123;        i++;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span>(<span class="hljs-params"></span>)</span>&#123;        System.<span class="hljs-keyword">out</span>.printLn(<span class="hljs-string">"i = "</span> +i);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Leaf x = <span class="hljs-keyword">new</span> Leaf();        x.increment().increment().increment().print();&#125;&#125;<span class="hljs-comment">// output i = 3</span></code></pre></div><p>解析：increment() 通过this 返回对当前对象的引用。<br><br><strong>必要时候在使用this，我们使用高级语言的原因就是希望他们来帮我么简化一些事情。从而节省时间</strong></p><h4 id="5-4-1-在构造器中调用构造器"><a href="#5-4-1-在构造器中调用构造器" class="headerlink" title="5.4.1 在构造器中调用构造器"></a>5.4.1 在构造器中调用构造器</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">public</span> class test&#123;    test(<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">String</span> j)&#123;        <span class="hljs-keyword">this</span>(j);<span class="hljs-comment">//!        this(j,i);</span>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"我是构造器1"</span>);    &#125;    test(<span class="hljs-keyword">String</span> arg)&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"我是构造器2"</span>);    &#125;    test(<span class="hljs-keyword">String</span> arg, <span class="hljs-keyword">int</span> x)&#123;        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"我是构造器3"</span>);    &#125;    testMothod(<span class="hljs-keyword">String</span> arg, <span class="hljs-keyword">int</span> x)&#123;        <span class="hljs-comment">//！ this(11);</span>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"我是方法不能调用构造器"</span>);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;        test tt = <span class="hljs-keyword">new</span> test(<span class="hljs-number">2</span>,<span class="hljs-string">"嘻嘻"</span>);    &#125;</code></pre></div><p>以上代码说明 构造器可以仅用this调用另一个构造器，不能调用二个。并且 方法内不能调用构造器。<br>“//！“ 代表编译错误。</p><h4 id="5-4-2-static的含义"><a href="#5-4-2-static的含义" class="headerlink" title="5.4.2 static的含义"></a>5.4.2 static的含义</h4><p>static 内部不能使用 this 反之可以。<br><br><strong>代码出现大量static，该重新考虑自己设计了</strong></p><h2 id="5-5-清理：终结处理和垃圾回收"><a href="#5-5-清理：终结处理和垃圾回收" class="headerlink" title="5.5 清理：终结处理和垃圾回收"></a>5.5 清理：终结处理和垃圾回收</h2><p>Java中的内存清理使用的是Java自带的垃圾回收机制，Java的垃圾回收机制清理的是通过new创建的对象，而在某些特殊情况下，可能有些对象不是通过new创建的，这些对象如果不使用的时候，垃圾回收器是不能准确的清理他们的从而造成了这块特殊的内存区域一直得不到释放。Java中提供了finalize()方法来处理这一部分特殊的内存区域。<br><br>垃圾回收只能回收 new 出来的对象<br><strong>1. 对象可能不被垃圾回收</strong><br><strong>2. 垃圾回收并不等于“析构”</strong><br></p><p>流程是 ：在Java垃圾回收器启用之前，会先调用这个方法进行一些必要的回收操作。但是针对这一块特殊的区域，或者是new创建的需要被回收的对象，一般情况下只有当Java虚拟机内存快要消耗殆尽的时候，垃圾回收器才会启动，毕竟启动垃圾回收器也是需要消耗资源的，所以不可能说实时存在。</p><h4 id="5-5-1-finalize-用途何在"><a href="#5-5-1-finalize-用途何在" class="headerlink" title="5.5.1 finalize() 用途何在"></a>5.5.1 finalize() 用途何在</h4><p><strong>3. 垃圾回收只和内存相关</strong></p><div class="hljs"><pre><code class="hljs undefined">finalize()方法的通用格式如下：<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">( )</span></span>&#123;<span class="hljs-comment">// finalization code here</span>&#125;</code></pre></div><p>Java 中 只有不是new 出来的对象 才用finalize()清除，由于Java 一切皆为对象，所以这种特殊情况可能采用了类C语言的做法，而非Java 通用代码。这种方法主要发生在“本地方法”中，一种Java调用非Java代码。<br><br>所以不要过多用到finalize()，它不适合进行普通清理工作。</p><h4 id="5-5-2-你必须实施清理"><a href="#5-5-2-你必须实施清理" class="headerlink" title="5.5.2 你必须实施清理"></a>5.5.2 你必须实施清理</h4><p>所以 将 Java 规范化 调用恰当的Java 方法 就不会用到 finalize()。</p><h4 id="5-5-3-终结条件"><a href="#5-5-3-终结条件" class="headerlink" title="5.5.3 终结条件"></a>5.5.3 终结条件</h4><p>调用 system.runFinalization() 会强制调用已经失去引用的对象的finalize方法 。</p><h4 id="5-54-垃圾回收器如何工作"><a href="#5-54-垃圾回收器如何工作" class="headerlink" title="5.54 垃圾回收器如何工作"></a>5.54 垃圾回收器如何工作</h4><p>写的比较长 总结一下：<br></p><ol><li>垃圾回收发生在Java虚拟机中。</li><li>引用计数是一种简单但速度很慢的回收技术。详解：引用技术是当对象被引用时候计数+1，当引用离开作用域-1，发现引用计数为0 释放占用空间。缺点就是两个对象循环调用时候，引用计数却不为0。<br>定位这类型的交互引用的对象需要的工作量极大。</li><li>Java垃圾回收并非基于引用计数技术。采用了一种自适应的垃圾回收技术。做法为”停止-复制”，但是这种有弊端 。具体google。<br>所以当没有新垃圾产生 会切换到“标记-清扫”。具体 google。</li><li>JIT编译技术 用以提升速度。它可以把程序的全部或部分翻译成本地机器码。（这本来是Java虚拟机要做的事情。）运行速度加以提升。</li><li>惰性评估 执行多的代码才会被JIT编译。这也是代码每次执行的优化。 所以执行越多 速度越快。</li></ol><h2 id="5-6-成员初始化"><a href="#5-6-成员初始化" class="headerlink" title="5.6 成员初始化"></a>5.6 成员初始化</h2><p>Java尽量保证每个变量在使用之前都进行了初始化操作，变量分为局部变量和成员变量，局部变量如果没有显示的初始化，在使用它的时候会报错，而成员变量不会，如果没有显示的初始化一个成员变量，那么它会被默认的分配一个指定的值。</p><h4 id="5-6-1-指定的初始化"><a href="#5-6-1-指定的初始化" class="headerlink" title="5.6.1 指定的初始化"></a>5.6.1 指定的初始化</h4><p>定义变量时候赋值，但在C++ 里不能这样做。</p><h2 id="5-7-构造器初始化"><a href="#5-7-构造器初始化" class="headerlink" title="5.7 构造器初始化"></a>5.7 构造器初始化</h2><p>构造器无法阻止自动初始化。它在构造器被调用之前发生。</p><h4 id="5-7-1-初始化顺序"><a href="#5-7-1-初始化顺序" class="headerlink" title="5.7.1 初始化顺序"></a>5.7.1 初始化顺序</h4><p>在类内部，即使变量定义散布在方法定义之间，它仍然会在任何方法（包括构造器）被调用之前得到初始化。<strong>初始化顺序为创建对象时，先初始化这个类的静态变量，然后在堆上为这个对象分配内存，最后执行构造函数。</strong></p><h4 id="5-7-2-静态数据的初始化"><a href="#5-7-2-静态数据的初始化" class="headerlink" title="5.7.2 静态数据的初始化"></a>5.7.2 静态数据的初始化</h4><p>如前边对构造器的阐述，可以使用构造器来初始化类的成员变量，当对象被实例化之后，对象的成员变量会被初始化。<strong>静态成员变量只有在第一次使用它是才会被初始化，后边再次用到时不会被初始化。</strong></p><h4 id="5-7-3-显示的静态初始化"><a href="#5-7-3-显示的静态初始化" class="headerlink" title="5.7.3 显示的静态初始化"></a>5.7.3 显示的静态初始化</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Cup</span> &#123;    Cup(<span class="hljs-keyword">int</span> marker) &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Cup("</span> + marker + <span class="hljs-string">")"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> marker</span>)</span> &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"f("</span> + marker + <span class="hljs-string">")"</span>);    &#125;&#125;<span class="hljs-keyword">class</span> <span class="hljs-title">Cups</span> &#123;    <span class="hljs-keyword">static</span> Cup cup1;    <span class="hljs-keyword">static</span> Cup cup2;    <span class="hljs-keyword">static</span> &#123;        cup1 = <span class="hljs-keyword">new</span> Cup(<span class="hljs-number">1</span>);        cup2 = <span class="hljs-keyword">new</span> Cup(<span class="hljs-number">2</span>);    &#125;    Cups() &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Cups()"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Inside main()"</span>);<span class="hljs-comment">//        Cups.cup1.f(99); // (1)</span>    &#125;    <span class="hljs-keyword">static</span> Cups cups1 = <span class="hljs-keyword">new</span> Cups(); <span class="hljs-comment">// (2)</span>    <span class="hljs-keyword">static</span> Cups cups2 = <span class="hljs-keyword">new</span> Cups(); <span class="hljs-comment">// (2)</span>&#125;</code></pre></div><p>上面这段代码很好的解释了 静态初始化。无论创建几个对象，静态初始化都只会进行一次。</p><h4 id="5-7-4-非静态实例初始化"><a href="#5-7-4-非静态实例初始化" class="headerlink" title="5.7.4 非静态实例初始化"></a>5.7.4 非静态实例初始化</h4><p>与 static 一样 初始化是在构造之前完成的。不同的是 多次调用 多次执行。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Tester</span> &#123;    String s;    &#123;        s = <span class="hljs-string">"Initializing string in Tester"</span>;        System.<span class="hljs-keyword">out</span>.println(s);    &#125;    Tester() &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Tester()"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        <span class="hljs-keyword">new</span> Tester();        <span class="hljs-keyword">new</span> Tester();    &#125;&#125;<span class="hljs-comment">// output </span><span class="hljs-function">Initializing <span class="hljs-keyword">string</span> <span class="hljs-keyword">in</span> Tester<span class="hljs-title">Tester</span>(<span class="hljs-params"></span>)Initializing <span class="hljs-keyword">string</span> <span class="hljs-keyword">in</span> Tester<span class="hljs-title">Tester</span>(<span class="hljs-params"></span>)</span></code></pre></div><h2 id="5-8-数组初始化"><a href="#5-8-数组初始化" class="headerlink" title="5.8 数组初始化"></a>5.8 数组初始化</h2><p>数据是一系列相同数据类型封装起来的序列，它的初始化可以发生在任何时候，int[] a1表示一个int类型的数组，这个数组内部所有的值都是int类型，a1只是这个数组的一个引用，可以显示的通过如int[] a1={1，2，3};的形式进行初始化。<strong>如果不能确定数组的内容或者是长度，则可以通过new的形式来创建一个数组。</strong>int[] a = new int[20];这种创建也只是创建了一个引用数组，直到数组中的每一个字段都有确切的值了，初始化才真正的完成。如a[1]=3;</p><h4 id="5-8-1-可变参数列表"><a href="#5-8-1-可变参数列表" class="headerlink" title="5.8.1 可变参数列表"></a>5.8.1 可变参数列表</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; 使用数组我们可以构建一个变参的函数，就是当方法的参数类型和个数都不确定的时候，我们可以使用一个数组作为形参。因为Object类是所有类型的父类，所以这个形参数组的类型就是Obejct类，对于基本数据类型，因为都有对应的包装类，所以也可以转换成Obejct类进行使用。<br>JDK1.5之后真正的变参函数 Object…args</p><h2 id="5-9-枚举类型"><a href="#5-9-枚举类型" class="headerlink" title="5.9 枚举类型"></a>5.9 枚举类型</h2><p>这里只是初步的了解一下枚举类型，enum，Java中的enum要比C++更加完备。</p><div class="hljs"><pre><code class="hljs undefined">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnumEx21</span> &#123;</span>public <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Bills</span> &#123;</span>ONE, FIVE, TEN, TWENTY, FIFTY, HUNDRED&#125;public static void main(String[] args) &#123;<span class="hljs-keyword">for</span>(Bills b : Bills.values())System.<span class="hljs-keyword">out</span>.println(b + <span class="hljs-string">", ordinal "</span> + b.ordinal());&#125;&#125;</code></pre></div><p>枚举还可以当构造函数使用，非常方便。</p><p>这里理解枚举暂时可以当常量集理解 具体19章会详解。</p><h2 id="5-10-总结"><a href="#5-10-总结" class="headerlink" title="5.10 总结"></a>5.10 总结</h2><p>Java 初始化 有至关重要的地位。构造器能够保证正确初始化和清理。（没有正确的构造器调用，编译器就不允许创建对象）<br></p><p>C++ 中 析构很重要。 Java就不太需要。垃圾回收可以简化编程，处理上也安全。<br></p><p>由于需要保证所有对象被创建，构造器实际上会更加复杂。尤其是组合或继承。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第四章</title>
    <link href="/2019/07/16/Thinking-in-Java-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
    <url>/2019/07/16/Thinking-in-Java-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第4章-控制执行流程"><a href="#第4章-控制执行流程" class="headerlink" title="第4章 控制执行流程"></a>第4章 控制执行流程</h1><p>if-else while do-while for return break</p><h2 id="4-1-ture-和-flase"><a href="#4-1-ture-和-flase" class="headerlink" title="4.1 ture 和 flase"></a>4.1 ture 和 flase</h2><p>关系操作符构造的条件语句如“==”的返回值是true和false，<strong>Java中不允许将一个数字作为布尔值使用。</strong></p><h2 id="4-2-if-else"><a href="#4-2-if-else" class="headerlink" title="4.2 if-else"></a>4.2 if-else</h2><p>if else语句与其它语言的相同，其中else是可选的。</p><h2 id="4-3-迭代"><a href="#4-3-迭代" class="headerlink" title="4.3 迭代"></a>4.3 迭代</h2><p> while、do-while、for用来控制循环，有时候将他们称为迭代语句。语句会重复执行，直到起控制作用的布尔值得到“假”的结果时停止。</p><h4 id="4-3-1-do-while"><a href="#4-3-1-do-while" class="headerlink" title="4.3.1 do-while"></a>4.3.1 do-while</h4><p>do-while 至少会执行一次。while 更常用一些。</p><h4 id="4-3-2-for"><a href="#4-3-2-for" class="headerlink" title="4.3.2 for"></a>4.3.2 for</h4><p>最常用的 迭代形式。适合计数。（练习4 最棒）</p><h4 id="4-3-3-逗号操作符"><a href="#4-3-3-逗号操作符" class="headerlink" title="4.3.3 逗号操作符"></a>4.3.3 逗号操作符</h4><p>可以在 for 语句定义多个变量。其他迭代不适用。无论是初始化 还是步进部分 语句都是顺序执行。</p><h2 id="4-4-foreach"><a href="#4-4-foreach" class="headerlink" title="4.4 foreach"></a>4.4 foreach</h2><p>更加简洁的for语法 用于数组和容器。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">// f是要被访问的循环体 i是一个变量</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x:f)&#123;    System.<span class="hljs-keyword">out</span>.pringln(x);&#125;</code></pre></div><p>顺带讲解了一下<strong>重载：相同方法可以具有不同参数</strong> 。<br><br>range() 配上 foreach 效率低 可读性高。<br><br>printnb（）方法不会换行。<br><br>foreach 更加易读。</p><h2 id="4-5-return"><a href="#4-5-return" class="headerlink" title="4.5 return"></a>4.5 return</h2><p> return关键字有两个用途，一方面指定一个void方法返回什么值，另一方面它会强制结束当前void方法，并返回那个值。</p><h2 id="4-6-break-和-continue"><a href="#4-6-break-和-continue" class="headerlink" title="4.6 break 和 continue"></a>4.6 break 和 continue</h2><p>break用于强制退出循环，不执行循环剩余的语句<br><br>continue是停止当前的迭代，退到循环开始执行下一次迭代</p><h2 id="4-7-臭名昭著的goto"><a href="#4-7-臭名昭著的goto" class="headerlink" title="4.7 臭名昭著的goto"></a>4.7 臭名昭著的goto</h2><p>goto 起源于汇编。Java编译器会生成自己的“汇编代码”，但是是运行在Java虚拟机上的。而不是直接运行在cpu硬件上。它是在源码级上的跳转。 导致可读性差，Java 没有goto。<br>Java 有 标签 可以 替换goto 使用。</p><h2 id="4-8-switch"><a href="#4-8-switch" class="headerlink" title="4.8 switch"></a>4.8 switch</h2><p>switch也被划为一种选择语句，根据整数表达式的值，从一系列语句中选择一组执行。</p><h2 id="4-9-总结"><a href="#4-9-总结" class="headerlink" title="4.9 总结"></a>4.9 总结</h2><p>介绍了大多数编程语言都具有基本特性：运算 操作符 优先级 类型转换以及选择和循环等等。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第三章</title>
    <link href="/2019/07/16/Thinking-in-Java-%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
    <url>/2019/07/16/Thinking-in-Java-%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-操作符"><a href="#第三章-操作符" class="headerlink" title="第三章 操作符"></a>第三章 操作符</h1><p>Java 操作符是建立在C++基础上的。</p><h2 id="3-1-更简单的打印语句"><a href="#3-1-更简单的打印语句" class="headerlink" title="3.1 更简单的打印语句"></a>3.1 更简单的打印语句</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">net</span><span class="hljs-selector-class">.mindview</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.Print</span>.*;</code></pre></div><p>导入jar包后 可以使用更简单的写法  printr() </p><h2 id="3-2-使用Java-操作符"><a href="#3-2-使用Java-操作符" class="headerlink" title="3.2 使用Java 操作符"></a>3.2 使用Java 操作符</h2><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-bullet">+ </span>- * / = == !=</code></pre></div><h2 id="3-3-优先级"><a href="#3-3-优先级" class="headerlink" title="3.3 优先级"></a>3.3 优先级</h2><p>先乘除后加减 括号内优先执行。<br>类型转换 操作符后面的按前面的转换。</p><h2 id="3-4-赋值"><a href="#3-4-赋值" class="headerlink" title="3.4 赋值"></a>3.4 赋值</h2><p>右值赋给左值，a=b 则 b 值复制一份给a。但是如果是将一个对象赋值给另一个对象 其实就是<strong>引用</strong>。<br>例如 d 是个对象 把 d 赋值给对象c 那么 c 和 d 都指向原来d 对象所在的内存地址 。 现在改变 c 同时也会 改变 d 对象 。<br>这种现象被称作 java <strong>别名现象</strong> 。</p><h4 id="3-4-1-方法中调用的别名问题"><a href="#3-4-1-方法中调用的别名问题" class="headerlink" title="3.4.1 方法中调用的别名问题"></a>3.4.1 方法中调用的别名问题</h4><p>方法调用 对象 改变其中的值</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">class</span> <span class="hljs-title">Letter</span> &#123;<span class="hljs-keyword">char</span> c;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PassObject</span> &#123;<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params">Letter y</span>)</span> &#123;y.c = <span class="hljs-string">'z'</span>;System.<span class="hljs-keyword">out</span>.println(y.c);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Letter x = <span class="hljs-keyword">new</span> Letter();x.c = <span class="hljs-string">'a'</span>;System.<span class="hljs-keyword">out</span>.println(x.c);f(x);System.<span class="hljs-keyword">out</span>.println(x.c);&#125;&#125;</code></pre></div><h2 id="3-5-算术操作符"><a href="#3-5-算术操作符" class="headerlink" title="3.5 算术操作符"></a>3.5 算术操作符</h2><p>简化运算符的功能如要将x加4之后再赋值给x，则可以写成：</p><div class="hljs"><pre><code class="hljs undefined">x+=4;</code></pre></div><h4 id="3-5-1-一元加减操作符"><a href="#3-5-1-一元加减操作符" class="headerlink" title="3.5.1 一元加减操作符"></a>3.5.1 一元加减操作符</h4><p>一元减号（-）和一元加号（+）与二元加号和减号都是相同的运算符。根据表达式的书写形式，编译器会自动判断使用哪一种。例如下述语句：</p><p>x = -a;<br>它的含义是显然的。编译器能正确识别下述语句：</p><p>x = a * -b;<br>但读者会被搞糊涂，所以最好更明确地写成：</p><p>x = a * (-b); 一元减号得到的运算对象的负值。一元加号的含义与一元减号相反，虽然它实际并不做任何事情。</p><h2 id="3-6-自动递增和递减"><a href="#3-6-自动递增和递减" class="headerlink" title="3.6 自动递增和递减"></a>3.6 自动递增和递减</h2><p>++a 会先执行运算，再生成值。<br>a++ 先生成值在运算。</p><h2 id="3-7-关系操作符"><a href="#3-7-关系操作符" class="headerlink" title="3.7 关系操作符"></a>3.7 关系操作符</h2><p>关系操作符生成的是一个boolean（布尔）结果。关系为真则结果为true，如果关系为假则结果为false。关系操作符号包括小于（＜）、大于（＞）、小于等于（＜=）、大于等于（＞＝）、等于（==）以及不等于（！=）。<br>操作符“==”和“！=”同样适用于操作对象，但是与基本操作类型相比有一些不同。<br><strong>bool类型不能比较大小，因为本身就是bool类型 比大小没意义</strong></p><div class="hljs"><pre><code class="hljs undefined">package com.chenxyt.java.practice;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OperationTest</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Integer itg1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">22</span>);Integer itg2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">22</span>);System.<span class="hljs-keyword">out</span>.println(itg1==itg2);System.<span class="hljs-keyword">out</span>.println(itg1!=itg2);<span class="hljs-keyword">int</span> int1 = <span class="hljs-number">22</span>;<span class="hljs-keyword">int</span> int2 = <span class="hljs-number">22</span>;System.<span class="hljs-keyword">out</span>.println(int1==int2);System.<span class="hljs-keyword">out</span>.println(int1!=int2);&#125;&#125;</code></pre></div><p>重点是，两个对象是“！=”，因为对于对象来说，“==”和“！=”比较的是对象的引用，虽然这两个对象的值相同，但是他们对象的引用并不是一个，也就是他们在内存中有两个不同的存储位置，所以不相同。所以要想比较对象的值是否相同，我们可以使用对象的equals（）方法来进行比较，它是Object类的一个通用方法，第一章中说到过所有类的父类都是Object，因此任何类的对象都可以调用这个方法。</p><div class="hljs"><pre><code class="hljs undefined">package com.chenxyt.java.practice;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">OperationTest</span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;Integer itg1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">22</span>);Integer itg2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">22</span>);System.<span class="hljs-keyword">out</span>.println(itg1.<span class="hljs-keyword">equals</span>(itg2));&#125;&#125;</code></pre></div><h2 id="3-8-逻辑操作符"><a href="#3-8-逻辑操作符" class="headerlink" title="3.8 逻辑操作符"></a>3.8 逻辑操作符</h2><p>Java中的逻辑操作符与其它语言基本类似，包括与（&amp;&amp;）、或（||）、非（！）</p><h4 id="3-8-1-短路"><a href="#3-8-1-短路" class="headerlink" title="3.8.1 短路"></a>3.8.1 短路</h4><p>即当两个算式做逻辑与运算时，如果左边第一个算式为假，则显然这个逻辑表达式最后的结果一定为假，那么就没有必要进行下边的表达式计算，直接结束运算，这个过程称作短路。</p><h2 id="3-9-直接常量"><a href="#3-9-直接常量" class="headerlink" title="3.9 直接常量"></a>3.9 直接常量</h2><p>直接常量 例如 π e   编译器可以准确知道要生成什么类型 但是有时候还是模糊， 需要加一些字符来添加额外信息 指导编译器。  例如 :</p><div class="hljs"><pre><code class="hljs undefined">char c = <span class="hljs-number">0</span>xffff<span class="hljs-comment">;</span>print(<span class="hljs-name">Interger</span>.toBinaryString(<span class="hljs-name">c</span>))<span class="hljs-comment">; //char 需要转换2进制</span></code></pre></div><p>常量后面可以标志类型。 L 代表 long F 代表 float D 代表 double 例如 int x = 1234567L;<br>16进制 前缀0X  8进制前缀0后续0～7的数字表示。</p><h4 id="3-9-1-指数记数法"><a href="#3-9-1-指数记数法" class="headerlink" title="3.9.1 指数记数法"></a>3.9.1 指数记数法</h4><p>Java 中 1.39e-43 其实 就是1.39*10-43</p><h2 id="3-10-按位操作符"><a href="#3-10-按位操作符" class="headerlink" title="3.10 按位操作符"></a>3.10 按位操作符</h2><p> Java中的按位操作符与其他语言基本相似，有按位与（&amp;）、按位或（|）、按位异或（^）和按位非（<del>）操作符。它们针对基本数据类型的一个比特位（bit）进行运算。运算规则如下，&amp;操作符必须同时为1才为1，|操作符只有同时为0时才为0，^操作符只要有一个为1就为1，</del>是单目运算符，取反，若值为1则结果为0，反之为1。按位操作符除了~还可以与“=”合起来使用，如&amp;=或者|=、^=。<br>对于布尔值，同样可以进行按位与、按位或和按位异或运算，但是不能进行按位非运算，并且他们不会被短路，不管第一个表达式结果是什么，都会继续运算下去。</p><h2 id="3-11-移位操作符"><a href="#3-11-移位操作符" class="headerlink" title="3.11 移位操作符"></a>3.11 移位操作符</h2><p> 移位操作符操作的也是二进制的“位”，移位操作符只能用来处理整数类型。移位操作也是二元操作符，一共有三种，左移操作符（&lt;&lt;），右移操作符（&gt;&gt;），无符号右移操作符（&gt;&gt;&gt;）<br>左移操作符是操作符左边的数向左移动操作符右边指定的位数，低位补0，右移操作符是操作符左边的数向右移动操作符右边指定的位数，其中正数高位补0，负数高位补1。无符号右移操作符是Java独有的一种，即不管正数还是负数，右移之后高位都补0。</p><h2 id="3-12-三元操作符-if-else"><a href="#3-12-三元操作符-if-else" class="headerlink" title="3.12 三元操作符 if-else"></a>3.12 三元操作符 if-else</h2><p>boolean-exp？value1：value2；</p><h2 id="3-1-3-字符串操作符-和"><a href="#3-1-3-字符串操作符-和" class="headerlink" title="3.1.3 字符串操作符 + 和 +="></a>3.1.3 字符串操作符 + 和 +=</h2><p>Java中可以使用+和+=连接String类型，并且当操作符左边你的数为String时，Java会试图将操作符右边的类型转换成String。</p><h2 id="3-14-使用操作符时常犯的的错误"><a href="#3-14-使用操作符时常犯的的错误" class="headerlink" title="3.14 使用操作符时常犯的的错误"></a>3.14 使用操作符时常犯的的错误</h2><p> 注意“=”和“==”的区别，以及逻辑运算符如（&amp;&amp;）和位运算符（&amp;）的区别和前自增“++i”和后自增“i++”的区别。注意“==”和“equals（）”的使用，注意别名现象。</p><h2 id="3-15-类型转换操作符"><a href="#3-15-类型转换操作符" class="headerlink" title="3.15 类型转换操作符"></a>3.15 类型转换操作符</h2><p>在c 和 c++ 类型转型非常容易溢出出错。但是在Java中是非常安全的。Java可以让我们把基本数据类型转换成别的基本数据类型。bool 除外。</p><h4 id="3-15-1-截尾和舍入"><a href="#3-15-1-截尾和舍入" class="headerlink" title="3.15.1 截尾和舍入"></a>3.15.1 截尾和舍入</h4><p>round() 对 double float 类型截取 round() 属于java.lang 的一部分 因此不需要额外的倒入。</p><h4 id="3-15-2-提升"><a href="#3-15-2-提升" class="headerlink" title="3.15.2 提升"></a>3.15.2 提升</h4><p>例如 : float 和 double 相乘 则结果提升尾 double 类型。</p><h2 id="3-16-java-没有sizeof"><a href="#3-16-java-没有sizeof" class="headerlink" title="3.16 java 没有sizeof"></a>3.16 java 没有sizeof</h2><p>C 和 C++ sizeof() 主要是为了移植 不同数据在不同机器位数不一样。所以必须要熟悉 一个字节占多少位。 Java 并不需要。 因为说有的数据类型在所有机器上是统一的。 <strong>它已经被设计在程序语言中了</strong>。</p><h2 id="3-17-操作符小结"><a href="#3-17-操作符小结" class="headerlink" title="3.17 操作符小结"></a>3.17 操作符小结</h2><p>java 遇到 int 最大值做乘法也会溢出 但是编译器并不会报错。<br><strong>当类型转换成较小的类型时候 必须要留意‘窄化转换’ 否则会丢失信息。</strong></p><h2 id="3-18-总结"><a href="#3-18-总结" class="headerlink" title="3.18 总结"></a>3.18 总结</h2><p>如果有c基础 学习Java语法并不难。Java语法类C。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第二章</title>
    <link href="/2019/07/16/Thinking-in-Java-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
    <url>/2019/07/16/Thinking-in-Java-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-一切都是对象"><a href="#第二章-一切都是对象" class="headerlink" title="第二章. 一切都是对象"></a>第二章. 一切都是对象</h1><h2 id="2-1-用引用操作对象"><a href="#2-1-用引用操作对象" class="headerlink" title="2.1 用引用操作对象"></a>2.1 用引用操作对象</h2><p>String s; 只是创建引用并初始化。String s = “asdf”; 这个代码只是把s初始化。引用到 “asdf” 的内存地址。类似于c的引用指针，只不过把对象抽象成内存地址。</p><h2 id="2-2-必须由你创建的所有对象"><a href="#2-2-必须由你创建的所有对象" class="headerlink" title="2.2 必须由你创建的所有对象"></a>2.2 必须由你创建的所有对象</h2><p>（这标题一看就是翻译过来的） 只看标题一脸蒙蔽……<br>String s = new String(“asdf”); 创建好对象了。</p><h4 id="2-2-1-储存到什么地方"><a href="#2-2-1-储存到什么地方" class="headerlink" title="2.2.1 储存到什么地方"></a>2.2.1 储存到什么地方</h4><p>有五种不同的地方可以存储数据：</p><ol><li>寄存器，这是最快的存储，在处理器内部</li><li>栈，这是存在随机访问内存，但是有处理器通过 栈指针 的直接支持 （一般存放确定好的静态变量，通过指针分配内存）</li><li>堆，这是通用的存储区域，所有 Java 对象都存储在这</li><li>常量存储，常量值一般都直接放置于程序代码内</li><li>非随机访问内存存储，完全存储在程序外的数据，和该程序是否在运行无关，且不受该程序控制<h4 id="2-2-2-基本类型"><a href="#2-2-2-基本类型" class="headerlink" title="2.2.2 基本类型"></a>2.2.2 基本类型</h4>介绍基本的数据类型以及占用的空间大小。<h4 id="2-2-3-Java重的数组"><a href="#2-2-3-Java重的数组" class="headerlink" title="2.2.3 Java重的数组"></a>2.2.3 Java重的数组</h4>Java 数组一定会被初始化并且无法访问其区间之外的部分，位置索引在运行时会被确认是否有效。（Java 看到null 就知道这个指针还没有指到某个对象。程序会报错。所以常规的数组错误在Java可以避免。）</li></ol><h2 id="2-3-永远不要销毁对象"><a href="#2-3-永远不要销毁对象" class="headerlink" title="2.3 永远不要销毁对象"></a>2.3 永远不要销毁对象</h2><p>Java 会自动帮我们销毁对象。</p><h4 id="2-3-1-作用域"><a href="#2-3-1-作用域" class="headerlink" title="2.3.1 作用域"></a>2.3.1 作用域</h4><p>作用域是由花括号 {} 的位置决定。作用域之内定义的变量在花括号结束前都可以被访问。</p><div class="hljs"><pre><code class="hljs undefined">&#123;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">12</span>;    &#123;        <span class="hljs-keyword">int</span> x = <span class="hljs-number">96</span>; <span class="hljs-comment">// Illegal</span>    &#125;&#125;</code></pre></div><p>编译器报错（x已经定义过了）。白话就是<strong>外面东西里面能用，里面的东西外边用不了</strong></p><h4 id="2-3-2-对象的作用域"><a href="#2-3-2-对象的作用域" class="headerlink" title="2.3.2 对象的作用域"></a>2.3.2 对象的作用域</h4><p>new 一个Java 对象 他可以存活在作用域之外。Java 有 垃圾回收 机制，它观察所有使用 new 创建的对象，判断哪些对象不再被引用，并释放那些不再被引用的对象。你可以只管创建对象，当你不使用他们时，他们会自行被释放。</p><h2 id="2-4-创建新的数据类型：-类"><a href="#2-4-创建新的数据类型：-类" class="headerlink" title="2.4 创建新的数据类型： 类"></a>2.4 创建新的数据类型： 类</h2><p>例如：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ATypeName</span> </span>&#123; <span class="hljs-comment">/* This is Class body */</span> &#125;ATypeName a = <span class="hljs-keyword">new</span> <span class="hljs-type">ATypeName</span>();</code></pre></div><p>类创建好了！ 就是这样！</p><h4 id="2-4-1-字段和方法"><a href="#2-4-1-字段和方法" class="headerlink" title="2.4.1 字段和方法"></a>2.4.1 字段和方法</h4><p>对象内可以创建字段和方法，但是普通字段不能在对象间共享</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataOnly</span> </span>&#123;    <span class="hljs-keyword">int</span> i;    <span class="hljs-keyword">double</span> d;    <span class="hljs-keyword">boolean</span> b;&#125;</code></pre></div><p>想要给对象里字段赋值 先引用一个对象 然后对其字段进行赋值操作。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-type">DataOnly</span> <span class="hljs-class"><span class="hljs-keyword">data</span> = new <span class="hljs-type">DataOnly</span>();</span><span class="hljs-class"><span class="hljs-keyword">data</span>.i = 47;</span><span class="hljs-class"><span class="hljs-keyword">data</span>.d = 1.1;</span><span class="hljs-class"><span class="hljs-keyword">data</span>.b = false;</span></code></pre></div><p>类中的某个成员是基本数据类型 即使没有初始化，Java也会给一个默认值。防止程序错误产生。</p><p>基本数据类型    默认值<br></p><p>boolean    false <br><br>char    ‘\u0000’ (null)<br><br>byte    (byte)0<br><br>short    (short)0<br><br>int    0<br><br>long    0L<br><br>float    0.0f<br><br>double    0.0d<br><br>但是上面说的不适用于 局部变量，局部作用域中不初始化会报错。</p><h2 id="2-5-方法、参数和返回值"><a href="#2-5-方法、参数和返回值" class="headerlink" title="2.5 方法、参数和返回值"></a>2.5 方法、参数和返回值</h2><p>介绍了方法的组成</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function">ReturnType <span class="hljs-title">methodName</span> <span class="hljs-params">(<span class="hljs-comment">/* Argument list */</span>)</span></span>&#123;    <span class="hljs-comment">/* Method body */</span>&#125;</code></pre></div><h4 id="2-5-1-参数列表"><a href="#2-5-1-参数列表" class="headerlink" title="2.5.1 参数列表"></a>2.5.1 参数列表</h4><p>方法的参数有强类型控制 如果是String 类型 则必须传String 对象 否则报错。</p><h2 id="2-6-构建一个Java程序"><a href="#2-6-构建一个Java程序" class="headerlink" title="2.6 构建一个Java程序"></a>2.6 构建一个Java程序</h2><h4 id="2-6-1-名字可见性"><a href="#2-6-1-名字可见性" class="headerlink" title="2.6.1 名字可见性"></a>2.6.1 名字可见性</h4><p>Java 为了保证命名唯一，采用了反转域名的规范建立包名，例如 net.mindview<br>.my.project.</p><h4 id="2-6-2-运用其他构件"><a href="#2-6-2-运用其他构件" class="headerlink" title="2.6.2 运用其他构件"></a>2.6.2 运用其他构件</h4><p>引用包写法</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span> java.util.*;</span></code></pre></div><h4 id="2-6-3-static-关键字"><a href="#2-6-3-static-关键字" class="headerlink" title="2.6.3 static 关键字"></a>2.6.3 static 关键字</h4><ol><li>static 修饰的变量是共享内存的</li><li>static 字段对每个类来说都只有一份存储空间，而非static对象则是每个对象都有一个存储空间。</li><li>static 好处是不创建任何对象就能调用它，这一点对定义main()入口文件很重要。</li></ol><h2 id="2-7-你的第一个Java程序"><a href="#2-7-你的第一个Java程序" class="headerlink" title="2.7 你的第一个Java程序"></a>2.7 你的第一个Java程序</h2><p>在每个程序文件的开头，都必须放置一个import语句</p><div class="hljs"><pre><code class="hljs undefined">import java.util.*;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">HelloDate</span> &#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">"Hello, it's: "</span>);        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">new</span> Date());    &#125;&#125;</code></pre></div><p>main()的形式是固定的，如上</p><p>虽然并为用到 args，但是Java编译器必须要这样做，因为 args 要用来存储命令行参数<br>（Java 最强大的优势之一就是它具有庞大的标准类库集）</p><h4 id="2-7-1-编译和运行"><a href="#2-7-1-编译和运行" class="headerlink" title="2.7.1 编译和运行"></a>2.7.1 编译和运行</h4><p>javac HelloDate.java <br><br>java HelloDate<br><br>注 ：<strong>JDK11以后 不需要用javac 编译 直接java 编译+运行 （Java也在像轻量改变）</strong> </p><h2 id="2-8-注释和嵌入式文档"><a href="#2-8-注释和嵌入式文档" class="headerlink" title="2.8 注释和嵌入式文档"></a>2.8 注释和嵌入式文档</h2><p>Java里提供两种注释风格。</p><p>第一种风格，注释以“/<em>”开始，随后是注释内容，并可跨越多行，最后以“</em>/”结束。<br><br>第二种风格，单行注释，以“//”开头，直到句末。</p><h4 id="2-8-1-注释文档"><a href="#2-8-1-注释文档" class="headerlink" title="2.8.1 注释文档"></a>2.8.1 注释文档</h4><p>javadoc 将文件同文档链接起来。将注释提取出来放在一个文件内。javadoc输出的是一个HTML文件，可以用Web浏览器查看。</p><h4 id="2-8-2-语法"><a href="#2-8-2-语法" class="headerlink" title="2.8.2 语法"></a>2.8.2 语法</h4><p>独立文档标签是一些以“@”字符开头的命令，且要置于注释行的最前面。<br>所有的javadoc命令都只能在“/<em>*”注释中出现，注释结束于“</em>/”。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">/** A class comment */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Documentation1</span> </span>&#123;    <span class="hljs-comment">/** A field comment */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> i;    <span class="hljs-comment">/** A method comment */</span>    <span class="hljs-keyword">public</span> void f() &#123;&#125;&#125;</code></pre></div><p><strong>javadoc只能为public和protected成员进行文档注释。private和包内可访问成员的注释会被忽略掉。可以使用-private进行标记，可以将private成员的注释也包括在内。</strong></p><h4 id="2-8-3-嵌入式HTML"><a href="#2-8-3-嵌入式HTML" class="headerlink" title="2.8.3 嵌入式HTML"></a>2.8.3 嵌入式HTML</h4><p>所有类型的注释文档都支持嵌入式HTML。</p><h4 id="2-8-4-一些标签示例"><a href="#2-8-4-一些标签示例" class="headerlink" title="2.8.4 一些标签示例"></a>2.8.4 一些标签示例</h4><ol><li><p>@see：引用其他类</p><div class="hljs"><pre><code class="hljs undefined">/** * <span class="hljs-variable">@see</span> classname * <span class="hljs-variable">@see</span> fully-qualified-classname * <span class="hljs-variable">@see</span> fully-qualified-classname<span class="hljs-comment">#method-name</span> *<span class="hljs-regexp">/</span></code></pre></div></li><li><p>{@link package.class#member label} 该标签与@see极其相似，只是它用于行内，并且用“label”作为超链接文本。</p></li><li><p>{@docRoot} 该标签产生到文档根目录的相对路径，用于文档树页面的显式超链接。</p></li><li><p>{@inheritDoc}<br>该标签从当前这个类的最直接的基类中继承相关文档到当前的文档注释中。</p></li><li><p>@version 代码版本的相关信息</p></li><li><p>@author 作者</p></li><li><p>@since 指定程序最早使用的版本</p></li><li><p>@param 参数</p></li><li><p>@return 返回值</p></li><li><p>@throws 产生异常的相关信息。</p></li><li><p>@deprecated 新特性改进。</p><h4 id="2-8-5-文档示例"><a href="#2-8-5-文档示例" class="headerlink" title="2.8.5 文档示例"></a>2.8.5 文档示例</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">//:first/HelloDate.java</span><span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-comment"><span class="markdown">/**<span class="hljs-bullet"> *  </span>The first Thinking in Java example program.<span class="hljs-bullet"> *  </span>Displays </span>a<span class="markdown"> string and today's date.<span class="hljs-bullet"> * </span>@author xjd<span class="hljs-bullet"> * </span>@author www.xxx.com.cn<span class="hljs-bullet"> * </span>@version 4.0 */</span></span>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloDate</span> </span>&#123;    <span class="hljs-comment"><span class="markdown">/**<span class="hljs-bullet">     *  </span>Entry point to class &amp; application<span class="hljs-bullet">     * </span>@param args array of string arguments<span class="hljs-bullet">     * </span>@throws exceptions No exceptions thrown<span class="hljs-code">     */</span></span></span>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;        System.out.println(<span class="hljs-string">"Hello, it's: "</span>);        System.out.println(<span class="hljs-keyword">new</span> Date());    &#125;<span class="hljs-comment">/* Output:(55% match)    Hello,it's:    Thu Jun 28 17:56:45 CST 2018    */</span><span class="hljs-comment">//:~</span>&#125;</code></pre></div></li></ol><p>第一行 用一个“:”作为特殊几号说明这是包含原文件名的注释行。</p><p>“///:~”标志源代码清单的结束。</p><p>/*Output标签表示输出的开始部分将由这个文件生成，通过这种形式，它会自动地测试以验证其准确性。</p><p>(55% match)在向测试系统说明程序的当前运行和醒一次运行的输出存在这很大差异，55%是两次输出与其的相关性程度。</p><h2 id="2-9-编码风格"><a href="#2-9-编码风格" class="headerlink" title="2.9 编码风格"></a>2.9 编码风格</h2><p>类名 首字母大写的<strong>驼峰风格</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllTheColorsOfTheRainbow</span>&#123;</span>    <span class="hljs-keyword">int</span> anIntegerRepresentingColors;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">changeTheHueOfTheColor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newHue)</span> </span>&#123;&#125;&#125;</code></pre></div><h2 id="2-10-总结"><a href="#2-10-总结" class="headerlink" title="2.10 总结"></a>2.10 总结</h2><p>大家了解如何编写一个简单程序的Java编程知识，对Java语言及它的一些基本思想也有了一个总体认识。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thinking in Java 第一章</title>
    <link href="/2019/07/16/Thinking-in-Java-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
    <url>/2019/07/16/Thinking-in-Java-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-对象导论"><a href="#第一章-对象导论" class="headerlink" title="第一章.对象导论"></a>第一章.对象导论</h1><h2 id="1-1-抽象过程"><a href="#1-1-抽象过程" class="headerlink" title="1.1 抽象过程"></a>1.1 抽象过程</h2><p>  总结一点 从一门脚本语言(php,python,javascript)转学到一门工业级语言，必须要转变的思想 就是 <strong>万物皆为对象</strong> </p><h2 id="1-2-每个对象都有一个接口"><a href="#1-2-每个对象都有一个接口" class="headerlink" title="1.2 每个对象都有一个接口"></a>1.2 每个对象都有一个接口</h2><p>  一张图清晰概括所有内容 ！<br>  <img src="https://github.com/znbsmd/photo/raw/master/object-interface.jpeg" srcset="/img/loading.gif" alt="avatar"></p><h2 id="1-3-每个对象都提供服务"><a href="#1-3-每个对象都提供服务" class="headerlink" title="1.3 每个对象都提供服务"></a>1.3 每个对象都提供服务</h2><p>   将对象看作是服务提供者<br></p><p>   举例: 一个记账系统 将功能拆分成3个对象 <br></p><ol><li>输入屏幕对象</li><li>执行计算对象</li><li>打印发票对象<br></li></ol><p>从而实现将功能简单化 和加强代码可用性和复用性，每个对象都看成一种服务，它会使其对象以适应其设计的过程简单的多。</p><h2 id="1-4-被隐藏的具体实现"><a href="#1-4-被隐藏的具体实现" class="headerlink" title="1.4 被隐藏的具体实现"></a>1.4 被隐藏的具体实现</h2><ol><li><p>对于客户端开发者（业务程序员）不需要关注类创建者（底层服务类）如何实现，只需要关注如何快速开发应用，拿来即用。从而减少程序bug 减轻开发任务。</p></li><li><p>对于类创建者（底层服务类）改变内部工作方式而不用担心影响到 客户端开发者（业务程序员）例如 优化 维护。可以清晰的分离得以保护。</p></li><li><p>public、private、protected 关键字 </p></li><li><p>java 默认访问权限 -&gt; 包访问权限</p></li></ol><h2 id="1-5-复用具体实现"><a href="#1-5-复用具体实现" class="headerlink" title="1.5 复用具体实现"></a>1.5 复用具体实现</h2><p>此节讲的比较抽象。 引用书中的一句话做为总结 :<br><br>最简单的复用某个类的方式就是直接使用该类的一个对象，将这个类的一个对象放在一个新类中。新的类可以由任意的其他对象实现想要的功能方式所组成。这种概念就是组合。这种组合关系就是复用。（简单理解就是下一节说的继承……）</p><h2 id="1-6继承"><a href="#1-6继承" class="headerlink" title="1.6继承"></a>1.6继承</h2><p> 继承创造了新的类，也可以在新的类中添加新的方法。完成代码复用。</p><h4 id="1-6-1-“是一个”-与-“像是一个”-关系"><a href="#1-6-1-“是一个”-与-“像是一个”-关系" class="headerlink" title="1.6.1 “是一个” 与 “像是一个” 关系"></a>1.6.1 “是一个” 与 “像是一个” 关系</h4><p>文字表达很啰嗦 用书中一张图足以总结 <img src="https://github.com/znbsmd/photo/raw/master/1.6.1.jpeg" srcset="/img/loading.gif" alt="avatar"></p><p>热力泵 是新类 空调是原有类 新cool() 优化替换 原有 cool() 做为”纯粹替换”。</p><h2 id="1-7-伴随多态的可互换对象"><a href="#1-7-伴随多态的可互换对象" class="headerlink" title="1.7 伴随多态的可互换对象"></a>1.7 伴随多态的可互换对象</h2><ol><li>java 多态的特性 基于 1.5 复用 和 1.6 继承 的更深一层的扩展 继承 把最基类的对象泛化 具体解析可google java 多态特性 网站有超级白话和详细说明帮助理解多态 。</li><li>后期绑定概念 : 非面向对象程序采用<strong>前期绑定</strong>  面向对象程序采用<strong>后期绑定</strong> 这样才能在一个对象发送消息时候才能知道这条消息应该做什么</li></ol><h2 id="1-8-单根继承结构"><a href="#1-8-单根继承结构" class="headerlink" title="1.8 单根继承结构"></a>1.8 单根继承结构</h2><p>在单继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型，3个单根继承的优点 :</p><ol><li>所有对象都可以很容易地在堆上创建</li><li>参数传递也得到了极大的简化</li><li>垃圾回收器的实现变得容易得多</li></ol><h2 id="1-9-容器"><a href="#1-9-容器" class="headerlink" title="1.9 容器"></a>1.9 容器</h2><p>为了解决 存储多个对象 为多个对象创造多个空间问题 容器很好的解决了这个问题。例如 : List、Map、Set 以及诸如队列、树、堆栈等更多的数据结构。</p><h4 id="1-9-1-参数化类型"><a href="#1-9-1-参数化类型" class="headerlink" title="1.9.1 参数化类型"></a>1.9.1 参数化类型</h4><p>容器的参数化类型机制：创建的容器，知道自己所保存的对象的类型，从而不需要向下转型以及消除犯错误的可能。这种机制在java中 ，称为泛型。<br> ArrayList<shape>  shapes = new ArrayList<shape>( );</shape></shape></p><h2 id="1-10-对象的创建和生命期"><a href="#1-10-对象的创建和生命期" class="headerlink" title="1.10 对象的创建和生命期"></a>1.10 对象的创建和生命期</h2><p>java对象创建一种是创建在栈上 在编译前确定 追求执行速度 但是牺牲了灵活性 分配的内存大小时候固定的。另一种创建对象存放在堆上 称为动态分配方式。为防止内存泄漏 java编译器 采用 垃圾回收器 机制 并自动销毁。</p><h2 id="1-11-异常处理-：-处理错误"><a href="#1-11-异常处理-：-处理错误" class="headerlink" title="1.11 异常处理 ： 处理错误"></a>1.11 异常处理 ： 处理错误</h2><p>java 内置了异常处理，并且强制你使用它。</p><h2 id="1-12-并发编程"><a href="#1-12-并发编程" class="headerlink" title="1.12 并发编程"></a>1.12 并发编程</h2><p>采用多线程 处理并发。弊端就是共享资源。所以 在资源使用期间加锁 完成后释放。java并发也是内置在语言中。</p><h2 id="1-13-java与internet"><a href="#1-13-java与internet" class="headerlink" title="1.13 java与internet"></a>1.13 java与internet</h2><p>java 解决了在万维网上的程序设计问题。所谓的互联网。</p><h4 id="1-13-1-web-是什么"><a href="#1-13-1-web-是什么" class="headerlink" title="1.13.1 web 是什么"></a>1.13.1 web 是什么</h4><p>就是服务器，使得 客户和服务器 在同一个网络中进行交互。</p><h4 id="1-13-2-客户端编程"><a href="#1-13-2-客户端编程" class="headerlink" title="1.13.2 客户端编程"></a>1.13.2 客户端编程</h4><p>介绍了脚本语言所解决的问题是有限的，其余的还需要java去解决。</p><h4 id="1-13-3-服务端编程"><a href="#1-13-3-服务端编程" class="headerlink" title="1.13.3 服务端编程"></a>1.13.3 服务端编程</h4><p>复杂可用的系统还需要java去实现，具体论述在《企业Java编程思想》中论述。</p><h2 id="1-14-总结"><a href="#1-14-总结" class="headerlink" title="1.14 总结"></a>1.14 总结</h2><p>编写良好的java代码比等价的过程型语言要简单，也易于理解。最后要清楚认识到 oop和java 能否解决你的问题，要有清楚的认识。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
